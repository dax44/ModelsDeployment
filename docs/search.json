[
  {
    "objectID": "Wdrażanie modeli uczenia maszynowego.html",
    "href": "Wdrażanie modeli uczenia maszynowego.html",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych."
  },
  {
    "objectID": "Wdrażanie modeli uczenia maszynowego.html#przebieg-prac-nad-wdrożeniem-modelu",
    "href": "Wdrażanie modeli uczenia maszynowego.html#przebieg-prac-nad-wdrożeniem-modelu",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych."
  },
  {
    "objectID": "wyk4.html",
    "href": "wyk4.html",
    "title": "Wykład 4",
    "section": "",
    "text": "Shiny oferuje wiele możliwości do tworzenia interaktywnych i estetycznych layoutów dla aplikacji. Można korzystać z różnych funkcji i elementów interfejsu użytkownika, aby dostosować wygląd i układ strony. Poniżej przedstawiam kilka kluczowych możliwości i technik budowy layoutów w Shiny:\n\n\nFluid Grid Layout:\n\n\nfluidPage() to podstawowa funkcja służąca do tworzenia responsywnego układu strony.\nObejmuje różne sekcje takie jak titlePanel, sidebarLayout, mainPanel itp., które pomagają w organizacji i strukturyzacji interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Elementy boczne, np. suwaki, przyciski\n    ),\n    mainPanel(\n      # Główna zawartość, np. wykresy, tabele\n    )\n  )\n)\n\n\n\n\nColumn Layout:\n\nMożna używać column() do podziału obszaru głównego na kolumny, co pozwala na bardziej elastyczny układ strony.\nTo przydatne, gdy chcemy umieścić różne elementy obok siebie.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  column(\n    width = 4,\n    # Pierwsza kolumna\n  ),\n  column(\n    width = 8,\n    # Druga kolumna\n  )\n)\n\n\n\n\nTabset Panel:\n\n\ntabsetPanel() umożliwia organizację interfejsu za pomocą zakładek.\nKażda zakładka może mieć własny zestaw elementów interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  tabsetPanel(\n    tabPanel(\"Zakładka 1\", \n             # Zawartość pierwszej zakładki),\n    tabPanel(\"Zakładka 2\", \n             # Zawartość drugiej zakładki)\n  )\n)\n\n\n\n\nHTML i CSS:\n\nShiny umożliwia wbudowanie kodu HTML i CSS do dostosowywania wyglądu.\nFunkcje takie jak HTML() pozwalają na wstawienie kodu HTML bezpośrednio do interfejsu użytkownika.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  HTML(\"&lt;h2&gt;Własny tytuł HTML&lt;/h2&gt;\")\n)\n\n\n\n\nDashboard Layout:\n\nBiblioteka shinydashboard dostarcza narzędzi do tworzenia układów przypominających klasyczne dashboardy.\nObejmuje funkcje takie jak dashboardPage(), dashboardHeader(), dashboardSidebar().\n\n\nKodlibrary(shinydashboard)\n\nui &lt;- dashboardPage(\n  dashboardHeader(title = \"Dashboard Title\"),\n  dashboardSidebar(\n    # Elementy boczne, np. suwaki, przyciski\n  ),\n  dashboardBody(\n    # Główna zawartość, np. wykresy, tabele\n  )\n)"
  },
  {
    "objectID": "wyk4.html#instalacja-edytora-shiny",
    "href": "wyk4.html#instalacja-edytora-shiny",
    "title": "Wykład 4",
    "section": "Instalacja edytora Shiny",
    "text": "Instalacja edytora Shiny\nPolecam instalować najnowszą wersję (dystrybucję) pakietu shinyuieditor ze strony Github autora.\n\nKodif (!requireNamespace(\"remotes\", quietly = TRUE))\n    install.packages(\"remotes\")\n\n# Install using the remotes package\nremotes::install_github(\"rstudio/shinyuieditor\")"
  },
  {
    "objectID": "wyk4.html#użycie-edytora-shiny",
    "href": "wyk4.html#użycie-edytora-shiny",
    "title": "Wykład 4",
    "section": "Użycie edytora Shiny",
    "text": "Użycie edytora Shiny\nAby użyć po raz pierwszy edytora interfejsu Shiny należy użyć następującej komendy:\n\nKodshinyuieditor::launch_editor(app_loc = \"shiny-app/\")\n\n\nJeśli w katalogu roboczym znajduje się aplikacja umieszczona w katalogu roboczym shiny-app, to edytor pozwoli na edycję istniejącej już aplikacji1. Warunek odpalenia shinyuieditor dla istniejącej aplikacji jest to, że wskazany katalog zawiera tylko plik app.R. Jeśli wskazany katalog nie zawiera niczego, edytor odpala się z możliwością wyboru wyglądu.\n\nKodshinyuieditor::launch_editor(app_loc = \"test_shinyuieditor/\")\n\n\n\n\nWygląd po wybraniu wyglądu aplikacji\n\nDodawanie elementów do aplikacji\nPo wyborze wyglądu głównego można przystąpić do edycji elementów wyglądu. Warto zacząć od tutorialu edytora klikając w prawym górnym rogu przycisk “Tour App”. Następnie można przystąpić do edycji wyglądu wg własnego uznania (patrzy przykład poniżej)\n\nAby dodać nowy element interfejsu użytkownika do aplikacji, należy przeciągnąć żądany element z panelu “Elements”. Miejsca, w których można umieścić element, zostaną podświetlone (jeśli nie ma dostępnych miejsc, spróbuj dodać nowy wiersz lub kolumnę do aplikacji, aby utworzyć miejsce). Po przeciągnięciu elementu na dostępny obszar, zwolnij go, aby dodać go do aplikacji.\nPrzemieszczanie elementów aplikacji\nKliknij i przeciągnij element ui, który chcesz przenieść. Podobnie jak w przypadku dodawania elementu, dostępne pozycje do przeniesienia elementu zostaną podświetlone. Przeciągnij element do żądanej nowej pozycji i upuść, aby go przenieść.\n\nWybór elementów aplikacji\nWybierz element, klikając wewnątrz niego. Po wybraniu elementu zostanie on oznaczony niebieskim konturem, a panel “Properties” zostanie zaktualizowany o szczegóły dotyczące elementu. Alternatywnie można wybrać element nadrzędny aktualnie wybranego elementu, klikając nazwę elementu nadrzędnego w wizualizacji ścieżki elementu w górnej części panelu “Properties”.\n\nUsuwanie elementów aplikacji\nWybierz element, po wybraniu elementu kliknij przycisk “Delete Element” w dolnej części panelu “Properties”. Niektóre elementy, takie jak grid_card(), będą również wyświetlać przyciski usuwania bezpośrednio na samym elemencie, gdy nie ma w nim żadnych elementów podrzędnych. Możesz również usunąć element za pomocą klawisza delete/backspace.\n\nAktualizacja ustwień elementów aplikacji\nWybierz element, po jego wybraniu zaktualizuj ustawienia za pomocą panelu “Properties”. Gdy dane wejściowe zostaną zaktualizowane, zmiany zostaną automatycznie zapisane i odzwierciedlone w skrypcie aplikacji i oknie podglądu na żywo.\n\nWyświetl rozmiary elementów aplikacji\nNajechanie myszą na lewy koniec wiersza lub górę kolumny powoduje wyświetlenie widżetu rozmiaru.\n\nDodawanie wierszy i kolumn do aplikacji\nOtwórz widżet rozmiaru wiersza lub kolumny sąsiadujący z miejscem, w którym chcesz dodać nowy wiersz lub kolumnę. Na obu końcach widżetu znajdują się przyciski plus (+), których kliknięcie spowoduje dodanie wiersza lub kolumny po odpowiednich stronach istniejącego wiersza lub kolumny.\n\nUsuwanie wierszy i kolumn aplikacji\nOtwórz widżet rozmiaru wiersza lub kolumny, który chcesz usunąć. Następnie kliknij czerwoną ikonę kosza, aby usunąć ten wiersz z układu. Jeśli ikona kosza jest wyszarzona, wiersz lub kolumna nie mogą zostać usunięte z powodu nazwanych obszarów siatki, które w całości się w nich znajdują. Najechanie myszką na zaszarzony przycisk spowoduje wskazanie tych obszarów siatki, dzięki czemu będzie można je usunąć lub przenieść w inne miejsce.\n\nZmiana rozmiarów wierszy i kolumn aplikacji\n\nLub też inaczej, otwórz widżet zmiany rozmiaru wiersza/kolumny Użyj kontrolek wprowadzania jednostek css w tym widżecie, aby zaktualizować rozmiar wiersza lub kolumny.\n\nWycofanie zmian w aplikacji\nUżyj przycisku cofnij dostępnego w prawym górnym rogu aplikacji, aby przywrócić interfejs użytkownika aplikacji do stanu sprzed ostatniej wprowadzonej zmiany. Jeśli chcesz przywrócić właśnie cofniętą zmianę, kliknij przycisk ponów po prawej stronie. Zarówno cofnięcie, jak i ponowienie można również wykonać za pomocą skrótów klawiaturowych, odpowiednio cmd/ctrl + z i cmd/ctrl + shift + z.\n\nZatrzymanie edytora aplikacji\nDopóki argument stop_on_browser_close jest ustawiony na domyślną wartość TRUE, wówczas wszystko, co należy zrobić, aby zatrzymać edytor, to zamknąć kartę/okno przeglądarki, w której edytor jest aktualnie otwarty. Innym sposobem zakończenia jest przerwanie serwera edytora poprzez naciśnięcie Control/Command + c w konsoli R używanej do uruchomienia edytora."
  },
  {
    "objectID": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "href": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "title": "Wykład 4",
    "section": "Zmiany w edytorze a zmiany w kodzie",
    "text": "Zmiany w edytorze a zmiany w kodzie\nNależy pamiętać, że każda zmiana w edytorze skutkuje zmianami w kodzie definiującym aplikację. W drugą stronę działa to analogicznie. Każda zmiana w kodzie znajduje swoje odwzorowanie w edytorze i preview."
  },
  {
    "objectID": "wyk4.html#podsumowanie-funkcjonalności-edytora-aplikacji",
    "href": "wyk4.html#podsumowanie-funkcjonalności-edytora-aplikacji",
    "title": "Wykład 4",
    "section": "Podsumowanie funkcjonalności edytora aplikacji",
    "text": "Podsumowanie funkcjonalności edytora aplikacji\nshinyuieditor, jako narzędzie do projektowania interfejsu użytkownika dla aplikacji Shiny w R, ma swoje zalety i wady. Oto niektóre z nich:\nZalety:\n\nŁatwość Użycia - umożliwia użytkownikom, w tym osobom nieprogramującym, łatwe tworzenie i modyfikowanie interfejsów użytkownika poprzez graficzny interfejs, co obniża próg wejścia do tworzenia aplikacji Shiny.\nSzybki prototyping - pomaga w szybkim prototypowaniu aplikacji przez wizualne eksperymentowanie z różnymi układami i elementami UI, co jest szczególnie przydatne w fazie projektowania.\nInteraktywność bez bezpośredniego kodowania - ułatwia dodawanie interaktywnych elementów do aplikacji bez konieczności bezpośredniego pisania kodu, co może przyspieszyć rozwój projektu.\nEdukacyjne korzyści - może służyć jako narzędzie edukacyjne dla osób uczących się tworzenia aplikacji Shiny, pozwalając na lepsze zrozumienie, jak różne komponenty UI współpracują ze sobą.\nWady:\n\nOgraniczenia dostosowywania - graficzne interfejsy użytkownika mogą ograniczać możliwości dostosowania w porównaniu do bezpośredniego kodowania. Zaawansowane funkcje i niestandardowe zachowania mogą wymagać ręcznej edycji kodu.\nZależność od konkretnej implementacji - narzędzie takie jak shinyuieditor może nie być stale aktualizowane lub wspierane, co oznacza, że może nie być kompatybilne z najnowszymi wersjami Shiny lub R.\nKrzywa uczenia się dla zaawansowanych funkcji - mimo że narzędzie to obniża próg wejścia, zaawansowane funkcje Shiny mogą nadal wymagać solidnej wiedzy o R i Shiny, co oznacza, że użytkownicy będą musieli inwestować czas w naukę poza używaniem samego edytora.\n\nPodsumowując, shinyuieditor może być bardzo pomocny dla osób rozpoczynających pracę z Shiny oraz dla szybkiego prototypowania interfejsów użytkownika, ale dla zaawansowanych i wyspecjalizowanych potrzeb projektowych, bezpośrednie programowanie w R może oferować większą elastyczność i kontrolę."
  },
  {
    "objectID": "wyk4.html#tematy-aplikacji",
    "href": "wyk4.html#tematy-aplikacji",
    "title": "Wykład 4",
    "section": "Tematy aplikacji",
    "text": "Tematy aplikacji\nPakiet bslib w języku R jest narzędziem zaprojektowanym, aby ułatwić tworzenie estetycznie atrakcyjnych i responsywnych interfejsów użytkownika w aplikacjach Shiny oraz w dokumentach R Markdown i Quarto. Jego głównym celem jest integracja z Bootstrap, popularnym frameworkiem CSS do tworzenia responsywnych i mobilnych pierwszych projektów internetowych. Dzięki bslib, użytkownicy mogą łatwo dostosować wygląd swoich aplikacji Shiny i dokumentów R Markdown, korzystając z szerokiej gamy tematów i opcji stylizacji dostępnych w Bootstrapie.\nPakiet ten umożliwia również tworzenie niestandardowych tematów lub modyfikowanie istniejących, co pozwala na precyzyjne dostosowanie estetyki projektu do specyficznych wymagań i preferencji. Dzięki zintegrowanemu wsparciu dla różnych wersji Bootstrapa, bslib pozwala deweloperom wybierać między różnymi wersjami tego frameworka, co jest szczególnie przydatne w kontekście zachowania kompatybilności i eksplorowania nowych możliwości projektowych.\n\n\nPrzykład zastosowania bslib\n\nPodsumowując, pakiet bslib jest niezastąpionym narzędziem dla twórców aplikacji Shiny i autorów dokumentów R Markdown/Quarto, którzy chcą podnieść wizualną jakość swoich projektów, nie zagłębiając się głęboko w szczegóły implementacji CSS. Ułatwia on szybką i efektywną personalizację wyglądu, poprawiając jednocześnie ogólną użyteczność i dostępność tworzonych aplikacji oraz dokumentów.\nCzcionki\nPakiet bslib ułatwia również integrację i dostosowanie czcionek w aplikacjach Shiny. Umożliwia to łatwe włączanie czcionek z zewnętrznych źródeł, takich jak Google Fonts, co pozwala na bardziej spersonalizowane i unikalne projekty interfejsu użytkownika. Dzięki bslib, programiści mogą precyzyjnie kontrolować wygląd tekstów w swoich aplikacjach, w tym styl, rozmiar i waga czcionek, co przyczynia się do lepszej czytelności i estetyki.\nWykresy\nbslib współpracuje również z bibliotekami do tworzenia wykresów w R, takimi jak ggplot2, umożliwiając lepszą integrację wizualną wykresów z resztą aplikacji. Dzięki temu kolory, czcionki i inne elementy stylistyczne wykresów mogą być spójne z ogólnym motywem aplikacji, co przyczynia się do jednolitego i profesjonalnego wyglądu. Możliwość dostosowania wyglądu wykresów bez bezpośredniego manipulowania każdym elementem pozwala na szybsze i bardziej efektywne tworzenie atrakcyjnych wizualizacji danych.\nPodsumowując, bslib znacząco rozszerza możliwości personalizacji i ulepszania interfejsów użytkownika w aplikacjach Shiny, R Markdown i innych treściach dynamicznych R. Poprzez ułatwienie dostosowywania tematów, integracji czcionek i harmonizacji wyglądu wykresów, bslib pozwala na tworzenie bardziej spersonalizowanych, atrakcyjnych i spójnych projektów bez potrzeby zaawansowanej znajomości CSS czy JavaScript."
  },
  {
    "objectID": "wyk4.html#footnotes",
    "href": "wyk4.html#footnotes",
    "title": "Wykład 4",
    "section": "Przypisy",
    "text": "Przypisy\n\nNależy jednak, że musi to być aplikacja przygotowana wg schematu generowanego przez shinyuieditor , bo inaczej nie będzie ona działać. Przykładowo użycie launch_editor do stockVis nie chciało działać.↩︎"
  },
  {
    "objectID": "wyk3.html",
    "href": "wyk3.html",
    "title": "Wykład 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w języku R i Python (od niedawna, jak jednak będę się skupiał na R). Jest to obszar, w którym inżynierowie danych i analitycy mogą tworzyć interaktywne aplikacje internetowe, wykorzystując całą swoją wiedzę i analizy zgromadzoną w języku R. Dzięki Shiny, użytkownicy mogą łatwo przekształcać swoje skrypty i modele w interaktywne aplikacje internetowe, bez konieczności posiadania wcześniejszego doświadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera się na paradygmacie “reactive programming”, co oznacza, że aplikacje tworzone przy jego użyciu są dynamiczne i reagują na zmiany danych w czasie rzeczywistym. Oznacza to, że użytkownicy mogą manipulować danymi i obserwować, jak te zmiany wpływają na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementów Shiny jest jego prostota użycia. Za pomocą kilku linii kodu w języku R, można stworzyć interaktywny interfejs, który pozwala użytkownikowi na łatwe eksplorowanie danych. Warto również podkreślić, że Shiny integruje się z istniejącymi narzędziami analizy danych w R, takimi jak ggplot2 czy dplyr, co ułatwia korzystanie z istniejących umiejętności programistycznych.\nShiny oferuje różnorodne elementy interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umożliwiając tworzenie rozbudowanych interfejsów. Ponadto, framework ten obsługuje również funkcje uwierzytelniania i autoryzacji, co pozwala kontrolować dostęp do aplikacji w zależności od potrzeb.\nDzięki Shiny, analiza danych staje się bardziej dostępna i przyjazna dla użytkownika końcowego, umożliwiając interaktywną eksplorację wyników analizy danych bez konieczności głębokiego zrozumienia kodu R. To narzędzie jest szczególnie przydatne dla osób pracujących w dziedzinie analizy danych, statystyki, czy nauk społecznych, które chcą szybko i efektywnie udostępnić swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#czym-jest-shiny",
    "href": "wyk3.html#czym-jest-shiny",
    "title": "Wykład 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w języku R i Python (od niedawna, jak jednak będę się skupiał na R). Jest to obszar, w którym inżynierowie danych i analitycy mogą tworzyć interaktywne aplikacje internetowe, wykorzystując całą swoją wiedzę i analizy zgromadzoną w języku R. Dzięki Shiny, użytkownicy mogą łatwo przekształcać swoje skrypty i modele w interaktywne aplikacje internetowe, bez konieczności posiadania wcześniejszego doświadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera się na paradygmacie “reactive programming”, co oznacza, że aplikacje tworzone przy jego użyciu są dynamiczne i reagują na zmiany danych w czasie rzeczywistym. Oznacza to, że użytkownicy mogą manipulować danymi i obserwować, jak te zmiany wpływają na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementów Shiny jest jego prostota użycia. Za pomocą kilku linii kodu w języku R, można stworzyć interaktywny interfejs, który pozwala użytkownikowi na łatwe eksplorowanie danych. Warto również podkreślić, że Shiny integruje się z istniejącymi narzędziami analizy danych w R, takimi jak ggplot2 czy dplyr, co ułatwia korzystanie z istniejących umiejętności programistycznych.\nShiny oferuje różnorodne elementy interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umożliwiając tworzenie rozbudowanych interfejsów. Ponadto, framework ten obsługuje również funkcje uwierzytelniania i autoryzacji, co pozwala kontrolować dostęp do aplikacji w zależności od potrzeb.\nDzięki Shiny, analiza danych staje się bardziej dostępna i przyjazna dla użytkownika końcowego, umożliwiając interaktywną eksplorację wyników analizy danych bez konieczności głębokiego zrozumienia kodu R. To narzędzie jest szczególnie przydatne dla osób pracujących w dziedzinie analizy danych, statystyki, czy nauk społecznych, które chcą szybko i efektywnie udostępnić swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#części-składowe-aplikacji-shiny",
    "href": "wyk3.html#części-składowe-aplikacji-shiny",
    "title": "Wykład 3",
    "section": "Części składowe aplikacji Shiny",
    "text": "Części składowe aplikacji Shiny\nDo poprawnego działania aplikacji Shiny konieczne jest zainstalowanie pakietu shiny.\nW każdej aplikacji Shiny można wyróżnić trzy podstawowe części:\n\n\nUI (Interfejs Użytkownika):\n\n\nElementy Interfejsu - definiują strukturę interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele, wykresy itp.\n\nUkład Strony - określa rozmieszczenie i stylizację elementów na stronie.\n\nDefinicja UI - jest to miejsce, w którym programista określa, jak mają wyglądać interaktywne elementy widoczne dla użytkownika.\n\n\n\nPrzykład definicji UI w Shiny może wyglądać następująco:\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Moja Aplikacja Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"slider\", \"Wybierz wartość:\", min = 1, max = 100, value = 50)\n    ),\n    mainPanel(\n      plotOutput(\"wykres\")\n    )\n  )\n)\n\n\n\n\nServer (Serwer):\n\n\nFunkcje Obliczeniowe - zawierają kod R odpowiedzialny za przetwarzanie danych, generowanie wyników oraz reakcję na interakcje użytkownika.\n\nReaktywność - serwer Shiny korzysta z obiektów reaktywnych do śledzenia zmian w danych i automatycznego aktualizowania wyników w interfejsie użytkownika.\n\n\n\nPrzykład definicji serwera w Shiny może wyglądać tak:\n\nKodserver &lt;- function(input, output) {\n  output$wykres &lt;- renderPlot({\n    dane &lt;- seq(1, input$slider)\n    plot(dane, main = \"Wykres dynamiczny\")\n  })\n}\n\n\n\n\nSesja Shiny:\n\n\nKomunikacja UI-Server - każda sesja Shiny umożliwia komunikację między interfejsem użytkownika a serwerem, przesyłanie danych i instrukcji między dwiema warstwami aplikacji.\n\nŻywotność Aplikacji - sesja utrzymuje stan aplikacji, umożliwiając śledzenie i reakcję na zmiany dokonywane przez użytkownika.\n\n\n\nPrzykład uruchamiania aplikacji Shiny zdefiniowanej powyżej:\n\nKodshinyApp(ui, server)\n\n\nDo zapoznania się z możliwościami aplikacji Shiny zachęcam do uruchomienia następujących przykładów aplikacji.\n\nKodrunExample(\"01_hello\")      # a histogram\nrunExample(\"02_text\")       # tables and data frames\nrunExample(\"03_reactivity\") # a reactive expression\nrunExample(\"04_mpg\")        # global variables\nrunExample(\"05_sliders\")    # slider bars\nrunExample(\"06_tabsets\")    # tabbed panels\nrunExample(\"07_widgets\")    # help text and submit buttons\nrunExample(\"08_html\")       # Shiny app built from HTML\nrunExample(\"09_upload\")     # file upload wizard\nrunExample(\"10_download\")   # file download wizard\nrunExample(\"11_timer\")      # an automated timer\n\n\n\n\nPrzykład wywołania przykładu ‘01_hello’\n\nReaktywność w Shiny\nReaktywność jest kluczowym konceptem w Shiny, który pozwala interakcji między komponentami interfejsu użytkownika a kodem R. W Shiny, gdy użytkownik wykonuje interakcję (na przykład klikając przycisk, wpisując tekst, wybierając wartość z rozwijanej listy), aplikacja automatycznie reaguje na tę interakcję. To oznacza, że wynik generowany przez aplikację jest zmienny i dynamicznie dostosowuje się do akcji użytkownika, bez konieczności odświeżania strony.\nReaktywność w Shiny opiera się na tzw. “reactive expressions” oraz “reactive conductors”. “Reactive expressions” są funkcjami, które automatycznie aktualizują wynik w zależności od zmian w ich zmiennych wejściowych. Z kolei “reactive conductors” pozwalają na definiowanie reakcji na zmiany wartości w interfejsie użytkownika.\nPrzykłady reaktywności w Shiny obejmują dynamiczne odświeżanie wykresów w zależności od wartości wybranych przez użytkownika, automatyczne dostosowanie zakresu danych w oparciu o interakcje użytkownika (np. przesunięcia suwaka), zmiany zależne od wprowadzonych danych (np. obliczenia oparte na wartościach wprowadzonych do pól tekstowych), i wiele innych. Reaktywność umożliwia tworzenie interfejsów, które są interaktywne i dostosowują się do działań użytkownika w czasie rzeczywistym.\n\n\nWyrażenia reaktywne (reactive()):\n\nReaktywne wyrażenia to fragmenty kodu, które automatycznie obliczają i śledzą swoje zależności.\nPrzykład: Reaktywne wyrażenie, które oblicza sumę dwóch wartości wprowadzanych przez użytkownika.\n\n\nKodsuma_reaktywna &lt;- reactive({\n  input$wartosc1 + input$wartosc2\n})\n\n\n\n\nObserwatory (observe()):\n\nObserwatory to fragmenty kodu, które są wykonywane w odpowiedzi na zmiany w danych. Służą najczęściej do działań typu side effect.\nPrzykład: Obserwator, który wypisuje na konsoli aktualną wartość suwaka.\n\n\nKodobserve({\n  cat(\"Aktualna wartość suwaka:\", input$suwak, \"\\n\")\n})\n\n\n\n\nReaktywne Funkcje (render*()):\n\nFunkcje render*()są używane w serwerze do generowania wyników, które są automatycznie aktualizowane w interfejsie w zależności od zmian w danych wejściowych.\nPrzykład: Renderowanie wykresu w zależności od wartości suwaka.\n\n\nKodoutput$wykres &lt;- renderPlot({\n  dane &lt;- seq(1, input$suwak)\n  plot(dane, main = \"Wykres dynamiczny\")\n})\n\n\n\n\nPrzykład 1\nRozważmy prosty przykład zastosowania reaktywności w Shiny, gdzie użytkownik wprowadza dwie liczby za pomocą pól tekstowych, a aplikacja reaguje na te zmiany, automatycznie obliczając i wyświetlając ich sumę. W tym przykładzie wykorzystamy reaktywne wyrażenia.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Sumator\"),\n  textInput(\"liczba1\", \"Wprowadź pierwszą liczbę:\", value = \"\"),\n  textInput(\"liczba2\", \"Wprowadź drugą liczbę:\", value = \"\"),\n  textOutput(\"wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Reaktywne wyrażenie obliczające sumę dwóch liczb\n  suma_reaktywna &lt;- reactive({\n    # Konwertujemy wprowadzone wartości na liczby\n    liczba1 &lt;- as.numeric(input$liczba1)\n    liczba2 &lt;- as.numeric(input$liczba2)\n    \n    # Sprawdzamy, czy wprowadzone wartości są liczbami\n    if (is.na(liczba1) || is.na(liczba2)) {\n      return(NULL)  # Zwracamy NULL, jeśli dane są nieprawidłowe\n    }\n    \n    # Obliczamy sumę\n    suma &lt;- liczba1 + liczba2\n    return(suma)\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$wynik &lt;- renderText({\n    suma &lt;- suma_reaktywna()\n    \n    # Sprawdzamy, czy wynik jest dostępny\n    if (!is.null(suma)) {\n      return(paste(\"Suma: \", suma))\n    } else {\n      return(\"Wprowadź poprawne liczby.\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, kiedy użytkownik wprowadza liczby do pól tekstowych, reaktywne wyrażenie suma_reaktywna automatycznie oblicza sumę tych liczb. Następnie, przy użyciu funkcji renderującej renderText, wynik jest wyświetlany w interfejsie. Dzięki temu podejściu, interfejs jest reaktywny na zmiany wprowadzane przez użytkownika, dostosowując się automatycznie do nowych danych i prezentując aktualny wynik.\n\nPrzykład 2\nRozważmy teraz przykład zastosowania wyrażenia reaktywnego w Shiny. W tej sytuacji, użytkownik będzie mógł kliknąć przycisk, co spowoduje inkrementację wartości licznika. Wykorzystamy do tego celu obiekt reaktywny.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik Kliknięć\"),\n  actionButton(\"przycisk\", \"Kliknij mnie\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Inicjalizacja obiektu reaktywnego dla licznika\n  licznik &lt;- reactiveValues(licznik_wartosc = 0)\n\n  # Obserwator reagujący na kliknięcie przycisku\n  observeEvent(input$przycisk, {\n    # Inkrementacja wartości licznika po kliknięciu przycisku\n    licznik$licznik_wartosc &lt;- licznik$licznik_wartosc + 1\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$licznik_wynik &lt;- renderText({\n    paste(\"Liczba kliknięć: \", licznik$licznik_wartosc)\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, obiekt reaktywny licznik jest używany do przechowywania wartości licznika. Za każdym razem, gdy użytkownik kliknie przycisk, obserwator reaguje na to kliknięcie, inkrementując wartość licznika w obiekcie reaktywnym. Następnie, przy użyciu funkcji renderującej renderText, aktualna wartość licznika jest wyświetlana w interfejsie. Dzięki temu, interfejs jest reaktywny na akcje użytkownika, a wartość licznika automatycznie się aktualizuje.\n\nPrzykład 3\nPrzykład zastosowania obserwatora w Shiny można przedstawić na prostym przypadku, gdzie użytkownik wpisuje tekst do pola tekstowego, a aplikacja reaguje na każdą zmianę i wyświetla liczbę znaków wprowadzonych przez użytkownika. W tym przypadku użyjemy funkcji obserwującej (observe) do reakcji na zmiany w tekście wprowadzonym przez użytkownika.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik Znaków\"),\n  textInput(\"tekst_input\", \"Wprowadź tekst:\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Obserwator reagujący na zmiany w tekście wprowadzonym przez użytkownika\n  observe({\n    # Pobranie tekstu z pola tekstowego\n    wprowadzony_tekst &lt;- input$tekst_input\n    \n    # Obliczenie liczby znaków w tekście\n    liczba_znakow &lt;- nchar(wprowadzony_tekst)\n    \n    # Aktualizacja wyniku w interfejsie\n    output$licznik_wynik &lt;- renderText({\n      paste(\"Liczba znaków: \", liczba_znakow)\n    })\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, funkcja observe śledzi zmiany w polu tekstowym (textInput) o nazwie “tekst_input”. Za każdym razem, gdy użytkownik wprowadza lub zmienia tekst, obserwator automatycznie aktualizuje wynik w interfejsie, wyświetlając liczbę znaków wprowadzonych przez użytkownika. Dzięki obserwatorowi, aplikacja jest reaktywna na zmiany w polu tekstowym bez konieczności odświeżania strony.\n\nPrzykład 4\nPrzykład wykorzystania renderPlot w Shiny może obejmować generowanie dynamicznego wykresu w zależności od interakcji użytkownika. Poniżej przedstawiam prosty scenariusz, w którym użytkownik może wybierać rodzaj wykresu (liniowy lub punktowy) oraz regulować parametry, a aplikacja reaguje, generując i wyświetlając odpowiedni wykres.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny Wykres\"),\n  selectInput(\"typ_wykresu\", \"Wybierz typ wykresu:\",\n              choices = c(\"Linia\", \"Punkty\")),\n  sliderInput(\"ilosc_punktow\", \"Liczba punktów:\", min = 10, max = 100, value = 50),\n  plotOutput(\"wykres\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Renderowanie wykresu w zależności od wyboru użytkownika\n  output$wykres &lt;- renderPlot({\n    typ_wykresu &lt;- input$typ_wykresu\n    ilosc_punktow &lt;- input$ilosc_punktow\n    \n    # Generowanie wykresu w zależności od wyboru użytkownika\n    if (typ_wykresu == \"Linia\") {\n      plot(1:ilosc_punktow, type = \"l\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    } else {\n      plot(1:ilosc_punktow, type = \"p\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, użytkownik ma możliwość wyboru rodzaju wykresu (liniowy lub punktowy) za pomocą rozwijanej listy (selectInput). Ponadto, suwak (sliderInput) pozwala regulować liczbę punktów na wykresie. Funkcja renderPlot reaguje na zmiany w tych parametrach, generując odpowiedni wykres w zależności od wyboru użytkownika. Wykres jest następnie renderowany w sekcji interfejsu o nazwie “wykres”.\n\nKolejność wykonywanych czynności w obiektach reaktywnych.\nW grafie reaktywnym w Shiny, kolejność wykonywania czynności jest określana przez zależności między reaktywnymi elementami. W ogólnym przypadku, Shiny stosuje podejście zwane “reactive programming”, gdzie reaktywne elementy składają się z obiektów reaktywnych, obserwatorów i funkcji renderujących.\nKolejność wykonywania czynności w grafie reaktywnym może być ogólnie opisana następująco:\n\n\nInicjalizacja:\n\nAplikacja Shiny zaczyna od inicjalizacji interfejsu użytkownika (UI) oraz serwera.\nObiekty reaktywne są tworzone i inicjalizowane zgodnie z ich definicjami.\n\n\n\nObserwatory:\n\nObserwatory reagują na zmiany w danych i wykonują odpowiednie akcje.\nObserwatory są wywoływane w odpowiedzi na zdarzenia, takie jak kliknięcia przycisków, zmiany wartości pól tekstowych itp.\n\n\n\nReaktywne Wyrażenia:\n\nReaktywne wyrażenia są obliczane w odpowiedzi na zmiany danych wejściowych, na których zależą.\nReaktywne wyrażenia to fragmenty kodu, które zwracają wartość i śledzą swoje zależności.\n\n\n\nFunkcje Renderujące:\n\nFunkcje renderujące są wywoływane w celu aktualizacji wyników w interfejsie użytkownika na podstawie wartości zwróconych przez reaktywne wyrażenia.\nSą one odpowiedzialne za generowanie treści do wyświetlenia, np. w obszarze tekstowym, wykresie czy tabeli.\n\n\n\nAktualizacja UI:\n\nZaktualizowane wyniki są renderowane w interfejsie użytkownika.\n\n\n\nWażne jest zrozumienie, że Shiny automatycznie dba o zarządzanie zależnościami między reaktywnymi elementami, co oznacza, że jeśli jedna wartość zmieni się, to wszystkie elementy zależne od niej zostaną automatycznie zaktualizowane. Dzięki temu podejściu, Shiny zapewnia spójność danych i dynamiczne dostosowywanie interfejsu użytkownika w zależności od akcji użytkownika lub zmian w danych.\nDla lepszego zrozumienia kolejności wykonywanych działań oraz “magii” jakiej dostarczają obiekty reaktywne, przeanalizujmy następujący przykład:\nPrzykład 5\nNiech rdzeniem naszej1 aplikacji będzie następujący kod:\n\nKodui &lt;- fluidPage(\n  numericInput(\"a\", \"a\", value = 10),\n  numericInput(\"b\", \"b\", value = 1),\n  numericInput(\"c\", \"c\", value = 1),\n  plotOutput(\"x\"),\n  tableOutput(\"y\"),\n  textOutput(\"z\")\n)\n\nserver &lt;- function(input, output, session) {\n  rng &lt;- reactive(input$a * 2)\n  smp &lt;- reactive(sample(rng(), input$b, replace = TRUE))\n  bc &lt;- reactive(input$b * input$c)\n  \n  output$x &lt;- renderPlot(hist(smp()))\n  output$y &lt;- renderTable(max(smp()))\n  output$z &lt;- renderText(bc())\n}\n\n\nW naszej aplikacji występują trzy wejścia (a, b, c) z ustawionymi wartościami domyślnymi, trzy wyrażenia reaktywne (rng, smp, bc) oraz trzema reaktywnymi wyjściami (x,y,z). W momencie inicjalizacji aplikacji stan je można opisać poniższym grafem (wszystkie wyrażenia reaktywne i wyjścia są w stanie określanym jako invalidated):\n\n\n\n\nW momencie egzekucji aplikacji Shiny uruchamiane jest jedno losowe wejście2 (oznaczmy to żółtym kolorem).\n\n\n\n\nPonieważ wywołanie to potrzebuje wartości wyrażeń reaktywnych, to tworzy się połączenie z wyrażeniami reaktywnymi, od których zależy wyjście i inicjalizowane są wyrażenia reaktywne. Powiedzmy, że pierwszym wykonującym się wyjściem było output$x. Wtedy wymagane jest wywołanie obiektu reaktywnego smp().\n\n\n\n\nWartość smp() zależy za to od input$b, którego wartość jest określona, ponieważ jest to wartość wejściowa z domyślną wartością 1.\n\n\n\n\nWartość smp() zależy również od innego wyrażenia reaktywnego rng(), które jest znów powiązane z wejściem input$a. Analogicznie do powyższej sytuacji odpowiednie połączenia i egzekucje zostaną wywołane.\n\n\n\n\nW ten sposób wszystko co jest potrzebne do egzekucji wyjścia output$x zostało policzone i można przejść do wywołania wyjścia.\n\n\n\n\nPrzechodzimy zatem do egzekucji kolejnego wyjścia output$y.\n\n\n\n\nPonieważ output$y zależy tylko do smp() a to zostało już policzone i jego stan został “skeszowany”, to nie trzeba po raz kolejny wywoływać tych obliczeń3. W podobny sposób wywoływane są wszystkie wyjścia. Po egzekucji wszystkich wyjść graf przedstawia się następująco4:\n\n\n\n\nJeśli nastąpi zmiana wartości wejściowej, wówczas wejście to jest najpierw oznaczane jako invalidated, a następnie stan invalidated jest nadawany wszystkim obiektom zależnym od tego wejścia, co powoduje, że graf wygląda następująco:\n\n\n\n\nPonadto usuwane są połączenia do obiektów w stanie invalidated i jednocześnie przypisywana jest nowa wartość input$a.\n\n\n\n\nW dalszej kolejności znów jedno z wyjść unieważnionych (ang. invalidated) jest poddane egzekucji, która pociąga za sobą egzekucje tych wejść i wyrażeń reaktywnych, które są wymagane do obliczenia wartości lub wyświetlenia wyjścia.\n\n\n\n\nDalej proces przebiega podobnie. Warto zauważyć, że pewne wejścia i wyrażenia reaktywne nie musiały się wywoływać ponownie.\nPrzeanalizujmy jeszcze jeden krótki przykład aby lepiej zrozumieć reaktywność w Shiny.\nPrzykład 6\nAplikacja jest zbudowana następująco:\n\nKodui &lt;- fluidPage(\n  selectInput(\"choice\", \"A or B?\", c(\"a\", \"b\")),\n  numericInput(\"a\", \"a\", 0),\n  numericInput(\"b\", \"b\", 10),\n  textOutput(\"out\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    if (input$choice == \"a\") {\n      input$a\n    } else {\n      input$b\n    }\n  }) \n}\n\n\nMogłoby się wydawać, że graf dla niej wygląda następująco:\n\n\n\n\nAle ponieważ Shiny dynamicznie rekonstruuje wykres po unieważnieniu danych wyjściowych, w rzeczywistości wygląda on jak jeden z poniższych wykresów, w zależności od wartości input$choice. Zapewnia to, że Shiny wykonuje minimalną ilość pracy, gdy dane wejściowe są unieważniane. W tym przypadku, jeśli input$choice jest ustawiony na b, to wartość input$a nie wpływa na output$out i nie ma potrzeby jej ponownego obliczania.\n\n\n\n\nGdybyśmy nieznacznie zmienili funkcję serwera, to wartość wyjścia stale by zależała od dwóch wejść.\n\nKodoutput$out &lt;- renderText({\n  a &lt;- input$a\n  b &lt;- input$b\n\n  if (input$choice == \"a\") {\n    a\n  } else {\n    b\n  }\n}) \n\n\n\n\n\n\n\n\nWskazówka\n\n\n\nChcąc poznać reguły panujące w złożonych aplikacjach i zależności pomiędzy obiektami, można użyć pakietu reactlog. Uruchamiając przed wywołaniem aplikacji funkcję reactlog::reactlog_enable() powodujemy odpalenie serwera rejestrującego połączenia. Można przeglądać na żywo zmiany stanów poszczególnych obiektów przez wywołanie Ctrl+F3 (Windows) lub Cmd+F3 (MacOS i Linux). Po zakończeniu działania aplikacji możemy też przejrzeć log stanów używając shiny::reactlogShow()."
  },
  {
    "objectID": "wyk3.html#footnotes",
    "href": "wyk3.html#footnotes",
    "title": "Wykład 3",
    "section": "Przypisy",
    "text": "Przypisy\n\nbezużytecznej↩︎\nnajczęściej wyjścia są niezależne, ale w przypadku zagnieżdżeń kolejność wykonywania aplikacji uwzględnia tą zależność↩︎\nto część magii reaktywności↩︎\nstan ten się nie zmienia aż do zmiany jakiejś wielkości wejściowej↩︎"
  },
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "Wykład 2",
    "section": "",
    "text": "Przypominając sytuację w jakiej się znajdujemy… utworzyliśmy repozytorium o nazwie DariuszMajerek/Github_tests. Dokonaliśmy w nim kilku zmian commitowanych za każdym razem. Podgląd tych zmian możemy dokonać przez przegląd commitów.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "Wykład 2",
    "section": "",
    "text": "Zmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "Wykład 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request."
  },
  {
    "objectID": "wyk2.html#działanie-na-gałęziach",
    "href": "wyk2.html#działanie-na-gałęziach",
    "title": "Wykład 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "Wykład 2",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nEwentualne zmiany nie popsują niczego w tym repo, bo jest ono przygotowane do tego typu testów.↩︎\nDotąd mamy wszystko zrobione↩︎"
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "Wykład 1",
    "section": "",
    "text": "Ponieważ proces budowy i udoskonalania modelu może trwać długo i być prowadzony przez kilka osób, to kontrolowanie wersji modelu wydaje się być konieczne.\nPonadto konieczne w tym procesie jest kontrolowanie zarówno aktualnej wersji modelu, jak i wszystkich przyległości z nim związanych. Idealnym narzędziem do zautomatyzowania czynności polegających na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program działający w terminalu ale istnieją również jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednocześnie połączony z hubem (czyli kontenerem) pozwalającym na przechowywanie i udostępnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usługa serwerowa, która pozwala na zapisywanie i udostępnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\nW niniejszym wykładzie zostaną przedstawione rozwiązania z wykorzystaniem Gita i GitHuba.\nPrzykładowe repozytorium projektu tidymodels na stronie GitHub wygląda następująco.\nGit w połączeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, który tworzymy, a jednocześnie na udostępnianie go oraz umożliwienie współpracy nad kodem przez wielu użytkowników - współtwórców (ang. contributors) ale nie tylko. Udostępnianie może być zarówno publiczne, jak i prywatne.\nFunkcjonalności GitHub, to:\nŁącząc Git z Githubem, programiści zyskują mocne narzędzie do kontroli wersji, współpracy, śledzenia problemów i automatyzacji procesów, co przyczynia się do skutecznego zarządzania projektami oprogramowania1."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "Wykład 1",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nNie wszystkie z powyższych tematów uda nam się omówić na wykładzie ale większość zostanie zademonstrowana.↩︎\nskrót od repozytorium↩︎\nwprawdzie na tym etapie dodaliśmy plik README.md ale ponieważ jest to pierwszy commit to tak go nazwaliśmy.↩︎"
  },
  {
    "objectID": "wyk5.html",
    "href": "wyk5.html",
    "title": "Wykład 5",
    "section": "",
    "text": "Tworzenie interaktywnych wykresów w Shiny jest kluczowym elementem budowy aplikacji, które dynamicznie prezentują dane i umożliwiają użytkownikom interakcję z wygenerowanymi wizualizacjami. Interaktywne wykresy w Shiny pozwalają na tworzenie bardziej angażujących i intuicyjnych interfejsów dla analizy danych, oferując użytkownikom możliwość eksploracji danych w czasie rzeczywistym. Poniżej przedstawiono szczegóły techniczne dotyczące podstaw tworzenia interaktywnych wykresów w Shiny, wraz z przykładami zastosowań.\nPodstawą do tworzenia interaktywnych wykresów w Shiny jest połączenie reaktywności aplikacji z możliwościami bibliotek do tworzenia wykresów. Do najpopularniejszych bibliotek wykorzystywanych w Shiny należą ggplot2 dla statycznych wykresów oraz plotly i highcharter dla interaktywnych wizualizacji. Wykorzystując te narzędzia, można tworzyć wykresy, które aktualizują się automatycznie w odpowiedzi na działania użytkownika, takie jak zmiana parametrów zapytania czy wybór konkretnych danych do analizy.\nInteraktywność wykresów osiąga się poprzez zastosowanie reaktywnych wyrażeń w kodzie serwera Shiny. Reaktywne wyrażenia monitorują zmiany w danych wejściowych (np. suwaki, pola wyboru) i automatycznie aktualizują wykresy, zapewniając dynamiczną prezentację danych. Przykładowo, użycie renderPlot z ggplot2 pozwala na generowanie wykresów, które reagują na zmiany danych wejściowych, podczas gdy plotly::renderPlotly służy do tworzenia interaktywnych wizualizacji z dodatkowymi funkcjami jak tooltipy czy możliwość zoomowania.\n\nKodlibrary(quantmod)\nlibrary(highcharter)\n\nx &lt;- getSymbols(\"GOOG\", auto.assign = FALSE)\ny &lt;- getSymbols(\"AMZN\", auto.assign = FALSE)\n\nhighchart(type = \"stock\") |&gt; \n  hc_add_series(x) |&gt; \n  hc_add_series(y, type = \"ohlc\")\n\n\n\n\n\n\nRysunek 1: Przykład wykresu interaktywnego stosując pakiet highcharter\n\n\n\nInteraktywność w Shiny jest kluczową cechą, która odróżnia te aplikacje od statycznych raportów i wizualizacji danych. Umożliwia ona użytkownikom bezpośrednią interakcję z danymi na wykresie, otwierając szeroki zakres możliwości aplikacji - od prostych analiz po zaawansowane eksploracje danych.\n\nKoddf &lt;- data.frame(\n  stringsAsFactors = FALSE,\n  name = c(\n    \"The Left\",\n    \"Social Democratic Party\",\n    \"Alliance 90/The Greens\",\n    \"Free Democratic Party\",\n    \"Christian Democratic Union\",\n    \"Christian Social Union in Bavaria\",\n    \"Alternative for Germany\"\n  ),\n  count = c(69, 153, 67, 80, 200, 46, 94),\n  col = c(\"#BE3075\", \"#EB001F\", \"#64A12D\", \"#FFED00\",\n          \"#000000\", \"#008AC5\", \"#009EE0\"\n  ),\n  abbrv = c(\"DIE LINKE\", \"SPD\", \"GRÜNE\", \"FDP\", \"CDU\", \"CSU\", \"AfD\")\n)\n\nhchart(\n  df,\n  \"item\",\n  hcaes(\n    name = name,\n    y = count,\n    label = abbrv,\n    color = col\n  ),\n  name = \"Representatives\",\n  showInLegend = TRUE,\n  size = \"100%\",\n  center = list(\"50%\", \"75%\"),\n  startAngle = -100,\n  endAngle  = 100\n) %&gt;%\n  hc_title(text = \"Item chart with different layout\") %&gt;%\n  hc_legend(labelFormat = '{name} &lt;span style=\"opacity: 0.4\"&gt;{y}&lt;/span&gt;')\n\n\n\n\n\n\nRysunek 2: Inny przykład interaktywności wykresu w highcharter\n\n\n\n\nKodlibrary(dplyr)\nlibrary(forcats)\nlibrary(purrr)\nlibrary(stringr)\npkmn_min &lt;- pokemon |&gt;\n  count(type_1, color = type_1_color) |&gt;\n  mutate(type_1 = fct_reorder(type_1, .x = n)) |&gt;\n  arrange(desc(type_1))\n\npkmn_ddn &lt;- pokemon |&gt;\n  count(type_1, type_2, color = type_mix_color) |&gt;\n  arrange(type_1, desc(n)) |&gt;\n  mutate(type_2 = ifelse(is.na(type_2), str_c(\"only \", type_1), type_2)) |&gt;\n  group_nest(type_1) |&gt;\n  mutate(\n    id = type_1,\n    type = \"column\",\n    # in the drilldown we'll give the mapping via creating the columns\n    data = map(data, mutate, name = type_2, y  = n),\n    data = map(data, list_parse)\n  )\n\nhchart(\n  pkmn_min,\n  type = \"column\",\n  hcaes(x = type_1, y = n, color = color, drilldown = type_1),\n  name = \"Pokémons\"\n  ) |&gt;\n  hc_drilldown(\n    activeAxisLabelStyle = list(textDecoration = \"none\"),\n    allowPointDrilldown = TRUE,\n    series = list_parse(pkmn_ddn)\n  ) |&gt;\n  hc_yAxis(\n    title = list(text = \"\"),\n    endOnTick = FALSE,\n    opposite = TRUE\n    ) |&gt;\n  hc_xAxis(\n    title = list(text = \"\"),\n    endOnTick = FALSE,\n    gridLineWidth = 0,\n    tickWidth = 0\n    ) |&gt;\n  hc_chart(\n    style = list(fontFamily = \"Gloria Hallelujah\")\n  )\n\n\n\n\n\n\nRysunek 3: Ciekawy przykład interaktywności wykresu w highcharter\n\n\n\n\nW Shiny, interaktywność z wykresami jest możliwa dzięki wykorzystaniu plotOutput(), który nie tylko wyświetla wykresy, ale również może reagować na zdarzenia generowane przez wskaźnik myszy, takie jak kliknięcie, podwójne kliknięcie, najechanie kursorem (ang. hover) czy zaznaczenie obszaru (ang. brush). Aby przekształcić te zdarzenia w dane wejściowe dla Shiny, wystarczy przekazać odpowiedni ciąg znaków do argumentu plotOutput(), np. plotOutput(\"plot\", click = \"plot_click\"). Tworzy to obiekt input$plot_click, który można wykorzystać do obsługi kliknięć na wykresie.\n\n\nKlikanie - głównym zdarzeniem jest kliknięcie myszą, które zwraca bogatą listę informacji, w tym lokalizację zdarzenia w koordynatach danych. Shiny oferuje pomocnika nearPoints(), który ułatwia identyfikację danych bliskich miejscu kliknięcia, zajmując się szczegółami technicznymi.\nPodwójne kliknięcie i najechanie kursorem - podobne do kliknięcia, te zdarzenia można wykorzystać do różnych interakcji, np. wyświetlenia dodatkowych informacji o punkcie danych lub wyróżnienia go na wykresie.\nZaznaczenie obszaru (brushing) - pozwala na wybór wielu punktów danych za pomocą prostokątnego narzędzia zaznaczającego. Użytkowanie brushedPoints() umożliwia obsługę danych zaznaczonych przez użytkownika.\n\n\nZarejestrowanie zdarzenia kliknięcia i aktualizacja innego elementu wyjściowego za pomocą koordynatów miejsca kliknięcia pokazuje, jak można dynamicznie reagować na interakcje użytkownika z danymi.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja interfejsu użytkownika\nui &lt;- fluidPage(\n  titlePanel(\"Interaktywny wykres w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Kliknij na wykresie, aby uzyskać koordynaty punktu.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", click = \"plot_click\"), # Wykres reagujący na kliknięcia\n      verbatimTextOutput(\"info\") # Wyświetlanie informacji o kliknięciu\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$info &lt;- renderPrint({\n    req(input$plot_click) # Zapewnienie, że kliknięcie miało miejsce\n    info &lt;- input$plot_click\n    paste(\"Kliknięto w punkt: x =\", round(info$x, 2), \"y =\", round(info$y, 2))\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\nWażne\n\n\n\nUżycie req() jest po to, aby upewnić się, że aplikacja nie zrobi nic przed pierwszym kliknięciem, oraz że współrzędne są w zakresach bazowych zmiennych wt i mpg.\n\n\nWywołanie tej aplikacji i kliknięcie daje następujący rezultat:\n\n\n\n\n\nRysunek 4\n\n\nCiekawą modyfikacją powyższego przykładu mogłoby być użycie funkcji nearPoints w funkcji serwera. Wówczas klikając blisko pewnych punktów1 otrzymamy tabelę punktów leżących blisko punktu kliknięcia.\n\nKod# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$data &lt;- renderTable({\n    # Zapewnienie, że kliknięcie miało miejsce\n    req(input$plot_click)\n    \n    # Użycie nearPoints do znalezienia punktów blisko kliknięcia\n    near_points &lt;- nearPoints(mtcars, input$plot_click, threshold = 50, maxpoints = 1, xvar = \"wt\", yvar = \"mpg\")\n    \n    # Zwrócenie znalezionych punktów\n    if (nrow(near_points) &gt; 0) {\n      near_points\n    } else {\n      data.frame() # Pusta ramka danych, jeśli nie znaleziono żadnych punktów\n    }\n  })\n}\n\n\nInnym sposobem wykorzystania interaktywności jest funkcja hover, która pozwala na wyświetlanie danych po najechaniu kursorem nad punkt na wykresie.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja UI\nui &lt;- fluidPage(\n  titlePanel(\"Interaktywność z hover w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Najedź myszą na punkty na wykresie, aby zobaczyć szczegóły.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", hover = hoverOpts(id=\"plot_hover\", delay = 100, delayType = \"debounce\")), # Wykres z obsługą hover\n      verbatimTextOutput(\"info\") # Miejsce na informacje o punkcie\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$info &lt;- renderPrint({\n    hover &lt;- input$plot_hover\n    if (!is.null(hover)) {\n      near_points &lt;- nearPoints(mtcars, hover, threshold = 5, maxpoints = 1, addDist = TRUE)\n      if (nrow(near_points) &gt; 0) {\n        cat(\"Waga: \", near_points$wt, \"\\nMile na galon: \", near_points$mpg)\n      } else {\n        \"Nie wykryto punktu.\"\n      }\n    }\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nWynik działania tej aplikacji jest następujący:\n\nPoniżej znajdziesz przykład aplikacji Shiny, która wykorzystuje funkcję brush (czyli zaznaczanie obszaru) do wyboru punktów na wykresie. Użytkownicy mogą zaznaczać obszar na wykresie, a aplikacja wyświetli dane dotyczące punktów znajdujących się w zaznaczonym obszarze.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja UI\nui &lt;- fluidPage(\n  titlePanel(\"Wykorzystanie Brush w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Zaznacz obszar na wykresie, aby zobaczyć szczegóły punktów.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", brush = \"plot_brush\"), # Wykres z obsługą brush\n      tableOutput(\"selected_data\") # Tabela wyświetlająca zaznaczone dane\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$selected_data &lt;- renderTable({\n    brush &lt;- input$plot_brush\n    if (!is.null(brush)) {\n      # Użycie brushedPoints do znalezienia punktów w zaznaczonym obszarze\n      brushed_points &lt;- brushedPoints(mtcars, brush)\n      if (nrow(brushed_points) &gt; 0) {\n        brushed_points\n      } else {\n        data.frame() # Pusta ramka danych, jeśli nie znaleziono żadnych punktów\n      }\n    }\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nW tej aplikacji:\n\n\nplotOutput(\"plot\", brush = \"plot_brush\") tworzy obszar wykresu, który pozwala użytkownikom na zaznaczanie obszaru przy użyciu myszy. Zaznaczenie jest przekazywane do Shiny jako obiekt brush, który zawiera informacje o zaznaczonym obszarze.\n\nrenderPlot({ ... }) generuje wykres punktowy dla danych mtcars za pomocą ggplot2.\n\nrenderTable({ ... }) wykorzystuje brushedPoints do identyfikacji i wyświetlenia punktów danych, które znajdują się w obrębie zaznaczonego obszaru. Funkcja ta automatycznie filtruje dane z mtcars do tych, które mieszczą się w zaznaczonym obszarze, i wyświetla je w formie tabeli.\n\nTa aplikacja Shiny pokazuje, jak można efektywnie użyć funkcji brush do interaktywnej eksploracji danych na wykresie, dając użytkownikom możliwość zaznaczania i analizowania konkretnych obszarów danych.\n\n\n\n\n\nRysunek 5\n\n\n\nPrawdziwa moc interaktywności ujawnia się, gdy zmiany wynikające z interakcji użytkownika są odzwierciedlane bezpośrednio na tym samym wykresie, z którym wchodzą w interakcję. Jest to możliwe dzięki zaawansowanym technikom reaktywności w Shiny, takim jak reactiveVal(), które umożliwiają tworzenie dynamicznych i interaktywnych wizualizacji, które reagują na działania użytkownika w czasie rzeczywistym.\nModyfikowanie wykresu w czasie rzeczywistym w odpowiedzi na interakcje użytkownika jest zaawansowaną techniką w aplikacjach Shiny, która znacząco zwiększa interaktywność i użyteczność aplikacji. Pozwala to na dynamiczną zmianę wyglądu wykresu, np. w zależności od danych wybranych przez użytkownika lub w odpowiedzi na inne działania, takie jak kliknięcie czy zaznaczenie obszaru. Poniżej przedstawiono przykład aplikacji Shiny, która ilustruje, jak można modyfikować wykres w odpowiedzi na interakcję z użytkownikiem za pomocą techniki brush.\n\nW tym przykładzie użytkownik może zaznaczyć obszar na wykresie punktowym, a aplikacja zaznaczy punkty w obrębie tego obszaru, zmieniając ich kolor. Dodatkowo, po zaznaczeniu obszaru, wyświetlona zostanie tylko część danych odpowiadająca zaznaczonym punktom, co pozwala na szczegółową analizę fragmentu zbioru danych.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja UI\nui &lt;- fluidPage(\n  titlePanel(\"Modyfikowanie wykresu poprzez brushing\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Zaznacz obszar na wykresie, aby zmienić kolor punktów.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", brush = \"plot_brush\") # Wykres z obsługą brush\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output, session) {\n  # Zmienna reaktywna przechowująca zaznaczone punkty\n  selected_points &lt;- reactiveVal(data.frame(wt = numeric(), mpg = numeric()))\n  \n  observe({\n    brush &lt;- input$plot_brush\n    if (!is.null(brush)) {\n      # Użycie brushedPoints do znalezienia punktów w zaznaczonym obszarze\n      brushed_points &lt;- brushedPoints(mtcars, brush)\n      selected_points(brushed_points) # Aktualizacja zaznaczonych punktów\n    }\n  })\n  \n  output$plot &lt;- renderPlot({\n    # Tworzenie wykresu z zaznaczonymi punktami w innym kolorze\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point(aes(color = ifelse(row.names(mtcars) %in% row.names(selected_points()), \"Zaznaczone\", \"Nie zaznaczone\")),\n                 show.legend = FALSE) +\n      scale_color_manual(values = c(\"Zaznaczone\" = \"red\", \"Nie zaznaczone\" = \"black\")) +\n      theme_minimal()\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nW tej aplikacji:\n\nZmienna reaktywna selected_points przechowuje dane o punktach zaznaczonych przez użytkownika.\nObserwator (observe({ ... })) aktualizuje selected_points za każdym razem, gdy użytkownik zaznacza nowy obszar na wykresie.\nrenderPlot({ ... }) tworzy wykres, na którym punkty są kolorowane różnie w zależności od tego, czy znajdują się w zaznaczonym obszarze. Funkcja ifelse wewnątrz aes zmienia kolor punktów na czerwony, jeśli są zaznaczone, pozostawiając pozostałe punkty czarne.\n\nWynik działania jest następujący:\n\n\n\n\n\nRysunek 6\n\n\n\nDynamiczna zmiana wysokości i szerokości wykresów w aplikacjach Shiny to zaawansowana funkcjonalność, która pozwala aplikacjom lepiej dostosować się do różnych urządzeń i rozmiarów ekranu użytkowników, jak również reagować na zmiany w interfejsie użytkownika, takie jak zmiany w układzie paneli czy rozwijane menu, które mogą zmieniać dostępną przestrzeń dla wykresów.\nAby umożliwić dynamiczną zmianę rozmiaru wykresów, Shiny oferuje możliwość przekazania funkcji bezargumentowych do argumentów width i height w renderPlot(). Te funkcje powinny zwracać wartości liczbowe, reprezentujące szerokość i wysokość wykresu w pikselach. Kluczowym aspektem jest to, że funkcje te są wykonywane w środowisku reaktywnym, co oznacza, że mogą dostosowywać rozmiar wykresu w odpowiedzi na zmiany w aplikacji.\nPoniżej znajduje się przykładowy kod, ilustrujący sposób dynamicznego dostosowywania rozmiarów wykresu w aplikacji Shiny:\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  sliderInput(\"height\", \"Wysokość wykresu\", min = 200, max = 600, value = 400),\n  sliderInput(\"width\", \"Szerokość wykresu\", min = 200, max = 600, value = 400),\n  plotOutput(\"dynamicPlot\", width = \"auto\", height = \"auto\")\n)\n\nserver &lt;- function(input, output) {\n  output$dynamicPlot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = mpg, y = disp)) + geom_point()\n  }, width = function() { input$width }, height = function() { input$height })\n}\n\nshinyApp(ui = ui, server = server)\n\n\nW tym przykładzie, suwaki umożliwiają użytkownikowi dynamiczne zmienianie wysokości i szerokości wykresu. Funkcje przekazane do width i height w renderPlot() wykorzystują wartości z inputów input$width i input$height do określenia rozmiarów wykresu, umożliwiając w ten sposób dynamiczną reakcję na akcje użytkownika.\n\n\n\n\n\nRysunek 7\n\n\n\nDynamiczna zmiana rozmiarów wykresów ma szerokie zastosowanie, szczególnie w przypadku:\n\nAdaptacyjnych interfejsów użytkownika - gdzie wykresy muszą dostosowywać się do różnych rozmiarów ekranu, w tym urządzeń mobilnych.\nInteraktywnych dashboardów - pozwalając użytkownikom na personalizację układu i rozmiarów wyświetlanych elementów.\nAplikacji analitycznych - gdzie złożoność danych wymaga elastyczności w prezentacji wyników, aby umożliwić dokładniejszą analizę.\n\nDynamiczne dostosowywanie rozmiaru wykresów znacząco podnosi użyteczność aplikacji Shiny, poprawiając interakcję użytkownika i dostosowanie do różnorodnych scenariuszy użytkowania.\n\nWyświetlanie obrazów w aplikacjach Shiny jest kolejną istotną funkcjonalnością, która rozszerza możliwości interaktywnych aplikacji o prezentację zasobów graficznych. Może to obejmować wyświetlanie zdjęć, diagramów, schematów, czy też dynamicznie generowanych wizualizacji. Funkcja renderImage() w Shiny pozwala na łatwe włączenie obrazów do aplikacji, umożliwiając interaktywne ich eksplorowanie oraz dynamiczną zmianę w zależności od akcji użytkownika.\nFunkcja renderImage() jest używana na serwerze aplikacji Shiny do określenia, jak obrazy mają być renderowane i wysyłane do interfejsu użytkownika. Aby wyświetlić obraz, renderImage() musi zwrócić listę zawierającą co najmniej ścieżkę do obrazu (src), a opcjonalnie inne parametry takie jak typ MIME (contentType), szerokość (width), wysokość (height) oraz dodatkowe atrybuty HTML, które zostaną dodane do znacznika &lt;img&gt;.\n\nPoniżej znajduje się przykład aplikacji Shiny, która wykorzystuje renderImage() do wyświetlania obrazów w zależności od wyboru użytkownika:\n\nKodlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Wyświetlanie obrazów w Shiny\"),\n  selectInput(\"imageChoice\", \"Wybierz obraz:\", choices = c(\"Screen 1\", \"Screen 2\")),\n  imageOutput(\"selectedImage\")\n)\n\nserver &lt;- function(input, output) {\n  output$selectedImage &lt;- renderImage({\n    # Ścieżki do obrazów\n    imagePath &lt;- switch(input$imageChoice,\n                        \"Screen 1\" = \"~/Desktop/Pollub/wyklady/ModelDeployment/images/Zrzut ekranu 2024-01-20 o 16.41.52.png\",\n                        \"Screen 2\" = \"~/Desktop/Pollub/wyklady/ModelDeployment/images/Zrzut ekranu 2024-01-20 o 16.43.24.png\")\n    \n    # Zwracanie listy z informacjami o obrazie\n    list(src = imagePath,\n         contentType = \"image/jpeg\",\n         width = 400, # Można dostosować\n         height = \"auto\")\n  }, deleteFile = FALSE) # Ustawienie na FALSE, jeśli obrazy nie są tymczasowe\n}\n\nshinyApp(ui = ui, server = server)\n\n\nW tym przykładzie użytkownik może wybrać między dwoma obrazami za pomocą menu rozwijanego. Wybrany obraz jest następnie wyświetlany na stronie dzięki renderImage(), która dynamicznie zwraca właściwy obraz na podstawie wyboru użytkownika.\nWyświetlanie obrazów ma szerokie zastosowanie w aplikacjach Shiny, od prostego pokazywania zdjęć po zaawansowane zastosowania takie jak:\n\nGalerie zdjęć - umożliwiają użytkownikom przeglądanie kolekcji obrazów.\nInstrukcje i schematy - pomagają wizualizować kroki procesów lub detale konstrukcyjne.\nWizualizacje danych - prezentują skomplikowane analizy danych lub wyniki symulacji w formie graficznej.\n\nKluczowym aspektem jest to, że renderImage() zapewnia elastyczność i kontrolę nad sposobem prezentacji obrazów, co pozwala na tworzenie bardziej interaktywnych i angażujących aplikacji Shiny.\n\nOgraniczenia interaktywności w aplikacjach Shiny wynikają głównie z podstawowego przepływu danych i architektury aplikacji. Rozumienie tych ograniczeń jest kluczowe do efektywnego projektowania i optymalizacji interaktywnych aplikacji Shiny. Oto głębsze spojrzenie na ograniczenia interaktywności, szczególnie w kontekście wykresów interaktywnych:\n\nOpóźnienia w interakcji\n\n\nPrzetwarzanie po stronie serwera - wszystkie interakcje użytkownika z wykresami interaktywnymi w Shiny są przetwarzane po stronie serwera. Oznacza to, że zdarzenia, takie jak kliknięcia myszką czy zaznaczanie obszaru, muszą być najpierw przesłane do serwera, przetworzone przez R, a następnie wyniki muszą być wysłane z powrotem do klienta. Ten przepływ może prowadzić do opóźnień, zwłaszcza w aplikacjach hostowanych zdalnie.\nPrzesyłanie danych - dla aplikacji hostowanych, czas potrzebny na przesyłanie zdarzeń od klienta do serwera i z powrotem może wpływać na responsywność aplikacji. Opóźnienia te mogą być szczególnie zauważalne w przypadku wolnych połączeń internetowych.\n\n\nOgraniczenia wydajności\n\n\nZłożoność wykresów - bardziej złożone wykresy z większą ilością punktów danych lub z bardziej skomplikowanymi obliczeniami do ich generowania mogą znacząco obciążać serwer, prowadząc do dłuższego czasu odpowiedzi. Przy każdej interakcji użytkownika wykres musi być ponownie generowany, co może być kosztowne obliczeniowo.\nRównoczesne użytkowanie - aplikacje Shiny mogą doświadczać spadków wydajności podczas obsługi wielu użytkowników jednocześnie, zwłaszcza gdy każdy użytkownik generuje intensywny ruch danych z interaktywnymi wykresami.\n\n\nOgraniczenia skalowalności - skalowanie aplikacji Shiny do obsługi dużej liczby użytkowników równocześnie, każdego z potencjalnie interaktywnymi wykresami, wymaga znacznych zasobów serwerowych. Może to być wyzwaniem w kontekście zarządzania zasobami i optymalizacji wydajności.\nAlternatywne rozwiązania\n\n\nObliczenia po stronie klienta - w niektórych przypadkach, przeniesienie części obliczeń do przeglądarki klienta za pomocą JavaScript może pomóc zmniejszyć obciążenie serwera i poprawić responsywność aplikacji. Narzędzia takie jak biblioteka plotly czy leaflet dla map oferują bardziej zaawansowane możliwości interaktywne, które działają po stronie klienta.\nAsynchroniczne przetwarzanie - wykorzystanie asynchronicznych wzorców przetwarzania w Shiny (np. przy użyciu future i promises) może poprawić reaktywność aplikacji poprzez umożliwienie serwerowi obsługi innych zadań podczas oczekiwania na zakończenie długotrwałych operacji.\n\nRozumienie i akceptacja tych ograniczeń są kluczowe przy projektowaniu interaktywnych aplikacji Shiny, zwłaszcza tych, które są intensywnie wykorzystywane przez użytkowników lub zawierają skomplikowane wizualizacje danych. Planowanie architektury aplikacji z myślą o tych ograniczeniach może pomóc w tworzeniu bardziej wydajnych i responsywnych rozwiązań."
  },
  {
    "objectID": "wyk5.html#footnotes",
    "href": "wyk5.html#footnotes",
    "title": "Wykład 5",
    "section": "Przypisy",
    "text": "Przypisy\n\npromień tego obszaru można modyfikować↩︎"
  }
]