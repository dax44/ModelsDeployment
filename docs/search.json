[
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "PrzypominajÄ…c sytuacjÄ™ w jakiej siÄ™ znajdujemyâ€¦ utworzyliÅ›my repozytorium o nazwie DariuszMajerek/Github_tests. DokonaliÅ›my w nim kilku zmian commitowanych za kaÅ¼dym razem. PodglÄ…d tych zmian moÅ¼emy dokonaÄ‡ przez przeglÄ…d commitÃ³w.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nWarning\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nCaution\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nImportant\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "Zmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nWarning\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nCaution\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nImportant\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request."
  },
  {
    "objectID": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "href": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "WykÅ‚ad 2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEwentualne zmiany nie popsujÄ… niczego w tym repo, bo jest ono przygotowane do tego typu testÃ³w.â†©ï¸\nDotÄ…d mamy wszystko zrobioneâ†©ï¸"
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "WykÅ‚ad 1",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych.\n\n\n\n\n\n\n\nKonieczne w tym procesie jest kontrolowanie aktualnej wersji modelu i wszystkich przylegÅ‚oÅ›ci z nim zwiÄ…zanych. Idealnym narzÄ™dziem do zautomatyzowania czynnoÅ›ci polegajÄ…cych na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program dziaÅ‚ajÄ…cy w terminalu ale istniejÄ… rÃ³wnieÅ¼ jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednoczeÅ›nie poÅ‚Ä…czony z hubem (czyli kontenerem) pozwalajÄ…cym na przechowywanie i udostÄ™pnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usÅ‚uga serwerowa, ktÃ³ra pozwala na zapisywanie i udostÄ™pnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\n\n\n\n\n\n\n\nW niniejszym wykÅ‚adzie zostanÄ… przedstawione rozwiÄ…zania z wykorzystaniem Gita i GitHuba.\nPrzykÅ‚adowe repozytorium projektu tidymodels na stronie GitHub wyglÄ…da nastÄ™pujÄ…co.\n\n\n\nStrona projektu tidymodels na GitHubie\n\n\nGit w poÅ‚Ä…czeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, ktÃ³ry tworzymy, a jednoczeÅ›nie na udostÄ™pnianie go oraz umoÅ¼liwienie wspÃ³Å‚pracy nad kodem przez wielu uÅ¼ytkownikÃ³w - wspÃ³Å‚twÃ³rcÃ³w (ang. contributors) ale nie tylko. UdostÄ™pnianie moÅ¼e byÄ‡ zarÃ³wno publiczne, jak i prywatne.\nFunkcjonalnoÅ›ci GitHub, to:\n\nKontrola wersji kodu.\nKopiowanie kodu na dwa sposoby:\n\nClone:\n\nKlonowanie repozytorium oznacza skopiowanie zdalnego repozytorium na lokalny komputer.\nGdy klonujesz repozytorium, uzyskujesz identycznÄ… kopiÄ™ zawartoÅ›ci, historii i gaÅ‚Ä™zi tego repozytorium na swoim lokalnym systemie.\nMoÅ¼esz pracowaÄ‡ nad projektem lokalnie i wysyÅ‚aÄ‡ swoje zmiany z powrotem do zdalnego repozytorium.\n\nPrzykÅ‚ad klonowania repozytorium:\n\ngit clone https://github.com/nazwa_uzytkownika/nazwa_repozytorium.git\n\nFork:\n\nForking (rozszerzanie) repozytorium oznacza utworzenie kopii zdalnego repozytorium w obrÄ™bie twojego konta na GitHubie.\nKiedy forkujesz repozytorium, masz wÅ‚asnÄ… kopiÄ™, ktÃ³rÄ… moÅ¼esz dowolnie modyfikowaÄ‡, nie wpÅ‚ywajÄ…c na oryginalne repozytorium.\nForkowanie jest czÄ™sto uÅ¼ywane w projekcie open source, gdzie chcesz dodaÄ‡ swoje zmiany, ale nie masz bezpoÅ›redniego dostÄ™pu do repozytorium.\n\nPrzykÅ‚ad forka repozytorium:\n\nNa stronie repozytorium w witrynie GitHub klikasz przycisk â€œForkâ€ w prawym gÃ³rnym rogu. To utworzy kopiÄ™ tego repozytorium w twoim wÅ‚asnym koncie.\n\nForking pozwala ci pracowaÄ‡ niezaleÅ¼nie nad projektem, a nastÄ™pnie moÅ¼esz zgÅ‚osiÄ‡ pull request (proÅ›bÄ™ o zaakceptowanie zmian) do oryginalnego repozytorium, aby wÅ‚aÅ›ciciel mÃ³gÅ‚ uwzglÄ™dniÄ‡ twoje zmiany.\n\nZarzÄ…dzanie Branchami:\n\nGitHub oferuje narzÄ™dzia do Å‚atwego zarzÄ…dzania gaÅ‚Ä™ziami (branches). MoÅ¼esz tworzyÄ‡, usuwaÄ‡ i Å‚Ä…czyÄ‡ gaÅ‚Ä™zie za pomocÄ… interfejsu graficznego.\n\nKomentarze i Dyskusje:\n\nMoÅ¼liwoÅ›Ä‡ dodawania komentarzy do kodu ÅºrÃ³dÅ‚owego, pull requestÃ³w i problemÃ³w uÅ‚atwia komunikacjÄ™ w zespole.\n\nIssues:\n\nGitHub umoÅ¼liwia Å›ledzenie problemÃ³w i zadaÅ„ (issues). MoÅ¼esz tworzyÄ‡, przypisywaÄ‡, zamykaÄ‡ i dyskutowaÄ‡ na temat problemÃ³w, co uÅ‚atwia Å›ledzenie postÄ™pÃ³w w projekcie.\n\nIntegracje i Webhooks:\n\nGitHub oferuje integracje z rÃ³Å¼nymi narzÄ™dziami i usÅ‚ugami, co umoÅ¼liwia automatyzacjÄ™ rÃ³Å¼nych procesÃ³w w projekcie. Webhooki pozwalajÄ… na powiadamianie zewnÄ™trznych usÅ‚ug o zdarzeniach na GitHubie.\n\nPull Request Reviews:\n\nMoÅ¼liwoÅ›Ä‡ recenzowania kodu ÅºrÃ³dÅ‚owego w ramach pull requestÃ³w. Recenzenci mogÄ… komentowaÄ‡ zmiany, proponowaÄ‡ poprawki i potwierdzaÄ‡ gotowoÅ›Ä‡ do zaakceptowania zmian.\n\nGitHub Actions:\n\nGitHub Actions to funkcja pozwalajÄ…ca na automatyzacjÄ™ procesÃ³w budowania, testowania i wdraÅ¼ania kodu ÅºrÃ³dÅ‚owego za pomocÄ… skryptÃ³w.\n\nBezpieczeÅ„stwo:\n\nGitHub oferuje funkcje zabezpieczajÄ…ce, takie jak uwierzytelnianie dwuskÅ‚adnikowe, zarzÄ…dzanie dostÄ™pem i audyt.\n\n\nÅÄ…czÄ…c Git z Githubem, programiÅ›ci zyskujÄ… mocne narzÄ™dzie do kontroli wersji, wspÃ³Å‚pracy, Å›ledzenia problemÃ³w i automatyzacji procesÃ³w, co przyczynia siÄ™ do skutecznego zarzÄ…dzania projektami oprogramowania1.\n\n\n\n\nAby stworzyÄ‡ jakiekolwiek repozytorium, trzeba mieÄ‡ miejsce, w ktÃ³rym to zrobimy. A zatem utworzymy nowe konto na GitHub.\n\nPrzejdÅº na stronÄ™ https://github.com/\n\n\n\nStrona domowa GitHub\n\n\nNastÄ™pnie wpisz w miejsce na email swÃ³j adres poczty.\nW kolejnym kroku wypeÅ‚nij pola na stronie\n\nPo wypeÅ‚nieniu wszystkich pÃ³l zostaniesz poproszony o rozwiÄ…zanie testu na sprawdzenie czy jesteÅ› czÅ‚owiekiem ğŸ™‰.\n\nWpisz kod, ktÃ³ry otrzymasz na podany przez Ciebie email.\n\nW kolejnym oknie wybierz interesujÄ…ce CiÄ™ funkcjonalnoÅ›ci (moÅ¼esz teÅ¼ nie wybieraÄ‡ Å¼adnej).\n\nNa kolejnej stronie moÅ¼na wybraÄ‡ darmowe konto regularnego uÅ¼ytkownika ale jest teÅ¼ moÅ¼liwoÅ›Ä‡ zaÅ‚oÅ¼enia konta studenckiego (wÃ³wczas trzeba przy logowaniu podaÄ‡ email uczelniany po czym nastÄ…pi weryfikacja). Konto studenckie daje nieco wiÄ™cej moÅ¼liwoÅ›ci ale konto darmowe wystarczy do naszych zadaÅ„.\n\nW kolejnym kroku powinieneÅ› juÅ¼ zostaÄ‡ przeniesiony do strony gÅ‚Ã³wnej Twojego konta na Githubie ğŸ‘.\n\n\nChoÄ‡ wydaje siÄ™, Å¼e to koniec, to niestety tak nie jest ğŸ¤¯. W roku 2022 GitHub wprowadziÅ‚ dodatkowe zabezpieczenia i kaÅ¼de poÅ‚Ä…czenie z GitHubem musi byÄ‡ uwierzytelnione (wczeÅ›niej teÅ¼ tak byÅ‚o ale mimo to nieco proÅ›ciej moÅ¼na byÅ‚o to zrobiÄ‡). InstrukcjÄ™ jak uwierzytelniÄ‡ GitHub wraz z instalacjÄ… i dodaniem klucza publicznego SSH w Windows moÅ¼na znaleÅºÄ‡ pod adresem Instalacja Gita z SSH. InstrukcjÄ™ dodawania klucza SSH dla rÃ³Å¼nych platform moÅ¼na znaleÅºÄ‡ pod adresem https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account.\nMoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia repozytorium ğŸ˜² . ZaÅ‚Ã³Å¼my, Å¼e bÄ™dzie to repozytorium przeznaczone do testÃ³w (stÄ…d nazwa Github_tests).\n\n\n\nNazwa ta pewnie jest uÅ¼ywana wielokrotnie w caÅ‚ym Githubie (patrz ğŸ‘‰) ale my tworzymy repozytorium w ramach naszego konta dlatego faktycznie nazwa repozytorium bÄ™dzie nastÄ™pujÄ…ca DariuszMajerek/Github_tests - czyli jest poÅ‚Ä…czeniem nazwy uÅ¼ytkownika i repozytorium.\n\n\n\n\n\nPuste repozytorium wyglÄ…da nastÄ™pujÄ…co.\n\n\n\n\n\n\n\nImportant\n\n\n\nNajwaÅ¼niejsze z tej strony jest aby skopiowaÄ‡ adres repozytorium w formie HTTPS https://github.com/DariuszMajerek/Github_tests.git lub SSH git@github.com:DariuszMajerek/Github_tests.git.\n\n\n\n\n\n\nPÃ³ki co istniej tylko repozytorium zdalne (na Githubie, z resztÄ… puste) ale nie istnieje jego odpowiednik na dysku lokalnym. W tym celu naleÅ¼y utworzyÄ‡ katalog o tej samej nazwie co nazwa repozytorium (bez nazwy uÅ¼ytkownika) a nastÄ™pnie przejÅ›Ä‡ do tego katalogu.\n\n\n\nTworzenie katalogu repo\n\n\n\n\n\n\n\n\nCaution\n\n\n\nPowyÅ¼szy ekran moÅ¼e nieco inaczej wyglÄ…daÄ‡ w innych systemach operacyjnych.\n\n\nW katalogu repo2 inicjujemy repo lokalne poprzez\ngit init\n\n# nastepnie sprawdzamy status repo\ngit status\n\nZainicjowanie lokalnego repo pozwala wymieniaÄ‡ dane pomiÄ™dzy repo lokalnym i zdalnym (w obie strony). MoÅ¼emy o tym myÅ›leÄ‡ w ten sposÃ³b, Å¼e sÄ… trzy stany naszego repo:\n\nlokalne - na dysku (ang. working dir);\nzdalne - na serwerze np. Github (ang. HEAD);\ntymczasowe - instancja naszego repo w wersji tymczasowej istniejÄ…ca na dysku (ang. index), ktÃ³ra powinna zostaÄ‡ przesÅ‚ana (wypchniÄ™ta - push) na serwer. Ta czynnoÅ›Ä‡ jest opisana w tÄ™ stronÄ™, bo najczÄ™Å›ciej to zmiany na dysku lokalnym, gdzie tworzymy model, wypychamy na serwer.\n\n\n\n\nTrzy stany repo\n\n\nInicjacja jedynie tworzy katalog .git z plikami konfiguracyjnymi repo. Nic poza tym katalogiem nie zawiera. Teraz przystÄ…pimy do dodania pierwszego pliku do repo. Dobrym zwyczajem jest dodanie pliku README.md, w ktÃ³rym znajdÄ… siÄ™ podstawowe informacje dotyczÄ…ce repo. Plik ten powinien byÄ‡ napisany w jÄ™zyku markdown aby GitHub mÃ³gÅ‚ bo przetworzyÄ‡ i wyÅ›wietliÄ‡ w sformatowany sposÃ³b.\n# plik README.md moÅ¼na utworzyÄ‡ na kilka sposÃ³bÃ³w, m.in w R\n# w poniÅ¼szym przykÅ‚adzie pokazujÄ™ jak to moÅ¼na zrobiÄ‡ w terminalu\n# poniÅ¼szy kod stworzy nowy plik README.md i doda jedynie tytuÅ‚ rozdziaÅ‚u \necho \"# Github_tests\" &gt;&gt; README.md\nJak widaÄ‡ na zaÅ‚Ä…czonym obrazie powstaÅ‚ plik README.md i zostaÅ‚ wypeÅ‚niony treÅ›ciÄ….\n\nPoniewaÅ¼ nastÄ…piÅ‚y pierwsze zmiany w repo (dodaliÅ›my plik README.md), to moÅ¼emy te zmiany wysÅ‚aÄ‡ na serwer, na ktÃ³rym obecnie zmiany te nie sÄ… jeszcze uwzglÄ™dnione.\n# dodajemy plik README.md do commita, czyli nowej wersji repo\n# commitami oznaczamy nowe wersje repo\ngit add README.md\n\n# jeÅ›li chcemy dodaÄ‡ wiÄ™cej plikÃ³w i katalogÃ³w jednoczeÅ›nie (a tak siÄ™ dzieje najczÄ™Å›ciej)\n# bo chcemy commitowaÄ‡ stan po zmianach w repo to wywoÅ‚ujemy\ngit add .\nPo tej czynnoÅ›ci moÅ¼emy sprawdziÄ‡ status repo za pomocÄ…\ngit status\nWynik tych dziaÅ‚aÅ„ jest nastÄ™pujÄ…cy\n\n\n\nRepo po zmianach\n\n\nJak widaÄ‡ plik README.md zostaÅ‚ dodany do tymczasowego stanu repo ale nie zostaÅ‚ on jeszcze przesÅ‚any na serwer. WidaÄ‡ teÅ¼, Å¼e Å¼aden commit nie zostaÅ‚ utworzony. Przez commit rozumiemy jakby snapshot obecnego stanu repo. PÃ³ki go nie wypchniemy na serwer zmiany te sÄ… zapisane jedynie lokalnie. PrzejdÅºmy do pierwszego commitu naszego repo. KaÅ¼dy commit powinien byÄ‡ opatrzony komentarzem, ktÃ³ry informuje nas co zmieniliÅ›my w repo3. Flaga -m oznacza chÄ™Ä‡ dodania komentarza.\ngit commit -m \"pierwszy commit\"\nPo wykonaniu commita i sprawdzeniu stanu\n\nChoÄ‡ stworzyliÅ›my commita, wiÄ™c zapisaliÅ›my stan repo po zmianach, to zmiany te nie zostaÅ‚y zaktualizowane na serwerze GitHub. Aby tego dokonaÄ‡ musimy podaÄ‡ adres repo zdalnego oraz wypchnÄ…Ä‡ lokalne zmiany na serwer.\n# podÅ‚Ä…czenie zdalnego repo pod nazwÄ… origin\ngit remote add origin \"git@github.com:DariuszMajerek/Github_tests.git\"\n\n\n\nPozostaÅ‚o nam wypchnÄ…Ä‡ pliki na serwer.\n# poniewaÅ¼ wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº nazwanÄ… main to komenda jest nastÄ™pujÄ…ca\ngit push -u origin main\nUstawienie flagi -u w poleceniu git push ustawia tzw upstream. W przyszÅ‚oÅ›ci jeÅ›li chcemy wypchnÄ…Ä‡ stan repo lokalnego wystarczy komenda git push bez origin i main o ile chcemy wysÅ‚aÄ‡ wszystko do tej samej gaÅ‚Ä™zi.\nW momencie wywoÅ‚ania tej komendy bÄ™dziemy prawdopodobnie poproszeni o hasÅ‚o do konta GitHub. JeÅ›li siÄ™ wszystko powiedzie, to ekran powinien wyglÄ…daÄ‡ nastÄ™pujÄ…co.\n\n\n\nREADME.md dodane do repo zdalnego\n\n\nI faktycznie w repo zdalnym siÄ™ to znajduje\n\n\n\nUwaga: w kolejnej prÃ³bie (bo pierwsza siÄ™ nie udaÅ‚a) dodaÅ‚em commit z innÄ… nazwÄ… â€œfirst commitâ€\n\n\nPo dodaniu commita i push do gaÅ‚Ä™zi gÅ‚Ã³wnej main stan repo lokalnego (na dysku komputera) i zdalnego sÄ… identyczne.\n\nJeÅ›li chcemy pobraÄ‡ obecny stan repo na dysk lokalny, wÃ³wczas uÅ¼ywamy komendy git pull remote_name branch_name, gdzie remote_name oznacza adres zdalnego repo, a branch_name nazwÄ™ gaÅ‚Ä™zi jakÄ… chcemy pobraÄ‡ (w tym momencie nasze repo posiada tylko jednÄ… gaÅ‚Ä…Åº ale w przyszÅ‚oÅ›ci moÅ¼e mieÄ‡ ich wiÄ™cej).\n\n\n\n\n\n\nImportant\n\n\n\nBardzo waÅ¼nÄ… zasadÄ… jest to aby repo zdalne i lokalne byÅ‚y identyczne. DbaÄ‡ o to bÄ™dzie sam git. Natomiast jeÅ›li zaczynamy pracowaÄ‡ nad rozwojem repo, dobrÄ… praktykÄ… jest najpierw pobranie obecnego stanu repo zdalnego przez komendÄ™ git pull.\n\n\nMoÅ¼e siÄ™ rÃ³wnieÅ¼ zdarzyÄ‡, Å¼e wspÃ³Å‚pracownicy, ktÃ³rzy pracujÄ… rÃ³wnolegle nad naszym projektem mogÄ… dokonaÄ‡ zmiany zdalnego repo i wÃ³wczas pobranie obecnego stanu repo zdalnego jest niemal zawsze konieczne.\nPoniewaÅ¼ zmian w repo zdalnym moÅ¼na dokonywaÄ‡ za pomocÄ… przeglÄ…darki i strony GitHub, to dokonamy rozwiniÄ™cia README.md. Zmiany dokonywane na serwerze (poprzez stronÄ™ internetowÄ…) wymagajÄ… rÃ³wnieÅ¼ commitowania zmian, tak abyÅ›my mogli kontrolowaÄ‡ wersjÄ™ naszego repo. W pliku README.md dodaÅ‚em jedno zdanie o treÅ›ci â€œTo repozytarium bÄ™dzie sÅ‚uÅ¼yÄ‡ do Ä‡wiczeÅ„ zwiÄ…zanych z usÅ‚ugami kontroli wersji.â€ i commitowaÅ‚em to z komentarzem â€œUpdate README.mdâ€.\n\nTo jest stan najbardziej aktualny naszego repo. Dlatego pobierzemy go na dysk aby repo lokalne i zdalne siÄ™ zgadzaÅ‚y.\n# pobieramy aktualny stan repo zdalnego\n# poniewaÅ¼ mamy tylko jednÄ… gaÅ‚Ä…Åº a origin jest ustawione na wÅ‚aÅ›ciwe repo\n# ponadto ustawiliÅ›my wczeÅ›niej flagÄ™ przy push -u to nie musimy dodawaÄ‡ innych parametrÃ³w\ngit pull\n\n\n\nEfekt dziaÅ‚ania git pull\n\n\nCzujne oko pewnie juÅ¼ zauwaÅ¼yÅ‚o, Å¼e w pliku README.md wpisujÄ…c zdanie popeÅ‚niÅ‚em bÅ‚Ä…d (literÃ³wkÄ™) w sÅ‚owie repozytorium. PoniewaÅ¼ plik mamy pobrany do lokalnego repo, to moÅ¼emy go poprawiÄ‡ (lokalnie np. w RStudio) i wypchnÄ…Ä‡ na serwer. Po zmianach lokalnego repo stan jest nastÄ™pujÄ…cy\n\nJak widaÄ‡ czÄ™Å›Ä‡ zmian nie zostaÅ‚a commitowana. Zmiany dokonane lokalnie najpierw trzeba dodaÄ‡ do tzw Stage, a nastÄ™pnie je commitowaÄ‡.\ngit add . # dodajemy zmiany do Stage\ngit status # po to by zobaczyÄ‡ stan Stage\ngit commit -m \"Fix typo in README.md\"\ngit stage\n\n# podobnie przy wypychaniu jeÅ›li chcemy wypchnÄ…Ä‡ do gaÅ‚Ä™zi gÅ‚Ã³wnej\n# to nie musimy dodawaÄ‡ parametrÃ³w przy git push\ngit push\n\n\n\nStan po wypchniÄ™ciu danych na serwer\n\n\nZmiany na serwerze zostaÅ‚y zapisane.\n\n\n\n\n\n\n\nNote\n\n\n\nPolecenie git pull jest poÅ‚Ä…czeniem git fetch, ktÃ³re pobiera ostatnie zatwierdzenia w lokalnym repozytorium i git merge, ktÃ³re poÅ‚Ä…czy gaÅ‚Ä…Åº ze zdalnej do lokalnej gaÅ‚Ä™zi."
  },
  {
    "objectID": "wyk1.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "href": "wyk1.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "title": "WykÅ‚ad 1",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych.\n\n\n\n\n\n\n\nKonieczne w tym procesie jest kontrolowanie aktualnej wersji modelu i wszystkich przylegÅ‚oÅ›ci z nim zwiÄ…zanych. Idealnym narzÄ™dziem do zautomatyzowania czynnoÅ›ci polegajÄ…cych na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program dziaÅ‚ajÄ…cy w terminalu ale istniejÄ… rÃ³wnieÅ¼ jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednoczeÅ›nie poÅ‚Ä…czony z hubem (czyli kontenerem) pozwalajÄ…cym na przechowywanie i udostÄ™pnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usÅ‚uga serwerowa, ktÃ³ra pozwala na zapisywanie i udostÄ™pnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\n\n\n\n\n\n\n\nW niniejszym wykÅ‚adzie zostanÄ… przedstawione rozwiÄ…zania z wykorzystaniem Gita i GitHuba.\nPrzykÅ‚adowe repozytorium projektu tidymodels na stronie GitHub wyglÄ…da nastÄ™pujÄ…co.\n\n\n\nStrona projektu tidymodels na GitHubie\n\n\nGit w poÅ‚Ä…czeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, ktÃ³ry tworzymy, a jednoczeÅ›nie na udostÄ™pnianie go oraz umoÅ¼liwienie wspÃ³Å‚pracy nad kodem przez wielu uÅ¼ytkownikÃ³w - wspÃ³Å‚twÃ³rcÃ³w (ang. contributors) ale nie tylko. UdostÄ™pnianie moÅ¼e byÄ‡ zarÃ³wno publiczne, jak i prywatne.\nFunkcjonalnoÅ›ci GitHub, to:\n\nKontrola wersji kodu.\nKopiowanie kodu na dwa sposoby:\n\nClone:\n\nKlonowanie repozytorium oznacza skopiowanie zdalnego repozytorium na lokalny komputer.\nGdy klonujesz repozytorium, uzyskujesz identycznÄ… kopiÄ™ zawartoÅ›ci, historii i gaÅ‚Ä™zi tego repozytorium na swoim lokalnym systemie.\nMoÅ¼esz pracowaÄ‡ nad projektem lokalnie i wysyÅ‚aÄ‡ swoje zmiany z powrotem do zdalnego repozytorium.\n\nPrzykÅ‚ad klonowania repozytorium:\n\ngit clone https://github.com/nazwa_uzytkownika/nazwa_repozytorium.git\n\nFork:\n\nForking (rozszerzanie) repozytorium oznacza utworzenie kopii zdalnego repozytorium w obrÄ™bie twojego konta na GitHubie.\nKiedy forkujesz repozytorium, masz wÅ‚asnÄ… kopiÄ™, ktÃ³rÄ… moÅ¼esz dowolnie modyfikowaÄ‡, nie wpÅ‚ywajÄ…c na oryginalne repozytorium.\nForkowanie jest czÄ™sto uÅ¼ywane w projekcie open source, gdzie chcesz dodaÄ‡ swoje zmiany, ale nie masz bezpoÅ›redniego dostÄ™pu do repozytorium.\n\nPrzykÅ‚ad forka repozytorium:\n\nNa stronie repozytorium w witrynie GitHub klikasz przycisk â€œForkâ€ w prawym gÃ³rnym rogu. To utworzy kopiÄ™ tego repozytorium w twoim wÅ‚asnym koncie.\n\nForking pozwala ci pracowaÄ‡ niezaleÅ¼nie nad projektem, a nastÄ™pnie moÅ¼esz zgÅ‚osiÄ‡ pull request (proÅ›bÄ™ o zaakceptowanie zmian) do oryginalnego repozytorium, aby wÅ‚aÅ›ciciel mÃ³gÅ‚ uwzglÄ™dniÄ‡ twoje zmiany.\n\nZarzÄ…dzanie Branchami:\n\nGitHub oferuje narzÄ™dzia do Å‚atwego zarzÄ…dzania gaÅ‚Ä™ziami (branches). MoÅ¼esz tworzyÄ‡, usuwaÄ‡ i Å‚Ä…czyÄ‡ gaÅ‚Ä™zie za pomocÄ… interfejsu graficznego.\n\nKomentarze i Dyskusje:\n\nMoÅ¼liwoÅ›Ä‡ dodawania komentarzy do kodu ÅºrÃ³dÅ‚owego, pull requestÃ³w i problemÃ³w uÅ‚atwia komunikacjÄ™ w zespole.\n\nIssues:\n\nGitHub umoÅ¼liwia Å›ledzenie problemÃ³w i zadaÅ„ (issues). MoÅ¼esz tworzyÄ‡, przypisywaÄ‡, zamykaÄ‡ i dyskutowaÄ‡ na temat problemÃ³w, co uÅ‚atwia Å›ledzenie postÄ™pÃ³w w projekcie.\n\nIntegracje i Webhooks:\n\nGitHub oferuje integracje z rÃ³Å¼nymi narzÄ™dziami i usÅ‚ugami, co umoÅ¼liwia automatyzacjÄ™ rÃ³Å¼nych procesÃ³w w projekcie. Webhooki pozwalajÄ… na powiadamianie zewnÄ™trznych usÅ‚ug o zdarzeniach na GitHubie.\n\nPull Request Reviews:\n\nMoÅ¼liwoÅ›Ä‡ recenzowania kodu ÅºrÃ³dÅ‚owego w ramach pull requestÃ³w. Recenzenci mogÄ… komentowaÄ‡ zmiany, proponowaÄ‡ poprawki i potwierdzaÄ‡ gotowoÅ›Ä‡ do zaakceptowania zmian.\n\nGitHub Actions:\n\nGitHub Actions to funkcja pozwalajÄ…ca na automatyzacjÄ™ procesÃ³w budowania, testowania i wdraÅ¼ania kodu ÅºrÃ³dÅ‚owego za pomocÄ… skryptÃ³w.\n\nBezpieczeÅ„stwo:\n\nGitHub oferuje funkcje zabezpieczajÄ…ce, takie jak uwierzytelnianie dwuskÅ‚adnikowe, zarzÄ…dzanie dostÄ™pem i audyt.\n\n\nÅÄ…czÄ…c Git z Githubem, programiÅ›ci zyskujÄ… mocne narzÄ™dzie do kontroli wersji, wspÃ³Å‚pracy, Å›ledzenia problemÃ³w i automatyzacji procesÃ³w, co przyczynia siÄ™ do skutecznego zarzÄ…dzania projektami oprogramowania1.\n\n\n\n\nAby stworzyÄ‡ jakiekolwiek repozytorium, trzeba mieÄ‡ miejsce, w ktÃ³rym to zrobimy. A zatem utworzymy nowe konto na GitHub.\n\nPrzejdÅº na stronÄ™ https://github.com/\n\n\n\nStrona domowa GitHub\n\n\nNastÄ™pnie wpisz w miejsce na email swÃ³j adres poczty.\nW kolejnym kroku wypeÅ‚nij pola na stronie\n\nPo wypeÅ‚nieniu wszystkich pÃ³l zostaniesz poproszony o rozwiÄ…zanie testu na sprawdzenie czy jesteÅ› czÅ‚owiekiem ğŸ™‰.\n\nWpisz kod, ktÃ³ry otrzymasz na podany przez Ciebie email.\n\nW kolejnym oknie wybierz interesujÄ…ce CiÄ™ funkcjonalnoÅ›ci (moÅ¼esz teÅ¼ nie wybieraÄ‡ Å¼adnej).\n\nNa kolejnej stronie moÅ¼na wybraÄ‡ darmowe konto regularnego uÅ¼ytkownika ale jest teÅ¼ moÅ¼liwoÅ›Ä‡ zaÅ‚oÅ¼enia konta studenckiego (wÃ³wczas trzeba przy logowaniu podaÄ‡ email uczelniany po czym nastÄ…pi weryfikacja). Konto studenckie daje nieco wiÄ™cej moÅ¼liwoÅ›ci ale konto darmowe wystarczy do naszych zadaÅ„.\n\nW kolejnym kroku powinieneÅ› juÅ¼ zostaÄ‡ przeniesiony do strony gÅ‚Ã³wnej Twojego konta na Githubie ğŸ‘.\n\n\nChoÄ‡ wydaje siÄ™, Å¼e to koniec, to niestety tak nie jest ğŸ¤¯. W roku 2022 GitHub wprowadziÅ‚ dodatkowe zabezpieczenia i kaÅ¼de poÅ‚Ä…czenie z GitHubem musi byÄ‡ uwierzytelnione (wczeÅ›niej teÅ¼ tak byÅ‚o ale mimo to nieco proÅ›ciej moÅ¼na byÅ‚o to zrobiÄ‡). InstrukcjÄ™ jak uwierzytelniÄ‡ GitHub wraz z instalacjÄ… i dodaniem klucza publicznego SSH w Windows moÅ¼na znaleÅºÄ‡ pod adresem Instalacja Gita z SSH. InstrukcjÄ™ dodawania klucza SSH dla rÃ³Å¼nych platform moÅ¼na znaleÅºÄ‡ pod adresem https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account.\nMoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia repozytorium ğŸ˜² . ZaÅ‚Ã³Å¼my, Å¼e bÄ™dzie to repozytorium przeznaczone do testÃ³w (stÄ…d nazwa Github_tests).\n\n\n\nNazwa ta pewnie jest uÅ¼ywana wielokrotnie w caÅ‚ym Githubie (patrz ğŸ‘‰) ale my tworzymy repozytorium w ramach naszego konta dlatego faktycznie nazwa repozytorium bÄ™dzie nastÄ™pujÄ…ca DariuszMajerek/Github_tests - czyli jest poÅ‚Ä…czeniem nazwy uÅ¼ytkownika i repozytorium.\n\n\n\n\n\nPuste repozytorium wyglÄ…da nastÄ™pujÄ…co.\n\n\n\n\n\n\n\nImportant\n\n\n\nNajwaÅ¼niejsze z tej strony jest aby skopiowaÄ‡ adres repozytorium w formie HTTPS https://github.com/DariuszMajerek/Github_tests.git lub SSH git@github.com:DariuszMajerek/Github_tests.git.\n\n\n\n\n\n\nPÃ³ki co istniej tylko repozytorium zdalne (na Githubie, z resztÄ… puste) ale nie istnieje jego odpowiednik na dysku lokalnym. W tym celu naleÅ¼y utworzyÄ‡ katalog o tej samej nazwie co nazwa repozytorium (bez nazwy uÅ¼ytkownika) a nastÄ™pnie przejÅ›Ä‡ do tego katalogu.\n\n\n\nTworzenie katalogu repo\n\n\n\n\n\n\n\n\nCaution\n\n\n\nPowyÅ¼szy ekran moÅ¼e nieco inaczej wyglÄ…daÄ‡ w innych systemach operacyjnych.\n\n\nW katalogu repo2 inicjujemy repo lokalne poprzez\ngit init\n\n# nastepnie sprawdzamy status repo\ngit status\n\nZainicjowanie lokalnego repo pozwala wymieniaÄ‡ dane pomiÄ™dzy repo lokalnym i zdalnym (w obie strony). MoÅ¼emy o tym myÅ›leÄ‡ w ten sposÃ³b, Å¼e sÄ… trzy stany naszego repo:\n\nlokalne - na dysku (ang. working dir);\nzdalne - na serwerze np. Github (ang. HEAD);\ntymczasowe - instancja naszego repo w wersji tymczasowej istniejÄ…ca na dysku (ang. index), ktÃ³ra powinna zostaÄ‡ przesÅ‚ana (wypchniÄ™ta - push) na serwer. Ta czynnoÅ›Ä‡ jest opisana w tÄ™ stronÄ™, bo najczÄ™Å›ciej to zmiany na dysku lokalnym, gdzie tworzymy model, wypychamy na serwer.\n\n\n\n\nTrzy stany repo\n\n\nInicjacja jedynie tworzy katalog .git z plikami konfiguracyjnymi repo. Nic poza tym katalogiem nie zawiera. Teraz przystÄ…pimy do dodania pierwszego pliku do repo. Dobrym zwyczajem jest dodanie pliku README.md, w ktÃ³rym znajdÄ… siÄ™ podstawowe informacje dotyczÄ…ce repo. Plik ten powinien byÄ‡ napisany w jÄ™zyku markdown aby GitHub mÃ³gÅ‚ bo przetworzyÄ‡ i wyÅ›wietliÄ‡ w sformatowany sposÃ³b.\n# plik README.md moÅ¼na utworzyÄ‡ na kilka sposÃ³bÃ³w, m.in w R\n# w poniÅ¼szym przykÅ‚adzie pokazujÄ™ jak to moÅ¼na zrobiÄ‡ w terminalu\n# poniÅ¼szy kod stworzy nowy plik README.md i doda jedynie tytuÅ‚ rozdziaÅ‚u \necho \"# Github_tests\" &gt;&gt; README.md\nJak widaÄ‡ na zaÅ‚Ä…czonym obrazie powstaÅ‚ plik README.md i zostaÅ‚ wypeÅ‚niony treÅ›ciÄ….\n\nPoniewaÅ¼ nastÄ…piÅ‚y pierwsze zmiany w repo (dodaliÅ›my plik README.md), to moÅ¼emy te zmiany wysÅ‚aÄ‡ na serwer, na ktÃ³rym obecnie zmiany te nie sÄ… jeszcze uwzglÄ™dnione.\n# dodajemy plik README.md do commita, czyli nowej wersji repo\n# commitami oznaczamy nowe wersje repo\ngit add README.md\n\n# jeÅ›li chcemy dodaÄ‡ wiÄ™cej plikÃ³w i katalogÃ³w jednoczeÅ›nie (a tak siÄ™ dzieje najczÄ™Å›ciej)\n# bo chcemy commitowaÄ‡ stan po zmianach w repo to wywoÅ‚ujemy\ngit add .\nPo tej czynnoÅ›ci moÅ¼emy sprawdziÄ‡ status repo za pomocÄ…\ngit status\nWynik tych dziaÅ‚aÅ„ jest nastÄ™pujÄ…cy\n\n\n\nRepo po zmianach\n\n\nJak widaÄ‡ plik README.md zostaÅ‚ dodany do tymczasowego stanu repo ale nie zostaÅ‚ on jeszcze przesÅ‚any na serwer. WidaÄ‡ teÅ¼, Å¼e Å¼aden commit nie zostaÅ‚ utworzony. Przez commit rozumiemy jakby snapshot obecnego stanu repo. PÃ³ki go nie wypchniemy na serwer zmiany te sÄ… zapisane jedynie lokalnie. PrzejdÅºmy do pierwszego commitu naszego repo. KaÅ¼dy commit powinien byÄ‡ opatrzony komentarzem, ktÃ³ry informuje nas co zmieniliÅ›my w repo3. Flaga -m oznacza chÄ™Ä‡ dodania komentarza.\ngit commit -m \"pierwszy commit\"\nPo wykonaniu commita i sprawdzeniu stanu\n\nChoÄ‡ stworzyliÅ›my commita, wiÄ™c zapisaliÅ›my stan repo po zmianach, to zmiany te nie zostaÅ‚y zaktualizowane na serwerze GitHub. Aby tego dokonaÄ‡ musimy podaÄ‡ adres repo zdalnego oraz wypchnÄ…Ä‡ lokalne zmiany na serwer.\n# podÅ‚Ä…czenie zdalnego repo pod nazwÄ… origin\ngit remote add origin \"git@github.com:DariuszMajerek/Github_tests.git\"\n\n\n\nPozostaÅ‚o nam wypchnÄ…Ä‡ pliki na serwer.\n# poniewaÅ¼ wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº nazwanÄ… main to komenda jest nastÄ™pujÄ…ca\ngit push -u origin main\nUstawienie flagi -u w poleceniu git push ustawia tzw upstream. W przyszÅ‚oÅ›ci jeÅ›li chcemy wypchnÄ…Ä‡ stan repo lokalnego wystarczy komenda git push bez origin i main o ile chcemy wysÅ‚aÄ‡ wszystko do tej samej gaÅ‚Ä™zi.\nW momencie wywoÅ‚ania tej komendy bÄ™dziemy prawdopodobnie poproszeni o hasÅ‚o do konta GitHub. JeÅ›li siÄ™ wszystko powiedzie, to ekran powinien wyglÄ…daÄ‡ nastÄ™pujÄ…co.\n\n\n\nREADME.md dodane do repo zdalnego\n\n\nI faktycznie w repo zdalnym siÄ™ to znajduje\n\n\n\nUwaga: w kolejnej prÃ³bie (bo pierwsza siÄ™ nie udaÅ‚a) dodaÅ‚em commit z innÄ… nazwÄ… â€œfirst commitâ€\n\n\nPo dodaniu commita i push do gaÅ‚Ä™zi gÅ‚Ã³wnej main stan repo lokalnego (na dysku komputera) i zdalnego sÄ… identyczne.\n\nJeÅ›li chcemy pobraÄ‡ obecny stan repo na dysk lokalny, wÃ³wczas uÅ¼ywamy komendy git pull remote_name branch_name, gdzie remote_name oznacza adres zdalnego repo, a branch_name nazwÄ™ gaÅ‚Ä™zi jakÄ… chcemy pobraÄ‡ (w tym momencie nasze repo posiada tylko jednÄ… gaÅ‚Ä…Åº ale w przyszÅ‚oÅ›ci moÅ¼e mieÄ‡ ich wiÄ™cej).\n\n\n\n\n\n\nImportant\n\n\n\nBardzo waÅ¼nÄ… zasadÄ… jest to aby repo zdalne i lokalne byÅ‚y identyczne. DbaÄ‡ o to bÄ™dzie sam git. Natomiast jeÅ›li zaczynamy pracowaÄ‡ nad rozwojem repo, dobrÄ… praktykÄ… jest najpierw pobranie obecnego stanu repo zdalnego przez komendÄ™ git pull.\n\n\nMoÅ¼e siÄ™ rÃ³wnieÅ¼ zdarzyÄ‡, Å¼e wspÃ³Å‚pracownicy, ktÃ³rzy pracujÄ… rÃ³wnolegle nad naszym projektem mogÄ… dokonaÄ‡ zmiany zdalnego repo i wÃ³wczas pobranie obecnego stanu repo zdalnego jest niemal zawsze konieczne.\nPoniewaÅ¼ zmian w repo zdalnym moÅ¼na dokonywaÄ‡ za pomocÄ… przeglÄ…darki i strony GitHub, to dokonamy rozwiniÄ™cia README.md. Zmiany dokonywane na serwerze (poprzez stronÄ™ internetowÄ…) wymagajÄ… rÃ³wnieÅ¼ commitowania zmian, tak abyÅ›my mogli kontrolowaÄ‡ wersjÄ™ naszego repo. W pliku README.md dodaÅ‚em jedno zdanie o treÅ›ci â€œTo repozytarium bÄ™dzie sÅ‚uÅ¼yÄ‡ do Ä‡wiczeÅ„ zwiÄ…zanych z usÅ‚ugami kontroli wersji.â€ i commitowaÅ‚em to z komentarzem â€œUpdate README.mdâ€.\n\nTo jest stan najbardziej aktualny naszego repo. Dlatego pobierzemy go na dysk aby repo lokalne i zdalne siÄ™ zgadzaÅ‚y.\n# pobieramy aktualny stan repo zdalnego\n# poniewaÅ¼ mamy tylko jednÄ… gaÅ‚Ä…Åº a origin jest ustawione na wÅ‚aÅ›ciwe repo\n# ponadto ustawiliÅ›my wczeÅ›niej flagÄ™ przy push -u to nie musimy dodawaÄ‡ innych parametrÃ³w\ngit pull\n\n\n\nEfekt dziaÅ‚ania git pull\n\n\nCzujne oko pewnie juÅ¼ zauwaÅ¼yÅ‚o, Å¼e w pliku README.md wpisujÄ…c zdanie popeÅ‚niÅ‚em bÅ‚Ä…d (literÃ³wkÄ™) w sÅ‚owie repozytorium. PoniewaÅ¼ plik mamy pobrany do lokalnego repo, to moÅ¼emy go poprawiÄ‡ (lokalnie np. w RStudio) i wypchnÄ…Ä‡ na serwer. Po zmianach lokalnego repo stan jest nastÄ™pujÄ…cy\n\nJak widaÄ‡ czÄ™Å›Ä‡ zmian nie zostaÅ‚a commitowana. Zmiany dokonane lokalnie najpierw trzeba dodaÄ‡ do tzw Stage, a nastÄ™pnie je commitowaÄ‡.\ngit add . # dodajemy zmiany do Stage\ngit status # po to by zobaczyÄ‡ stan Stage\ngit commit -m \"Fix typo in README.md\"\ngit stage\n\n# podobnie przy wypychaniu jeÅ›li chcemy wypchnÄ…Ä‡ do gaÅ‚Ä™zi gÅ‚Ã³wnej\n# to nie musimy dodawaÄ‡ parametrÃ³w przy git push\ngit push\n\n\n\nStan po wypchniÄ™ciu danych na serwer\n\n\nZmiany na serwerze zostaÅ‚y zapisane.\n\n\n\n\n\n\n\nNote\n\n\n\nPolecenie git pull jest poÅ‚Ä…czeniem git fetch, ktÃ³re pobiera ostatnie zatwierdzenia w lokalnym repozytorium i git merge, ktÃ³re poÅ‚Ä…czy gaÅ‚Ä…Åº ze zdalnej do lokalnej gaÅ‚Ä™zi."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "WykÅ‚ad 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNie wszystkie z powyÅ¼szych tematÃ³w uda nam siÄ™ omÃ³wiÄ‡ na wykÅ‚adzie ale wiÄ™kszoÅ›Ä‡ zostanie zademonstrowana.â†©ï¸\nskrÃ³t od repozytoriumâ†©ï¸\nwprawdzie na tym etapie dodaliÅ›my plik README.md ale poniewaÅ¼ jest to pierwszy commit to tak go nazwaliÅ›my.â†©ï¸"
  }
]