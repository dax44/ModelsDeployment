[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych.",
    "crumbs": [
      "Wstęp"
    ]
  },
  {
    "objectID": "index.html#przebieg-prac-nad-wdrożeniem-modelu",
    "href": "index.html#przebieg-prac-nad-wdrożeniem-modelu",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych.",
    "crumbs": [
      "Wstęp"
    ]
  },
  {
    "objectID": "wyk7.html",
    "href": "wyk7.html",
    "title": "Wykład 7",
    "section": "",
    "text": "Możliwość zapisywania i udostępniania stanu aplikacji Shiny poprzez zakładki (ang. bookmarking) znacząco rozszerza funkcjonalność tych aplikacji, czyniąc je bardziej interaktywnymi i przyjaznymi dla użytkownika. Poniżej znajduje się opis sposobów realizacji tej funkcjonalności, wraz z przykładami użycia.\n\nDomyślnie aplikacje Shiny nie umożliwiają łatwego powrotu do wcześniej uzyskanego stanu ani udostępniania go innym. Aby to zmienić i umożliwić zapisywanie stanu aplikacji w URL, można wykorzystać funkcjonalność zakładek. Poniżej przedstawiono kroki niezbędne do osiągnięcia tego celu na przykładzie aplikacji generującej figury Lissajous:\n\n\nDodanie przycisku zakładki - w interfejsie użytkownika dodajemy bookmarkButton(), który umożliwia generowanie URL z zapisanym stanem aplikacji.\n\nKodui &lt;- function(request) {\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        sliderInput(\"omega\", \"omega\", value = 1, min = -2, max = 2, step = 0.01),\n        sliderInput(\"delta\", \"delta\", value = 1, min = 0, max = 2, step = 0.01),\n        sliderInput(\"damping\", \"damping\", value = 1, min = 0.9, max = 1, step = 0.001),\n        numericInput(\"length\", \"length\", value = 100),\n        bookmarkButton()\n      ),\n      mainPanel(plotOutput(\"fig\"))\n    )\n  )\n}\n\n\n\nTransformacja UI w funkcję - aby umożliwić dynamiczne dostosowywanie interfejsu w zależności od zapisanych wartości, UI aplikacji musi być zdefiniowane jako funkcja.\n\nWłączenie zakładek - w wywołaniu shinyApp() dodajemy enableBookmarking = \"url\", aby umożliwić zapisywanie stanu aplikacji w URL.\n\nKodshinyApp(ui, server, enableBookmarking = \"url\")\n\n\n\n\n\n\n\n\n\n\nAdnotacja\n\n\n\nMożna ją wypróbować na stronie https://hadley.shinyapps.io/ms-bookmark-url. Jeśli pobawisz się aplikacją i dodasz do zakładek kilka interesujących stanów, zobaczysz, że wygenerowane adresy URL wyglądają mniej więcej tak:\n\nhttps://hadley.shinyapps.io/ms-bookmark-url/?inputs&damping=1&delta=1&length=100&omega=1\nhttps://hadley.shinyapps.io/ms-bookmark-url/?inputs&damping=0.966&delta=1.25&length=100&omega=-0.54\nhttps://hadley.shinyapps.io/ms-bookmark-url/?inputs&damping=0.997&delta=1.37&length=500&omega=-0.9\n\nAby zrozumieć, co się dzieje, weźmy pierwszy adres URL i podzielmy go na części:\n\nhttp:// to “protokół” używany do komunikacji z aplikacją. Zawsze będzie to http lub https.\nhadley.shinyapps.io/ms-bookmark-url to lokalizacja aplikacji.\n\nWszystko po ? jest “parametrem”. Każdy parametr jest oddzielony znakiem &, a jeśli go rozdzielisz, możesz zobaczyć wartości każdego wejścia w aplikacji:\n\ndamping=1\ndelta=1\nlength=100\nomega=1\n\nTak więc “wygenerowanie zakładki” oznacza zapisanie aktualnych wartości danych wejściowych w parametrach adresu URL. Jeśli zrobisz to lokalnie, adresy URL będą wyglądać nieco inaczej:\n\nhttp://127.0.0.1:4087/?inputs&damping=1&delta=1&length=100&omega=1\nhttp://127.0.0.1:4087/?inputs&damping=0.966&delta=1.25&length=100&omega=-0.54\nhttp://127.0.0.1:4087/?inputs&damping=0.997&delta=1.37&length=500&omega=-0.9\n\nWiększość elementów jest taka sama, z wyjątkiem tego, że zamiast hadley.shinyapps.io/ms-bookmark-url jest coś w rodzaju 127.0.0.1:4087. 127.0.0.1 to specjalny adres, który zawsze wskazuje na twój własny komputer, a 4087 to losowo przypisany port. Zwykle różne aplikacje otrzymują różne ścieżki lub adresy IP, ale nie jest to możliwe, gdy hostujesz wiele aplikacji na własnym komputerze.\n\n\n\nMożna także zautomatyzować proces aktualizacji URL bez konieczności klikania przycisku, używając odpowiednich funkcji w server. Poniżej znajduje się przykład, jak to zrealizować:\n\nKodserver &lt;- function(input, output, session) {\n  # Kod generujący treść aplikacji...\n  \n  observe({\n    reactiveValuesToList(input)\n    session$doBookmark()\n  })\n  onBookmarked(updateQueryString)\n}\n\n\nA to daje https://hadley.shinyapps.io/ms-bookmark-auto - ponieważ adres URL jest teraz automatycznie aktualizowany, można wówczas usunąć przycisk zakładki z interfejsu użytkownika.\n\nDla bardziej złożonych aplikacji, gdzie URL może stać się zbyt długi lub konieczne jest zapisanie stanu plików, można użyć enableBookmarking = \"server\". Ta opcja zapisuje stan aplikacji w pliku .rds na serwerze, generując krótki i jednoznaczny URL.\n\nKodshinyApp(ui, server, enableBookmarking = \"server\")\n\n\nJeśli to zrobisz, zobaczysz, że przycisk zakładki generuje adresy URL takie jak:\n\nhttp://127.0.0.1:4087/?_state_id_=0d645f1b28f05c97\nhttp://127.0.0.1:4087/?_state_id_=87b56383d8a1062c\nhttp://127.0.0.1:4087/?_state_id_=c8b0291ba622b69c\n\nKtóre są sparowane z pasującymi katalogami w katalogu roboczym:\n\nshiny_bookmarks/0d645f1b28f05c97\nshiny_bookmarks/87b56383d8a1062c\nshiny_bookmarks/c8b0291ba622b69c\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nGłówną wadą zakładek serwerowych jest to, że wymagają one zapisywania plików na serwerze i nie jest oczywiste, jak długo muszą one być przechowywane. Jeśli dodajesz do zakładek złożone stany i nigdy nie usuwasz tych plików, twoja aplikacja będzie z czasem zajmować coraz więcej miejsca na dysku. Jeśli usuniesz pliki, niektóre stare zakładki przestaną działać.\n\n\n\nAutomatyczne zakładkowanie opiera się na grafie reaktywnym. Inicjuje ono wejścia zapisanymi wartościami, a następnie odtwarza wszystkie wyrażenia i wyjścia reaktywne, co skutkuje wygenerowaniem tej samej aplikacji, którą widzisz, o ile graf reaktywny twojej aplikacji jest prosty. Poniżej pokrótce omawiam niektóre przypadki, które wymagają dodatkowej uwagi:\n\nJeśli twoja aplikacja używa liczb losowych, wyniki mogą być różne, nawet jeśli wszystkie wejścia są takie same. Jeśli naprawdę ważne jest, aby zawsze generować te same liczby, musisz zastanowić się, jak uczynić swój proces losowy powtarzalnym. Najłatwiejszym sposobem jest użycie funkcji repeatable().\nJeśli masz zakładki i chcesz “zakładkować” oraz przywracać aktywną zakładkę, upewnij się, że dostarczasz id w twoim wywołaniu funkcji tabsetPanel().\nJeśli istnieją wejścia, które nie powinny być “zakładkowane”, np. zawierają prywatne informacje, które nie powinny być udostępniane, dołącz wywołanie funkcji setBookmarkExclude() gdzieś w funkcji serwera. Na przykład, setBookmarkExclude(c(\"secret1\", \"secret2\")) zapewni, że wejścia secret1 i secret2 nie będą zakładkowane.\nJeśli ręcznie zarządzasz stanem reaktywnym w swoim własnym obiekcie reactiveValues(), będziesz musiał użyć funkcji zwrotnych onBookmark() i onRestore(), aby ręcznie zapisać i załadować dodatkowy stan.\n\nTidy evaluation jest kluczową koncepcją przy programowaniu z tidyverse w aplikacjach Shiny, która umożliwia płynniejszą eksplorację danych, ale stwarza pewne wyzwanie przy odnoszeniu się pośrednio do zmiennych, co utrudnia programowanie. W tym rozdziale przybliżymy, jak osadzać funkcje z ggplot2 i dplyr w aplikacji Shiny1.\n1 Techniki te są szerzej opisane w Using ggplot2 in packages i Programming with dplyr.\nRozdział dotyczący tidy evaluation w kontekście tworzenia aplikacji Shiny z użyciem bibliotek tidyverse wprowadza do problematyki programowania z oceną zmiennych (tidy evaluation), która jest kluczowa przy interaktywnej eksploracji danych. Jednakże, ocena taka wprowadza trudności w pośrednim odwoływaniu się do zmiennych, co może utrudnić programowanie. Przykład zaprezentowany w sekcji “Motywacja” ma na celu ilustrowanie, jak można stworzyć aplikację Shiny, która umożliwia filtrowanie danych na podstawie wartości numerycznych przekraczających określony próg, wybranych przez użytkownika.\n\nZałóżmy, że chcemy stworzyć aplikację Shiny, która pozwala użytkownikowi filtrować dane dotyczące diamentów (używając wbudowanego zbioru danych diamonds z pakietu ggplot2) w celu wyświetlenia tych, które mają wartość większą niż określony próg dla wybranej zmiennej numerycznej, np. carat, depth, price itd.\n\nKodlibrary(shiny)\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(ggplot2)\n\nnum_vars &lt;- c(\"carat\", \"depth\", \"table\", \"price\", \"x\", \"y\", \"z\")\nui &lt;- fluidPage(\n  selectInput(\"var\", \"Variable\", choices = num_vars),\n  numericInput(\"min\", \"Minimum\", value = 1),\n  tableOutput(\"output\")\n)\nserver &lt;- function(input, output, session) {\n  data &lt;- reactive(diamonds %&gt;% filter(input$var &gt; input$min))\n  output$output &lt;- renderTable(head(data()))\n}\n\n\nW tej aplikacji użytkownik ma możliwość wyboru zmiennej z zestawu num_vars i ustawienia minimalnej wartości dla tej zmiennej. Po wciśnięciu przycisku “Filtruj”, aplikacja filtruje dane i wyświetla pierwsze 6 wierszy spełniających kryteria filtracji.\n\n\n\n\n\nRys. 1\n\n\nTo podejście, w którym próbowano użyć input$var &gt; input$min bezpośrednio w funkcji filter(), nie działa poprawnie z powodu pośredniego odwoływania się do zmiennej (patrz Rys. 1). W takim przypadku dplyr interpretuje input$var jako stałą wartość (nazwę zmiennej w postaci tekstowej), a nie jako kolumnę w ramce danych. Aby to naprawić, używamy tzw maskowania danych2 .data[[input$var]] &gt; input$min, co pozwala na dynamiczne odwołanie się do kolumny ramki danych określonej przez zmienną wybraną przez użytkownika.\n2 o czym więcej w następnym akapicie\nKodlibrary(shiny)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nnum_vars &lt;- c(\"carat\", \"depth\", \"table\", \"price\", \"x\", \"y\", \"z\")\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Filtrowanie danych diamentów\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"var\", \"Zmienna\", choices = num_vars),\n      numericInput(\"min\", \"Minimalna wartość\", value = 1),\n      actionButton(\"goButton\", \"Filtruj\")\n    ),\n    mainPanel(\n      tableOutput(\"output\")\n    )\n  )\n)\n\n# serwer\nserver &lt;- function(input, output, session) {\n  filteredData &lt;- eventReactive(input$goButton, {\n    req(input$var) # Wymagane, aby zmienna była wybrana\n    diamonds %&gt;%\n      filter(.data[[input$var]] &gt; input$min)\n  })\n  \n  output$output &lt;- renderTable({\n    filteredData() %&gt;% head() # Wyświetla pierwsze 6 wierszy przefiltrowanych danych\n  })\n}\n\n# wywołanie aplikacji\nshinyApp(ui = ui, server = server)\n\n\n\nCzęść dotycząca maskowania danych (ang. data-masking) w kontekście tidy evaluation odnosi się do mechanizmu używanego w funkcjach tidyverse, takich jak dplyr i ggplot2, który umożliwia bezpośrednie odwoływanie się do zmiennych ramki danych bez konieczności używania dodatkowej składni, jak $ czy [[ ]]. Dzięki temu podejściu, praca z danymi staje się bardziej intuicyjna i wygodna podczas interaktywnej eksploracji danych. Maskowanie danych pozwala na odwoływanie się do zmiennych znajdujących się bezpośrednio w ramce danych jak gdyby były one zmiennymi dostępnymi w bieżącym środowisku kodu. Funkcje wykorzystujące maskowanie danych “widzą” nazwy kolumn jako zmiennych, co ułatwia ich użycie w wyrażeniach bez konieczności jawnej ich ekstrakcji.\nMaskowanie danych jest stosowane w wielu funkcjach dplyr, takich jak arrange(), filter(), group_by(), mutate(), i summarise(), a także w funkcji aes() z pakietu ggplot2. Dzięki temu, kiedy korzystasz z tych funkcji, możesz odwoływać się do kolumn w ramce danych bezpośrednio, używając ich nazw, jakby były one zmiennymi w przestrzeni roboczej.\n\n\nKodlibrary(dplyr)\n\n# Przykład użycia funkcji filter() z maskowaniem danych\ndata &lt;- mtcars %&gt;% filter(mpg &gt; 20, cyl == 4)\n\n# Tutaj mpg i cyl są traktowane jak zwykłe zmienne, mimo że są kolumnami w mtcars\n\n\nW tym przykładzie, mpg i cyl są “maskowane” przez funkcję filter(), co oznacza, że możemy używać ich nazw bezpośrednio, jak gdyby były one zmiennymi w aktualnym środowisku.\n\n\nKodlibrary(ggplot2)\n\n# Przykład użycia aes() z maskowaniem danych\nggplot(mtcars, aes(x = mpg, y = disp)) + geom_point()\n\n# Podobnie, mpg i disp są traktowane jak zmienne\n\n\nW przykładzie z ggplot2, aes() również wykorzystuje maskowanie danych, pozwalając na bezpośrednie odwoływanie się do nazw kolumn w ramce danych mtcars.\n\nW przypadku, gdy potrzebujemy odwołać się do kolumny na podstawie wartości zawartej w zmiennej (np. wybranej przez użytkownika w aplikacji Shiny), musimy wykorzystać mechanizm tidy evaluation. Dla przykładu, jeśli chcemy filtrować dane na podstawie zmiennej wybranej dynamicznie, możemy użyć specjalnej składni .data[[nazwa_zmiennej]]:\n\nKodnazwa_zmiennej &lt;- \"mpg\"\ndata_filtr &lt;- mtcars %&gt;% filter(.data[[nazwa_zmiennej]] &gt; 20)\n\n\nW tym przypadku, .data jest specjalnym obiektem pozwalającym na bezpieczne odwoływanie się do kolumn ramki danych wewnątrz funkcji tidyverse, które używają maskowania danych, zapewniając jednocześnie elastyczność wymaganą przy programowaniu dynamicznym, takim jak w aplikacjach Shiny.\nTak mógłby wyglądać przykład wykorzystania dynamicznego maskowania danych w rysowaniu wykresu z pakietem ggplot2:\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny wykres ggplot2 z maskowaniem danych w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"xvar\", \"Zmienna osi X:\", choices = names(mtcars)),\n      selectInput(\"yvar\", \"Zmienna osi Y:\", choices = names(mtcars)),\n      width = 4\n    ),\n    mainPanel(\n      plotOutput(\"plot\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    # Dynamicznie odwołujemy się do zmiennych przy pomocy .data[[]]\n    ggplot(mtcars, aes(x = .data[[input$xvar]], y = .data[[input$yvar]])) +\n      geom_point() +\n      theme_minimal() +\n      labs(x = input$xvar, y = input$yvar, title = paste(\"Wykres\", input$xvar, \"vs\", input$yvar))\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nKluczowe punkty kodu:\n\nUżycie .data[[ ]] w aes() - aby prawidłowo zaimplementować maskowanie danych, używamy .data[[input$xvar]] i .data[[input$yvar]] w funkcji aes() z ggplot2. Pozwala to na dynamiczne odwołanie się do zmiennych w ramce danych na podstawie wyboru użytkownika, zachowując przy tym zgodność z konwencją tidy evaluation.\nBezpośrednie odwołanie do zmiennych - kod korzysta bezpośrednio z nazw zmiennych przechowywanych w input$xvar i input$yvar bez konieczności przekształcania ich do postaci tekstowej, co jest właściwym sposobem wykorzystania maskowania danych w kontekście tidy evaluation.\n\nCzęść ta dotyczy danych dostarczonych przez użytkownika w kontekście maskowania danych w aplikacjach Shiny i podkreśla wyzwania związane z bezpiecznym i skutecznym zarządzaniem danymi zewnętrznymi. Przy pracy z danymi dostarczonymi przez użytkownika, istnieje ryzyko wystąpienia nieoczekiwanych problemów, takich jak: konflikty nazw, “wstrzyknięcie” złośliwego kodu i zużycie zasobów.\n\nZałóżmy, że tworzymy aplikację Shiny, która pozwala użytkownikowi na przesłanie własnego pliku danych w formacie csv, a następnie wykonanie filtracji na podstawie wybranej kolumny i wartości progu.\n\nKodlibrary(shiny)\nlibrary(dplyr)\nlibrary(readr)\n\nui &lt;- fluidPage(\n  titlePanel(\"Filtrowanie danych użytkownika\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"fileUpload\", \"Wybierz plik CSV:\"),\n      selectInput(\"column\", \"Wybierz kolumnę:\", choices = NULL),\n      numericInput(\"threshold\", \"Próg wartości:\", 0),\n      actionButton(\"filterBtn\", \"Filtruj\")\n    ),\n    mainPanel(\n      tableOutput(\"filteredData\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  uploadedData &lt;- reactive({\n    req(input$fileUpload)\n    read_csv(input$fileUpload$datapath)\n  })\n  \n  observe({\n    updateSelectInput(session, \"column\", choices = names(uploadedData()))\n  })\n  \n  filteredData &lt;- eventReactive(input$filterBtn, {\n    req(input$column, input$threshold)\n    uploadedData() %&gt;%\n      filter(.data[[input$column]] &gt; input$threshold)\n  })\n  \n  output$filteredData &lt;- renderTable({\n    filteredData()\n  })\n}\n\nshinyApp(ui, server)\n\n\nPotencjalne zagrożenia:\n\nKonflikty nazw - jeśli przesłany plik zawiera kolumnę input, może to zakłócić działanie aplikacji, ponieważ input jest zmienną specjalną w Shiny, używaną do przechowywania danych wejściowych od użytkownika. Rozwiązaniem może być użycie .data[[input$column]] zamiast bezpośredniego odwołania się do input$column, co już zastosowaliśmy w kodzie.\n“Wstrzyknięcie” złośliwego kodu - przyjmowanie dowolnych danych od użytkownika i bezpośrednie ich przetwarzanie, szczególnie przy użyciu funkcji takich jak eval() (której tutaj akurat nie używamy), może prowadzić do ryzyka wstrzyknięcia złośliwego kodu. Ważne jest, aby stosować techniki sanacji i weryfikacji danych wejściowych.\nZużycie zasobów - przesyłanie dużych plików danych może obciążyć serwer. Możliwym rozwiązaniem jest ograniczenie maksymalnego rozmiaru przesyłanego pliku lub stosowanie paginacji wyników, aby nie przetwarzać całego zbioru danych naraz.\n\nWykorzystanie funkcji typu filter() z dplyr w aplikacji Shiny jest popularnym wyborem ze względu na jej czytelność i integrację z innymi funkcjami tidyverse, co ułatwia tworzenie złożonych operacji na danych. Jednak w niektórych przypadkach, szczególnie gdy potrzebujemy wykonać proste operacje filtracji, równoważny kod w podstawowym R może wydawać się bardziej bezpośredni i mniej obciążający. Przykładowo\n\nKoddf[df[[input$var]] &gt; input$min, ]\n\n\ndemonstruje, jak można osiągnąć filtrację bezpośrednio w podstawowym R, używając indeksowania. Taka metoda może być bardziej zrozumiała dla osób niezaznajomionych z dplyr lub tidyverse.\nCo warto rozważyć przy wyborze podejścia:\n\nProstota vs elastyczność - podstawowy R może być bardziej intuicyjny dla prostych operacji filtracji, ale dplyr oferuje większą elastyczność i czytelność, szczególnie przy bardziej skomplikowanych operacjach.\nZachowanie typu danych - w podstawowym R, operacje na ramkach danych z jedną kolumną mogą domyślnie zwrócić wektor, chyba że użyjemy parametru drop = FALSE. Jest to ważne do rozważenia, gdy oczekujemy, że wynikiem zawsze będzie ramka danych.\nObsługa brakujących wartości - w podstawowym R konieczne może być użycie funkcji takich jak which() do wykluczenia brakujących wartości przed filtracją, podczas gdy dplyr radzi sobie z nimi w bardziej przejrzysty sposób.\nFiltrowanie grupowe - dplyr znacznie ułatwia filtrowanie grupowe, co może być trudniejsze do osiągnięcia w podstawowym R bez dodatkowego kodu.\n\n\nWybór między użyciem dplyr a podstawowym R w aplikacjach Shiny powinien być podyktowany konkretnymi potrzebami projektu oraz preferencjami programisty. dplyr oferuje spójną i wydajną składnię, która może ułatwić pisanie i utrzymanie kodu, szczególnie w przypadku bardziej złożonych operacji na danych. Z drugiej strony, dla prostych zadań filtracji, bezpośrednie użycie funkcji podstawowego R może być wystarczające i nieco bardziej bezpośrednie. Ważne jest, aby pamiętać o specyficznych cechach każdego podejścia i wybrać to, które najlepiej pasuje do wymagań aplikacji i jest zgodne z doświadczeniem programisty. Ostatecznie, zarówno dplyr, jak i podstawowe funkcje R mają swoje miejsce w ekosystemie R, a zrozumienie ich mocnych i słabych stron może pomóc w tworzeniu skutecznych i wydajnych aplikacji Shiny.\n\nTidy-selection to mechanizm selekcji zmiennych w tidyverse, który zapewnia spójne i elastyczne podejście do wyboru kolumn w ramach manipulacji danymi. Jest szczególnie przydatny w aplikacjach Shiny, gdzie użytkownicy często mają możliwość dynamicznego wyboru zmiennych do analizy lub wizualizacji. W kontekście budowania aplikacji Shiny, tidy-selection umożliwia tworzenie bardziej interaktywnych i elastycznych interfejsów użytkownika, które mogą dostosować się do różnych zestawów danych i preferencji użytkowników.\nWykorzystanie funkcji takich jak select(), filter(), mutate() i summarise() z pakietu dplyr w aplikacjach Shiny często wymaga dynamicznego odwoływania się do zmiennych. Tidy-selection wprowadza funkcje pomocnicze takie jak all_of() i any_of(), które pozwalają na bezpieczne i skuteczne odwoływanie się do zmiennych, nawet jeśli są one wybrane przez użytkownika w czasie działania aplikacji.\n\nZałóżmy, że chcemy stworzyć aplikację Shiny, która pozwala użytkownikowi na wybór jednej lub więcej zmiennych z zestawu danych mtcars, a następnie wyświetlenie tylko tych wierszy, które spełniają kryteria dla wybranych zmiennych.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny wykres rozrzutu\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"xvar\", \"Oś X\", choices = names(mtcars)),\n      selectInput(\"yvar\", \"Oś Y\", choices = names(mtcars)),\n      actionButton(\"btn\", \"Generuj wykres\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  observeEvent(input$btn, {\n    output$plot &lt;- renderPlot({\n      ggplot(mtcars, aes_string(x = input$xvar, y = input$yvar)) +\n        geom_point() +\n        labs(x = input$xvar, y = input$yvar)\n    })\n  })\n}\n\nshinyApp(ui, server)\n\n\nW tym przykładzie selectInput() pozwala użytkownikowi na wybór jednej lub więcej zmiennych z mtcars. Użytkownik może również określić minimalną wartość, a po kliknięciu przycisku “Filtruj”, aplikacja wyświetli tylko te wiersze, które spełniają kryterium minimalnej wartości dla wybranych zmiennych. Użycie any_of() w funkcji filter() z pakietu dplyr zapewnia, że filtracja będzie dotyczyć tylko tych kolumn, które faktycznie zostały wybrane przez użytkownika, ignorując te, które nie istnieją, co zapobiega potencjalnym błędom wykonania.\n\n\nany_of() - używane, gdy chcemy zastosować operację do wszystkich istniejących zmiennych z listy podanej przez użytkownika, ignorując te, które nie istnieją. Jest to bezpieczne podejście, gdy lista zmiennych może zawierać nazwy, które nie występują w danych.\nall_of() - używane, gdy oczekujemy, że wszystkie zmienne z listy będą istnieć w danych. Jeśli jakakolwiek zmienna z listy nie istnieje, dplyr zgłosi błąd. Jest to przydatne, gdy chcemy mieć pewność, że operacja zostanie zastosowana do dokładnie określonego zestawu zmiennych.\n\nWybór między any_of() a all_of() zależy od specyfiki zadania i danych, z którymi pracujemy, oraz od tego, czy chcemy unikać błędów przy brakujących zmiennych, czy też wymagamy, aby wszystkie zmienne były obecne.",
    "crumbs": [
      "Wykład 7"
    ]
  },
  {
    "objectID": "wyk7.html#bookmarking",
    "href": "wyk7.html#bookmarking",
    "title": "Wykład 7",
    "section": "",
    "text": "Możliwość zapisywania i udostępniania stanu aplikacji Shiny poprzez zakładki (ang. bookmarking) znacząco rozszerza funkcjonalność tych aplikacji, czyniąc je bardziej interaktywnymi i przyjaznymi dla użytkownika. Poniżej znajduje się opis sposobów realizacji tej funkcjonalności, wraz z przykładami użycia.\n\nDomyślnie aplikacje Shiny nie umożliwiają łatwego powrotu do wcześniej uzyskanego stanu ani udostępniania go innym. Aby to zmienić i umożliwić zapisywanie stanu aplikacji w URL, można wykorzystać funkcjonalność zakładek. Poniżej przedstawiono kroki niezbędne do osiągnięcia tego celu na przykładzie aplikacji generującej figury Lissajous:\n\n\nDodanie przycisku zakładki - w interfejsie użytkownika dodajemy bookmarkButton(), który umożliwia generowanie URL z zapisanym stanem aplikacji.\n\nKodui &lt;- function(request) {\n  fluidPage(\n    sidebarLayout(\n      sidebarPanel(\n        sliderInput(\"omega\", \"omega\", value = 1, min = -2, max = 2, step = 0.01),\n        sliderInput(\"delta\", \"delta\", value = 1, min = 0, max = 2, step = 0.01),\n        sliderInput(\"damping\", \"damping\", value = 1, min = 0.9, max = 1, step = 0.001),\n        numericInput(\"length\", \"length\", value = 100),\n        bookmarkButton()\n      ),\n      mainPanel(plotOutput(\"fig\"))\n    )\n  )\n}\n\n\n\nTransformacja UI w funkcję - aby umożliwić dynamiczne dostosowywanie interfejsu w zależności od zapisanych wartości, UI aplikacji musi być zdefiniowane jako funkcja.\n\nWłączenie zakładek - w wywołaniu shinyApp() dodajemy enableBookmarking = \"url\", aby umożliwić zapisywanie stanu aplikacji w URL.\n\nKodshinyApp(ui, server, enableBookmarking = \"url\")\n\n\n\n\n\n\n\n\n\n\nAdnotacja\n\n\n\nMożna ją wypróbować na stronie https://hadley.shinyapps.io/ms-bookmark-url. Jeśli pobawisz się aplikacją i dodasz do zakładek kilka interesujących stanów, zobaczysz, że wygenerowane adresy URL wyglądają mniej więcej tak:\n\nhttps://hadley.shinyapps.io/ms-bookmark-url/?inputs&damping=1&delta=1&length=100&omega=1\nhttps://hadley.shinyapps.io/ms-bookmark-url/?inputs&damping=0.966&delta=1.25&length=100&omega=-0.54\nhttps://hadley.shinyapps.io/ms-bookmark-url/?inputs&damping=0.997&delta=1.37&length=500&omega=-0.9\n\nAby zrozumieć, co się dzieje, weźmy pierwszy adres URL i podzielmy go na części:\n\nhttp:// to “protokół” używany do komunikacji z aplikacją. Zawsze będzie to http lub https.\nhadley.shinyapps.io/ms-bookmark-url to lokalizacja aplikacji.\n\nWszystko po ? jest “parametrem”. Każdy parametr jest oddzielony znakiem &, a jeśli go rozdzielisz, możesz zobaczyć wartości każdego wejścia w aplikacji:\n\ndamping=1\ndelta=1\nlength=100\nomega=1\n\nTak więc “wygenerowanie zakładki” oznacza zapisanie aktualnych wartości danych wejściowych w parametrach adresu URL. Jeśli zrobisz to lokalnie, adresy URL będą wyglądać nieco inaczej:\n\nhttp://127.0.0.1:4087/?inputs&damping=1&delta=1&length=100&omega=1\nhttp://127.0.0.1:4087/?inputs&damping=0.966&delta=1.25&length=100&omega=-0.54\nhttp://127.0.0.1:4087/?inputs&damping=0.997&delta=1.37&length=500&omega=-0.9\n\nWiększość elementów jest taka sama, z wyjątkiem tego, że zamiast hadley.shinyapps.io/ms-bookmark-url jest coś w rodzaju 127.0.0.1:4087. 127.0.0.1 to specjalny adres, który zawsze wskazuje na twój własny komputer, a 4087 to losowo przypisany port. Zwykle różne aplikacje otrzymują różne ścieżki lub adresy IP, ale nie jest to możliwe, gdy hostujesz wiele aplikacji na własnym komputerze.\n\n\n\nMożna także zautomatyzować proces aktualizacji URL bez konieczności klikania przycisku, używając odpowiednich funkcji w server. Poniżej znajduje się przykład, jak to zrealizować:\n\nKodserver &lt;- function(input, output, session) {\n  # Kod generujący treść aplikacji...\n  \n  observe({\n    reactiveValuesToList(input)\n    session$doBookmark()\n  })\n  onBookmarked(updateQueryString)\n}\n\n\nA to daje https://hadley.shinyapps.io/ms-bookmark-auto - ponieważ adres URL jest teraz automatycznie aktualizowany, można wówczas usunąć przycisk zakładki z interfejsu użytkownika.\n\nDla bardziej złożonych aplikacji, gdzie URL może stać się zbyt długi lub konieczne jest zapisanie stanu plików, można użyć enableBookmarking = \"server\". Ta opcja zapisuje stan aplikacji w pliku .rds na serwerze, generując krótki i jednoznaczny URL.\n\nKodshinyApp(ui, server, enableBookmarking = \"server\")\n\n\nJeśli to zrobisz, zobaczysz, że przycisk zakładki generuje adresy URL takie jak:\n\nhttp://127.0.0.1:4087/?_state_id_=0d645f1b28f05c97\nhttp://127.0.0.1:4087/?_state_id_=87b56383d8a1062c\nhttp://127.0.0.1:4087/?_state_id_=c8b0291ba622b69c\n\nKtóre są sparowane z pasującymi katalogami w katalogu roboczym:\n\nshiny_bookmarks/0d645f1b28f05c97\nshiny_bookmarks/87b56383d8a1062c\nshiny_bookmarks/c8b0291ba622b69c\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nGłówną wadą zakładek serwerowych jest to, że wymagają one zapisywania plików na serwerze i nie jest oczywiste, jak długo muszą one być przechowywane. Jeśli dodajesz do zakładek złożone stany i nigdy nie usuwasz tych plików, twoja aplikacja będzie z czasem zajmować coraz więcej miejsca na dysku. Jeśli usuniesz pliki, niektóre stare zakładki przestaną działać.\n\n\n\nAutomatyczne zakładkowanie opiera się na grafie reaktywnym. Inicjuje ono wejścia zapisanymi wartościami, a następnie odtwarza wszystkie wyrażenia i wyjścia reaktywne, co skutkuje wygenerowaniem tej samej aplikacji, którą widzisz, o ile graf reaktywny twojej aplikacji jest prosty. Poniżej pokrótce omawiam niektóre przypadki, które wymagają dodatkowej uwagi:\n\nJeśli twoja aplikacja używa liczb losowych, wyniki mogą być różne, nawet jeśli wszystkie wejścia są takie same. Jeśli naprawdę ważne jest, aby zawsze generować te same liczby, musisz zastanowić się, jak uczynić swój proces losowy powtarzalnym. Najłatwiejszym sposobem jest użycie funkcji repeatable().\nJeśli masz zakładki i chcesz “zakładkować” oraz przywracać aktywną zakładkę, upewnij się, że dostarczasz id w twoim wywołaniu funkcji tabsetPanel().\nJeśli istnieją wejścia, które nie powinny być “zakładkowane”, np. zawierają prywatne informacje, które nie powinny być udostępniane, dołącz wywołanie funkcji setBookmarkExclude() gdzieś w funkcji serwera. Na przykład, setBookmarkExclude(c(\"secret1\", \"secret2\")) zapewni, że wejścia secret1 i secret2 nie będą zakładkowane.\nJeśli ręcznie zarządzasz stanem reaktywnym w swoim własnym obiekcie reactiveValues(), będziesz musiał użyć funkcji zwrotnych onBookmark() i onRestore(), aby ręcznie zapisać i załadować dodatkowy stan.",
    "crumbs": [
      "Wykład 7"
    ]
  },
  {
    "objectID": "wyk7.html#tidy-evaluation",
    "href": "wyk7.html#tidy-evaluation",
    "title": "Wykład 7",
    "section": "",
    "text": "Tidy evaluation jest kluczową koncepcją przy programowaniu z tidyverse w aplikacjach Shiny, która umożliwia płynniejszą eksplorację danych, ale stwarza pewne wyzwanie przy odnoszeniu się pośrednio do zmiennych, co utrudnia programowanie. W tym rozdziale przybliżymy, jak osadzać funkcje z ggplot2 i dplyr w aplikacji Shiny1.\n1 Techniki te są szerzej opisane w Using ggplot2 in packages i Programming with dplyr.\nRozdział dotyczący tidy evaluation w kontekście tworzenia aplikacji Shiny z użyciem bibliotek tidyverse wprowadza do problematyki programowania z oceną zmiennych (tidy evaluation), która jest kluczowa przy interaktywnej eksploracji danych. Jednakże, ocena taka wprowadza trudności w pośrednim odwoływaniu się do zmiennych, co może utrudnić programowanie. Przykład zaprezentowany w sekcji “Motywacja” ma na celu ilustrowanie, jak można stworzyć aplikację Shiny, która umożliwia filtrowanie danych na podstawie wartości numerycznych przekraczających określony próg, wybranych przez użytkownika.\n\nZałóżmy, że chcemy stworzyć aplikację Shiny, która pozwala użytkownikowi filtrować dane dotyczące diamentów (używając wbudowanego zbioru danych diamonds z pakietu ggplot2) w celu wyświetlenia tych, które mają wartość większą niż określony próg dla wybranej zmiennej numerycznej, np. carat, depth, price itd.\n\nKodlibrary(shiny)\nlibrary(dplyr, warn.conflicts = FALSE)\nlibrary(ggplot2)\n\nnum_vars &lt;- c(\"carat\", \"depth\", \"table\", \"price\", \"x\", \"y\", \"z\")\nui &lt;- fluidPage(\n  selectInput(\"var\", \"Variable\", choices = num_vars),\n  numericInput(\"min\", \"Minimum\", value = 1),\n  tableOutput(\"output\")\n)\nserver &lt;- function(input, output, session) {\n  data &lt;- reactive(diamonds %&gt;% filter(input$var &gt; input$min))\n  output$output &lt;- renderTable(head(data()))\n}\n\n\nW tej aplikacji użytkownik ma możliwość wyboru zmiennej z zestawu num_vars i ustawienia minimalnej wartości dla tej zmiennej. Po wciśnięciu przycisku “Filtruj”, aplikacja filtruje dane i wyświetla pierwsze 6 wierszy spełniających kryteria filtracji.\n\n\n\n\n\nRys. 1\n\n\nTo podejście, w którym próbowano użyć input$var &gt; input$min bezpośrednio w funkcji filter(), nie działa poprawnie z powodu pośredniego odwoływania się do zmiennej (patrz Rys. 1). W takim przypadku dplyr interpretuje input$var jako stałą wartość (nazwę zmiennej w postaci tekstowej), a nie jako kolumnę w ramce danych. Aby to naprawić, używamy tzw maskowania danych2 .data[[input$var]] &gt; input$min, co pozwala na dynamiczne odwołanie się do kolumny ramki danych określonej przez zmienną wybraną przez użytkownika.\n2 o czym więcej w następnym akapicie\nKodlibrary(shiny)\nlibrary(dplyr)\nlibrary(ggplot2)\n\nnum_vars &lt;- c(\"carat\", \"depth\", \"table\", \"price\", \"x\", \"y\", \"z\")\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Filtrowanie danych diamentów\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"var\", \"Zmienna\", choices = num_vars),\n      numericInput(\"min\", \"Minimalna wartość\", value = 1),\n      actionButton(\"goButton\", \"Filtruj\")\n    ),\n    mainPanel(\n      tableOutput(\"output\")\n    )\n  )\n)\n\n# serwer\nserver &lt;- function(input, output, session) {\n  filteredData &lt;- eventReactive(input$goButton, {\n    req(input$var) # Wymagane, aby zmienna była wybrana\n    diamonds %&gt;%\n      filter(.data[[input$var]] &gt; input$min)\n  })\n  \n  output$output &lt;- renderTable({\n    filteredData() %&gt;% head() # Wyświetla pierwsze 6 wierszy przefiltrowanych danych\n  })\n}\n\n# wywołanie aplikacji\nshinyApp(ui = ui, server = server)\n\n\n\nCzęść dotycząca maskowania danych (ang. data-masking) w kontekście tidy evaluation odnosi się do mechanizmu używanego w funkcjach tidyverse, takich jak dplyr i ggplot2, który umożliwia bezpośrednie odwoływanie się do zmiennych ramki danych bez konieczności używania dodatkowej składni, jak $ czy [[ ]]. Dzięki temu podejściu, praca z danymi staje się bardziej intuicyjna i wygodna podczas interaktywnej eksploracji danych. Maskowanie danych pozwala na odwoływanie się do zmiennych znajdujących się bezpośrednio w ramce danych jak gdyby były one zmiennymi dostępnymi w bieżącym środowisku kodu. Funkcje wykorzystujące maskowanie danych “widzą” nazwy kolumn jako zmiennych, co ułatwia ich użycie w wyrażeniach bez konieczności jawnej ich ekstrakcji.\nMaskowanie danych jest stosowane w wielu funkcjach dplyr, takich jak arrange(), filter(), group_by(), mutate(), i summarise(), a także w funkcji aes() z pakietu ggplot2. Dzięki temu, kiedy korzystasz z tych funkcji, możesz odwoływać się do kolumn w ramce danych bezpośrednio, używając ich nazw, jakby były one zmiennymi w przestrzeni roboczej.\n\n\nKodlibrary(dplyr)\n\n# Przykład użycia funkcji filter() z maskowaniem danych\ndata &lt;- mtcars %&gt;% filter(mpg &gt; 20, cyl == 4)\n\n# Tutaj mpg i cyl są traktowane jak zwykłe zmienne, mimo że są kolumnami w mtcars\n\n\nW tym przykładzie, mpg i cyl są “maskowane” przez funkcję filter(), co oznacza, że możemy używać ich nazw bezpośrednio, jak gdyby były one zmiennymi w aktualnym środowisku.\n\n\nKodlibrary(ggplot2)\n\n# Przykład użycia aes() z maskowaniem danych\nggplot(mtcars, aes(x = mpg, y = disp)) + geom_point()\n\n# Podobnie, mpg i disp są traktowane jak zmienne\n\n\nW przykładzie z ggplot2, aes() również wykorzystuje maskowanie danych, pozwalając na bezpośrednie odwoływanie się do nazw kolumn w ramce danych mtcars.\n\nW przypadku, gdy potrzebujemy odwołać się do kolumny na podstawie wartości zawartej w zmiennej (np. wybranej przez użytkownika w aplikacji Shiny), musimy wykorzystać mechanizm tidy evaluation. Dla przykładu, jeśli chcemy filtrować dane na podstawie zmiennej wybranej dynamicznie, możemy użyć specjalnej składni .data[[nazwa_zmiennej]]:\n\nKodnazwa_zmiennej &lt;- \"mpg\"\ndata_filtr &lt;- mtcars %&gt;% filter(.data[[nazwa_zmiennej]] &gt; 20)\n\n\nW tym przypadku, .data jest specjalnym obiektem pozwalającym na bezpieczne odwoływanie się do kolumn ramki danych wewnątrz funkcji tidyverse, które używają maskowania danych, zapewniając jednocześnie elastyczność wymaganą przy programowaniu dynamicznym, takim jak w aplikacjach Shiny.\nTak mógłby wyglądać przykład wykorzystania dynamicznego maskowania danych w rysowaniu wykresu z pakietem ggplot2:\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny wykres ggplot2 z maskowaniem danych w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"xvar\", \"Zmienna osi X:\", choices = names(mtcars)),\n      selectInput(\"yvar\", \"Zmienna osi Y:\", choices = names(mtcars)),\n      width = 4\n    ),\n    mainPanel(\n      plotOutput(\"plot\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    # Dynamicznie odwołujemy się do zmiennych przy pomocy .data[[]]\n    ggplot(mtcars, aes(x = .data[[input$xvar]], y = .data[[input$yvar]])) +\n      geom_point() +\n      theme_minimal() +\n      labs(x = input$xvar, y = input$yvar, title = paste(\"Wykres\", input$xvar, \"vs\", input$yvar))\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nKluczowe punkty kodu:\n\nUżycie .data[[ ]] w aes() - aby prawidłowo zaimplementować maskowanie danych, używamy .data[[input$xvar]] i .data[[input$yvar]] w funkcji aes() z ggplot2. Pozwala to na dynamiczne odwołanie się do zmiennych w ramce danych na podstawie wyboru użytkownika, zachowując przy tym zgodność z konwencją tidy evaluation.\nBezpośrednie odwołanie do zmiennych - kod korzysta bezpośrednio z nazw zmiennych przechowywanych w input$xvar i input$yvar bez konieczności przekształcania ich do postaci tekstowej, co jest właściwym sposobem wykorzystania maskowania danych w kontekście tidy evaluation.\n\nCzęść ta dotyczy danych dostarczonych przez użytkownika w kontekście maskowania danych w aplikacjach Shiny i podkreśla wyzwania związane z bezpiecznym i skutecznym zarządzaniem danymi zewnętrznymi. Przy pracy z danymi dostarczonymi przez użytkownika, istnieje ryzyko wystąpienia nieoczekiwanych problemów, takich jak: konflikty nazw, “wstrzyknięcie” złośliwego kodu i zużycie zasobów.\n\nZałóżmy, że tworzymy aplikację Shiny, która pozwala użytkownikowi na przesłanie własnego pliku danych w formacie csv, a następnie wykonanie filtracji na podstawie wybranej kolumny i wartości progu.\n\nKodlibrary(shiny)\nlibrary(dplyr)\nlibrary(readr)\n\nui &lt;- fluidPage(\n  titlePanel(\"Filtrowanie danych użytkownika\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"fileUpload\", \"Wybierz plik CSV:\"),\n      selectInput(\"column\", \"Wybierz kolumnę:\", choices = NULL),\n      numericInput(\"threshold\", \"Próg wartości:\", 0),\n      actionButton(\"filterBtn\", \"Filtruj\")\n    ),\n    mainPanel(\n      tableOutput(\"filteredData\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  uploadedData &lt;- reactive({\n    req(input$fileUpload)\n    read_csv(input$fileUpload$datapath)\n  })\n  \n  observe({\n    updateSelectInput(session, \"column\", choices = names(uploadedData()))\n  })\n  \n  filteredData &lt;- eventReactive(input$filterBtn, {\n    req(input$column, input$threshold)\n    uploadedData() %&gt;%\n      filter(.data[[input$column]] &gt; input$threshold)\n  })\n  \n  output$filteredData &lt;- renderTable({\n    filteredData()\n  })\n}\n\nshinyApp(ui, server)\n\n\nPotencjalne zagrożenia:\n\nKonflikty nazw - jeśli przesłany plik zawiera kolumnę input, może to zakłócić działanie aplikacji, ponieważ input jest zmienną specjalną w Shiny, używaną do przechowywania danych wejściowych od użytkownika. Rozwiązaniem może być użycie .data[[input$column]] zamiast bezpośredniego odwołania się do input$column, co już zastosowaliśmy w kodzie.\n“Wstrzyknięcie” złośliwego kodu - przyjmowanie dowolnych danych od użytkownika i bezpośrednie ich przetwarzanie, szczególnie przy użyciu funkcji takich jak eval() (której tutaj akurat nie używamy), może prowadzić do ryzyka wstrzyknięcia złośliwego kodu. Ważne jest, aby stosować techniki sanacji i weryfikacji danych wejściowych.\nZużycie zasobów - przesyłanie dużych plików danych może obciążyć serwer. Możliwym rozwiązaniem jest ograniczenie maksymalnego rozmiaru przesyłanego pliku lub stosowanie paginacji wyników, aby nie przetwarzać całego zbioru danych naraz.\n\nWykorzystanie funkcji typu filter() z dplyr w aplikacji Shiny jest popularnym wyborem ze względu na jej czytelność i integrację z innymi funkcjami tidyverse, co ułatwia tworzenie złożonych operacji na danych. Jednak w niektórych przypadkach, szczególnie gdy potrzebujemy wykonać proste operacje filtracji, równoważny kod w podstawowym R może wydawać się bardziej bezpośredni i mniej obciążający. Przykładowo\n\nKoddf[df[[input$var]] &gt; input$min, ]\n\n\ndemonstruje, jak można osiągnąć filtrację bezpośrednio w podstawowym R, używając indeksowania. Taka metoda może być bardziej zrozumiała dla osób niezaznajomionych z dplyr lub tidyverse.\nCo warto rozważyć przy wyborze podejścia:\n\nProstota vs elastyczność - podstawowy R może być bardziej intuicyjny dla prostych operacji filtracji, ale dplyr oferuje większą elastyczność i czytelność, szczególnie przy bardziej skomplikowanych operacjach.\nZachowanie typu danych - w podstawowym R, operacje na ramkach danych z jedną kolumną mogą domyślnie zwrócić wektor, chyba że użyjemy parametru drop = FALSE. Jest to ważne do rozważenia, gdy oczekujemy, że wynikiem zawsze będzie ramka danych.\nObsługa brakujących wartości - w podstawowym R konieczne może być użycie funkcji takich jak which() do wykluczenia brakujących wartości przed filtracją, podczas gdy dplyr radzi sobie z nimi w bardziej przejrzysty sposób.\nFiltrowanie grupowe - dplyr znacznie ułatwia filtrowanie grupowe, co może być trudniejsze do osiągnięcia w podstawowym R bez dodatkowego kodu.\n\n\nWybór między użyciem dplyr a podstawowym R w aplikacjach Shiny powinien być podyktowany konkretnymi potrzebami projektu oraz preferencjami programisty. dplyr oferuje spójną i wydajną składnię, która może ułatwić pisanie i utrzymanie kodu, szczególnie w przypadku bardziej złożonych operacji na danych. Z drugiej strony, dla prostych zadań filtracji, bezpośrednie użycie funkcji podstawowego R może być wystarczające i nieco bardziej bezpośrednie. Ważne jest, aby pamiętać o specyficznych cechach każdego podejścia i wybrać to, które najlepiej pasuje do wymagań aplikacji i jest zgodne z doświadczeniem programisty. Ostatecznie, zarówno dplyr, jak i podstawowe funkcje R mają swoje miejsce w ekosystemie R, a zrozumienie ich mocnych i słabych stron może pomóc w tworzeniu skutecznych i wydajnych aplikacji Shiny.\n\nTidy-selection to mechanizm selekcji zmiennych w tidyverse, który zapewnia spójne i elastyczne podejście do wyboru kolumn w ramach manipulacji danymi. Jest szczególnie przydatny w aplikacjach Shiny, gdzie użytkownicy często mają możliwość dynamicznego wyboru zmiennych do analizy lub wizualizacji. W kontekście budowania aplikacji Shiny, tidy-selection umożliwia tworzenie bardziej interaktywnych i elastycznych interfejsów użytkownika, które mogą dostosować się do różnych zestawów danych i preferencji użytkowników.\nWykorzystanie funkcji takich jak select(), filter(), mutate() i summarise() z pakietu dplyr w aplikacjach Shiny często wymaga dynamicznego odwoływania się do zmiennych. Tidy-selection wprowadza funkcje pomocnicze takie jak all_of() i any_of(), które pozwalają na bezpieczne i skuteczne odwoływanie się do zmiennych, nawet jeśli są one wybrane przez użytkownika w czasie działania aplikacji.\n\nZałóżmy, że chcemy stworzyć aplikację Shiny, która pozwala użytkownikowi na wybór jednej lub więcej zmiennych z zestawu danych mtcars, a następnie wyświetlenie tylko tych wierszy, które spełniają kryteria dla wybranych zmiennych.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\nlibrary(dplyr)\n\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny wykres rozrzutu\"),\n  sidebarLayout(\n    sidebarPanel(\n      selectInput(\"xvar\", \"Oś X\", choices = names(mtcars)),\n      selectInput(\"yvar\", \"Oś Y\", choices = names(mtcars)),\n      actionButton(\"btn\", \"Generuj wykres\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\")\n    )\n  )\n)\n\nserver &lt;- function(input, output) {\n  observeEvent(input$btn, {\n    output$plot &lt;- renderPlot({\n      ggplot(mtcars, aes_string(x = input$xvar, y = input$yvar)) +\n        geom_point() +\n        labs(x = input$xvar, y = input$yvar)\n    })\n  })\n}\n\nshinyApp(ui, server)\n\n\nW tym przykładzie selectInput() pozwala użytkownikowi na wybór jednej lub więcej zmiennych z mtcars. Użytkownik może również określić minimalną wartość, a po kliknięciu przycisku “Filtruj”, aplikacja wyświetli tylko te wiersze, które spełniają kryterium minimalnej wartości dla wybranych zmiennych. Użycie any_of() w funkcji filter() z pakietu dplyr zapewnia, że filtracja będzie dotyczyć tylko tych kolumn, które faktycznie zostały wybrane przez użytkownika, ignorując te, które nie istnieją, co zapobiega potencjalnym błędom wykonania.\n\n\nany_of() - używane, gdy chcemy zastosować operację do wszystkich istniejących zmiennych z listy podanej przez użytkownika, ignorując te, które nie istnieją. Jest to bezpieczne podejście, gdy lista zmiennych może zawierać nazwy, które nie występują w danych.\nall_of() - używane, gdy oczekujemy, że wszystkie zmienne z listy będą istnieć w danych. Jeśli jakakolwiek zmienna z listy nie istnieje, dplyr zgłosi błąd. Jest to przydatne, gdy chcemy mieć pewność, że operacja zostanie zastosowana do dokładnie określonego zestawu zmiennych.\n\nWybór między any_of() a all_of() zależy od specyfiki zadania i danych, z którymi pracujemy, oraz od tego, czy chcemy unikać błędów przy brakujących zmiennych, czy też wymagamy, aby wszystkie zmienne były obecne.",
    "crumbs": [
      "Wykład 7"
    ]
  },
  {
    "objectID": "wyk4.html",
    "href": "wyk4.html",
    "title": "Wykład 4",
    "section": "",
    "text": "Shiny oferuje wiele możliwości do tworzenia interaktywnych i estetycznych layoutów dla aplikacji. Można korzystać z różnych funkcji i elementów interfejsu użytkownika, aby dostosować wygląd i układ strony. Poniżej przedstawiam kilka kluczowych możliwości i technik budowy layoutów w Shiny:\n\n\nFluid Grid Layout:\n\n\nfluidPage() to podstawowa funkcja służąca do tworzenia responsywnego układu strony.\nObejmuje różne sekcje takie jak titlePanel, sidebarLayout, mainPanel itp., które pomagają w organizacji i strukturyzacji interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł aplikacji\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Elementy boczne, np. suwaki, przyciski\n    ),\n    mainPanel(\n      # Główna zawartość, np. wykresy, tabele\n    )\n  )\n)\n\n\n\n\nColumn Layout:\n\nMożna używać column() do podziału obszaru głównego na kolumny, co pozwala na bardziej elastyczny układ strony.\nTo przydatne, gdy chcemy umieścić różne elementy obok siebie.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł aplikacji\"),\n  column(\n    width = 4,\n    # Pierwsza kolumna\n  ),\n  column(\n    width = 8,\n    # Druga kolumna\n  )\n)\n\n\n\n\nTabset Panel:\n\n\ntabsetPanel() umożliwia organizację interfejsu za pomocą zakładek.\nKażda zakładka może mieć własny zestaw elementów interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł aplikacji\"),\n  tabsetPanel(\n    tabPanel(\"Zakładka 1\", \n             # Zawartość pierwszej zakładki),\n    tabPanel(\"Zakładka 2\", \n             # Zawartość drugiej zakładki)\n  )\n)\n\n\n\n\nHTML i CSS:\n\nShiny umożliwia wbudowanie kodu HTML i CSS do dostosowywania wyglądu.\nFunkcje takie jak HTML() pozwalają na wstawienie kodu HTML bezpośrednio do interfejsu użytkownika.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł aplikacji\"),\n  HTML(\"&lt;h2&gt;Własny tytuł HTML&lt;/h2&gt;\")\n)\n\n\n\n\nDashboard Layout:\n\nBiblioteka shinydashboard dostarcza narzędzi do tworzenia układów przypominających klasyczne dashboardy.\nObejmuje funkcje takie jak dashboardPage(), dashboardHeader(), dashboardSidebar().\n\n\nKodlibrary(shinydashboard)\n\nui &lt;- dashboardPage(\n  dashboardHeader(title = \"Dashboard Title\"),\n  dashboardSidebar(\n    # Elementy boczne, np. suwaki, przyciski\n  ),\n  dashboardBody(\n    # Główna zawartość, np. wykresy, tabele\n  )\n)",
    "crumbs": [
      "Wykład 4"
    ]
  },
  {
    "objectID": "wyk4.html#instalacja-edytora-shiny",
    "href": "wyk4.html#instalacja-edytora-shiny",
    "title": "Wykład 4",
    "section": "Instalacja edytora Shiny",
    "text": "Instalacja edytora Shiny\nPolecam instalować najnowszą wersję (dystrybucję) pakietu shinyuieditor ze strony Github autora.\n\nKodif (!requireNamespace(\"remotes\", quietly = TRUE))\n    install.packages(\"remotes\")\n\n# Install using the remotes package\nremotes::install_github(\"rstudio/shinyuieditor\")\n\n# lub też\npak::pak(\"rstudio/shinyuieditor\")",
    "crumbs": [
      "Wykład 4"
    ]
  },
  {
    "objectID": "wyk4.html#użycie-edytora-shiny",
    "href": "wyk4.html#użycie-edytora-shiny",
    "title": "Wykład 4",
    "section": "Użycie edytora Shiny",
    "text": "Użycie edytora Shiny\nAby użyć po raz pierwszy edytora interfejsu Shiny należy użyć następującej komendy:\n\nKodshinyuieditor::launch_editor(app_loc = \"shiny-app/\")\n\n\nJeśli w katalogu roboczym znajduje się aplikacja umieszczona w katalogu roboczym shiny-app, to edytor pozwoli na edycję istniejącej już aplikacji1. Warunek odpalenia shinyuieditor dla istniejącej aplikacji jest to, że wskazany katalog zawiera tylko plik app.R. Jeśli wskazany katalog nie zawiera niczego, edytor odpala się z możliwością wyboru wyglądu.\n1 Należy jednak, że musi to być aplikacja przygotowana wg schematu generowanego przez shinyuieditor , bo inaczej nie będzie ona działać. Przykładowo użycie launch_editor do stockVis nie chciało działać.\nKodshinyuieditor::launch_editor(app_loc = \"test_shinyuieditor/\")\n\n\n\n\nWygląd po wybraniu wyglądu aplikacji\n\nDodawanie elementów do aplikacji\nPo wyborze wyglądu głównego można przystąpić do edycji elementów wyglądu. Warto zacząć od tutorialu edytora klikając w prawym górnym rogu przycisk “Tour App”. Następnie można przystąpić do edycji wyglądu wg własnego uznania (patrzy przykład poniżej)\n\nAby dodać nowy element interfejsu użytkownika do aplikacji, należy przeciągnąć żądany element z panelu “Elements”. Miejsca, w których można umieścić element, zostaną podświetlone (jeśli nie ma dostępnych miejsc, spróbuj dodać nowy wiersz lub kolumnę do aplikacji, aby utworzyć miejsce). Po przeciągnięciu elementu na dostępny obszar, upuść go, aby dodać go do aplikacji.\nPrzemieszczanie elementów aplikacji\nKliknij i przeciągnij element ui, który chcesz przenieść. Podobnie jak w przypadku dodawania elementu, dostępne pozycje do przeniesienia elementu zostaną podświetlone. Przeciągnij element do żądanej nowej pozycji i upuść, aby go przenieść.\n\nWybór elementów aplikacji\nWybierz element, klikając wewnątrz niego. Po wybraniu elementu zostanie on oznaczony niebieskim konturem, a panel “Properties” zostanie zaktualizowany o szczegóły dotyczące elementu. Alternatywnie można wybrać element nadrzędny aktualnie wybranego elementu, klikając nazwę elementu nadrzędnego w wizualizacji ścieżki elementu w górnej części panelu “Properties”.\n\nUsuwanie elementów aplikacji\nWybierz element, po wybraniu elementu kliknij przycisk “Delete Element” w dolnej części panelu “Properties”. Niektóre elementy, takie jak grid_card(), będą również wyświetlać przyciski usuwania bezpośrednio na samym elemencie, gdy nie ma w nim żadnych elementów podrzędnych. Możesz również usunąć element za pomocą klawisza delete/backspace.\n\nAktualizacja ustwień elementów aplikacji\nWybierz element, po jego wybraniu zaktualizuj ustawienia za pomocą panelu “Properties”. Gdy dane wejściowe zostaną zaktualizowane, zmiany zostaną automatycznie zapisane i odzwierciedlone w skrypcie aplikacji i oknie podglądu na żywo.\n\nWyświetl rozmiary elementów aplikacji\nNajechanie myszą na lewy koniec wiersza lub górę kolumny powoduje wyświetlenie widżetu rozmiaru.\n\nDodawanie wierszy i kolumn do aplikacji\nOtwórz widżet rozmiaru wiersza lub kolumny sąsiadujący z miejscem, w którym chcesz dodać nowy wiersz lub kolumnę. Na obu końcach widżetu znajdują się przyciski plus (+), których kliknięcie spowoduje dodanie wiersza lub kolumny po odpowiednich stronach istniejącego wiersza lub kolumny.\n\nUsuwanie wierszy i kolumn aplikacji\nOtwórz widżet rozmiaru wiersza lub kolumny, który chcesz usunąć. Następnie kliknij czerwoną ikonę kosza, aby usunąć ten wiersz z układu. Jeśli ikona kosza jest wyszarzona, wiersz lub kolumna nie mogą zostać usunięte z powodu nazwanych obszarów siatki, które w całości się w nich znajdują. Najechanie myszką na zaszarzony przycisk spowoduje wskazanie tych obszarów siatki, dzięki czemu będzie można je usunąć lub przenieść w inne miejsce.\n\nZmiana rozmiarów wierszy i kolumn aplikacji\n\nLub też inaczej, otwórz widżet zmiany rozmiaru wiersza/kolumny Użyj kontrolek wprowadzania jednostek CSS w tym widżecie, aby zaktualizować rozmiar wiersza lub kolumny.\n\nWycofanie zmian w aplikacji\nUżyj przycisku cofnij dostępnego w prawym górnym rogu aplikacji, aby przywrócić interfejs użytkownika aplikacji do stanu sprzed ostatniej wprowadzonej zmiany. Jeśli chcesz przywrócić właśnie cofniętą zmianę, kliknij przycisk ponów po prawej stronie. Zarówno cofnięcie, jak i ponowienie można również wykonać za pomocą skrótów klawiaturowych, odpowiednio cmd/ctrl + z i cmd/ctrl + shift + z.\n\nZatrzymanie edytora aplikacji\nDopóki argument stop_on_browser_close jest ustawiony na domyślną wartość TRUE, wówczas wszystko, co należy zrobić, aby zatrzymać edytor, to zamknąć kartę/okno przeglądarki, w której edytor jest aktualnie otwarty. Innym sposobem zakończenia jest przerwanie serwera edytora poprzez naciśnięcie Control/Command + c w konsoli R używanej do uruchomienia edytora.",
    "crumbs": [
      "Wykład 4"
    ]
  },
  {
    "objectID": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "href": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "title": "Wykład 4",
    "section": "Zmiany w edytorze a zmiany w kodzie",
    "text": "Zmiany w edytorze a zmiany w kodzie\nNależy pamiętać, że każda zmiana w edytorze skutkuje zmianami w kodzie definiującym aplikację. W drugą stronę działa to analogicznie. Każda zmiana w kodzie znajduje swoje odwzorowanie w edytorze i preview.",
    "crumbs": [
      "Wykład 4"
    ]
  },
  {
    "objectID": "wyk4.html#podsumowanie-funkcjonalności-edytora-aplikacji",
    "href": "wyk4.html#podsumowanie-funkcjonalności-edytora-aplikacji",
    "title": "Wykład 4",
    "section": "Podsumowanie funkcjonalności edytora aplikacji",
    "text": "Podsumowanie funkcjonalności edytora aplikacji\nshinyuieditor, jako narzędzie do projektowania interfejsu użytkownika dla aplikacji Shiny w R, ma swoje zalety i wady. Oto niektóre z nich:\nZalety:\n\nŁatwość użycia - umożliwia użytkownikom, w tym osobom nieprogramującym, łatwe tworzenie i modyfikowanie interfejsów użytkownika poprzez graficzny interfejs, co obniża próg wejścia do tworzenia aplikacji Shiny.\nSzybki prototyping - pomaga w szybkim prototypowaniu aplikacji przez wizualne eksperymentowanie z różnymi układami i elementami UI, co jest szczególnie przydatne w fazie projektowania.\nInteraktywność bez bezpośredniego kodowania - ułatwia dodawanie interaktywnych elementów do aplikacji bez konieczności bezpośredniego pisania kodu, co może przyspieszyć rozwój projektu.\nEdukacyjne korzyści - może służyć jako narzędzie edukacyjne dla osób uczących się tworzenia aplikacji Shiny, pozwalając na lepsze zrozumienie, jak różne komponenty UI współpracują ze sobą.\nWady:\n\nOgraniczenia dostosowywania - graficzne interfejsy użytkownika mogą ograniczać możliwości dostosowania w porównaniu do bezpośredniego kodowania. Zaawansowane funkcje i niestandardowe zachowania mogą wymagać ręcznej edycji kodu.\nZależność od konkretnej implementacji - narzędzie takie jak shinyuieditor może nie być stale aktualizowane lub wspierane, co oznacza, że może nie być kompatybilne z najnowszymi wersjami Shiny lub R.\nKrzywa uczenia się dla zaawansowanych funkcji - mimo że narzędzie to obniża próg wejścia, zaawansowane funkcje Shiny mogą nadal wymagać solidnej wiedzy o R i Shiny, co oznacza, że użytkownicy będą musieli inwestować czas w naukę poza używaniem samego edytora.\n\nPodsumowując, shinyuieditor może być bardzo pomocny dla osób rozpoczynających pracę z Shiny oraz dla szybkiego prototypowania interfejsów użytkownika, ale dla zaawansowanych i wyspecjalizowanych potrzeb projektowych, bezpośrednie programowanie w R może oferować większą elastyczność i kontrolę.",
    "crumbs": [
      "Wykład 4"
    ]
  },
  {
    "objectID": "wyk4.html#tematy-aplikacji",
    "href": "wyk4.html#tematy-aplikacji",
    "title": "Wykład 4",
    "section": "Tematy aplikacji",
    "text": "Tematy aplikacji\nPakiet bslib w języku R jest narzędziem zaprojektowanym, aby ułatwić tworzenie estetycznie atrakcyjnych i responsywnych interfejsów użytkownika w aplikacjach Shiny oraz w dokumentach R Markdown i Quarto. Jego głównym celem jest integracja z Bootstrap, popularnym frameworkiem CSS do tworzenia responsywnych i mobilnych pierwszych projektów internetowych. Dzięki bslib, użytkownicy mogą łatwo dostosować wygląd swoich aplikacji Shiny i dokumentów R Markdown, korzystając z szerokiej gamy tematów i opcji stylizacji dostępnych w Bootstrapie.\nPakiet ten umożliwia również tworzenie niestandardowych tematów lub modyfikowanie istniejących, co pozwala na precyzyjne dostosowanie estetyki projektu do specyficznych wymagań i preferencji. Dzięki zintegrowanemu wsparciu dla różnych wersji Bootstrapa, bslib pozwala deweloperom wybierać między różnymi wersjami tego frameworka, co jest szczególnie przydatne w kontekście zachowania kompatybilności i eksplorowania nowych możliwości projektowych.\n\n\nPrzykład zastosowania bslib\n\nPodsumowując, pakiet bslib jest niezastąpionym narzędziem dla twórców aplikacji Shiny i autorów dokumentów R Markdown/Quarto, którzy chcą podnieść wizualną jakość swoich projektów, nie zagłębiając się głęboko w szczegóły implementacji CSS. Ułatwia on szybką i efektywną personalizację wyglądu, poprawiając jednocześnie ogólną użyteczność i dostępność tworzonych aplikacji oraz dokumentów.\nCzcionki\nPakiet bslib ułatwia również integrację i dostosowanie czcionek w aplikacjach Shiny. Umożliwia to łatwe włączanie czcionek z zewnętrznych źródeł, takich jak Google Fonts, co pozwala na bardziej spersonalizowane i unikalne projekty interfejsu użytkownika. Dzięki bslib, programiści mogą precyzyjnie kontrolować wygląd tekstów w swoich aplikacjach, w tym styl i rozmiar czcionek, co przyczynia się do lepszej czytelności i estetyki.\nWykresy\nbslib współpracuje również z bibliotekami do tworzenia wykresów w R, takimi jak ggplot2, umożliwiając lepszą integrację wizualną wykresów z resztą aplikacji. Dzięki temu kolory, czcionki i inne elementy stylistyczne wykresów mogą być spójne z ogólnym motywem aplikacji, co przyczynia się do jednolitego i profesjonalnego wyglądu. Możliwość dostosowania wyglądu wykresów bez bezpośredniego manipulowania każdym elementem pozwala na szybsze i bardziej efektywne tworzenie atrakcyjnych wizualizacji danych.\nPodsumowując, bslib znacząco rozszerza możliwości personalizacji i ulepszania interfejsów użytkownika w aplikacjach Shiny, R Markdown i innych treściach dynamicznych R. Poprzez ułatwienie dostosowywania tematów, integracji czcionek i harmonizacji wyglądu wykresów, bslib pozwala na tworzenie bardziej spersonalizowanych, atrakcyjnych i spójnych projektów bez potrzeby zaawansowanej znajomości CSS czy JavaScript.",
    "crumbs": [
      "Wykład 4"
    ]
  },
  {
    "objectID": "wyk3.html",
    "href": "wyk3.html",
    "title": "Wykład 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w języku R i Python (od niedawna, jak jednak będę się skupiał na R). Jest to obszar, w którym inżynierowie danych i analitycy mogą tworzyć interaktywne aplikacje internetowe, wykorzystując całą swoją wiedzę i analizy zgromadzoną w języku R. Dzięki Shiny, użytkownicy mogą łatwo przekształcać swoje skrypty i modele w interaktywne aplikacje internetowe, bez konieczności posiadania wcześniejszego doświadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera się na paradygmacie “reactive programming”, co oznacza, że aplikacje tworzone przy jego użyciu są dynamiczne i reagują na zmiany danych w czasie rzeczywistym. Oznacza to, że użytkownicy mogą manipulować danymi i obserwować, jak te zmiany wpływają na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementów Shiny jest jego prostota użycia. Za pomocą kilku linii kodu w języku R, można stworzyć interaktywny interfejs, który pozwala użytkownikowi na łatwe eksplorowanie danych. Warto również podkreślić, że Shiny integruje się z istniejącymi narzędziami analizy danych w R, takimi jak ggplot2 czy dplyr, co ułatwia korzystanie z istniejących umiejętności programistycznych.\nShiny oferuje różnorodne elementy interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umożliwiając tworzenie rozbudowanych interfejsów. Ponadto, framework ten obsługuje również funkcje uwierzytelniania i autoryzacji, co pozwala kontrolować dostęp do aplikacji w zależności od potrzeb.\nDzięki Shiny, analiza danych staje się bardziej dostępna i przyjazna dla użytkownika końcowego, umożliwiając interaktywną eksplorację wyników analizy danych bez konieczności głębokiego zrozumienia kodu R. To narzędzie jest szczególnie przydatne dla osób pracujących w dziedzinie analizy danych, statystyki, czy nauk społecznych, które chcą szybko i efektywnie udostępnić swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe.",
    "crumbs": [
      "Wykład 3"
    ]
  },
  {
    "objectID": "wyk3.html#czym-jest-shiny",
    "href": "wyk3.html#czym-jest-shiny",
    "title": "Wykład 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w języku R i Python (od niedawna, jak jednak będę się skupiał na R). Jest to obszar, w którym inżynierowie danych i analitycy mogą tworzyć interaktywne aplikacje internetowe, wykorzystując całą swoją wiedzę i analizy zgromadzoną w języku R. Dzięki Shiny, użytkownicy mogą łatwo przekształcać swoje skrypty i modele w interaktywne aplikacje internetowe, bez konieczności posiadania wcześniejszego doświadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera się na paradygmacie “reactive programming”, co oznacza, że aplikacje tworzone przy jego użyciu są dynamiczne i reagują na zmiany danych w czasie rzeczywistym. Oznacza to, że użytkownicy mogą manipulować danymi i obserwować, jak te zmiany wpływają na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementów Shiny jest jego prostota użycia. Za pomocą kilku linii kodu w języku R, można stworzyć interaktywny interfejs, który pozwala użytkownikowi na łatwe eksplorowanie danych. Warto również podkreślić, że Shiny integruje się z istniejącymi narzędziami analizy danych w R, takimi jak ggplot2 czy dplyr, co ułatwia korzystanie z istniejących umiejętności programistycznych.\nShiny oferuje różnorodne elementy interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umożliwiając tworzenie rozbudowanych interfejsów. Ponadto, framework ten obsługuje również funkcje uwierzytelniania i autoryzacji, co pozwala kontrolować dostęp do aplikacji w zależności od potrzeb.\nDzięki Shiny, analiza danych staje się bardziej dostępna i przyjazna dla użytkownika końcowego, umożliwiając interaktywną eksplorację wyników analizy danych bez konieczności głębokiego zrozumienia kodu R. To narzędzie jest szczególnie przydatne dla osób pracujących w dziedzinie analizy danych, statystyki, czy nauk społecznych, które chcą szybko i efektywnie udostępnić swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe.",
    "crumbs": [
      "Wykład 3"
    ]
  },
  {
    "objectID": "wyk3.html#części-składowe-aplikacji-shiny",
    "href": "wyk3.html#części-składowe-aplikacji-shiny",
    "title": "Wykład 3",
    "section": "Części składowe aplikacji Shiny",
    "text": "Części składowe aplikacji Shiny\nDo poprawnego działania aplikacji Shiny konieczne jest zainstalowanie pakietu shiny.\nW każdej aplikacji Shiny można wyróżnić trzy podstawowe części:\n\n\nUI (Interfejs Użytkownika):\n\n\nElementy Interfejsu - definiują strukturę interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele, wykresy itp.\n\nUkład Strony - określa rozmieszczenie i stylizację elementów na stronie.\n\nDefinicja UI - jest to miejsce, w którym programista określa, jak mają wyglądać interaktywne elementy widoczne dla użytkownika.\n\n\n\nPrzykład definicji UI w Shiny może wyglądać następująco:\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Moja Aplikacja Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"slider\", \"Wybierz wartość:\", min = 1, max = 100, value = 50)\n    ),\n    mainPanel(\n      plotOutput(\"wykres\")\n    )\n  )\n)\n\n\n\n\nServer (Serwer):\n\n\nFunkcje Obliczeniowe - zawierają kod R odpowiedzialny za przetwarzanie danych, generowanie wyników oraz reakcję na interakcje użytkownika.\n\nReaktywność - serwer Shiny korzysta z obiektów reaktywnych do śledzenia zmian w danych i automatycznego aktualizowania wyników w interfejsie użytkownika.\n\n\n\nPrzykład definicji serwera w Shiny może wyglądać tak:\n\nKodserver &lt;- function(input, output) {\n  output$wykres &lt;- renderPlot({\n    dane &lt;- seq(1, input$slider)\n    plot(dane, main = \"Wykres dynamiczny\")\n  })\n}\n\n\n\n\nSesja Shiny:\n\n\nKomunikacja UI-Server - każda sesja Shiny umożliwia komunikację między interfejsem użytkownika a serwerem, przesyłanie danych i instrukcji między dwiema warstwami aplikacji.\n\nŻywotność Aplikacji - sesja utrzymuje stan aplikacji, umożliwiając śledzenie i reakcję na zmiany dokonywane przez użytkownika.\n\n\n\nPrzykład uruchamiania aplikacji Shiny zdefiniowanej powyżej:\n\nKodshinyApp(ui, server)\n\n\nDo zapoznania się z możliwościami aplikacji Shiny zachęcam do uruchomienia następujących przykładów aplikacji.\n\nKodrunExample(\"01_hello\")      # a histogram\nrunExample(\"02_text\")       # tables and data frames\nrunExample(\"03_reactivity\") # a reactive expression\nrunExample(\"04_mpg\")        # global variables\nrunExample(\"05_sliders\")    # slider bars\nrunExample(\"06_tabsets\")    # tabbed panels\nrunExample(\"07_widgets\")    # help text and submit buttons\nrunExample(\"08_html\")       # Shiny app built from HTML\nrunExample(\"09_upload\")     # file upload wizard\nrunExample(\"10_download\")   # file download wizard\nrunExample(\"11_timer\")      # an automated timer\n\n\n\n\nPrzykład wywołania przykładu ‘01_hello’\n\nReaktywność w Shiny\nReaktywność jest kluczowym konceptem w Shiny, który pozwala interakcji między komponentami interfejsu użytkownika a kodem R. W Shiny, gdy użytkownik wykonuje interakcję (na przykład klikając przycisk, wpisując tekst, wybierając wartość z rozwijanej listy), aplikacja automatycznie reaguje na tę interakcję. To oznacza, że wynik generowany przez aplikację jest zmienny i dynamicznie dostosowuje się do akcji użytkownika, bez konieczności odświeżania strony.\nReaktywność w Shiny opiera się na tzw. “reactive expressions” oraz “reactive conductors”. “Reactive expressions” są funkcjami, które automatycznie aktualizują wynik w zależności od zmian w ich zmiennych wejściowych. Z kolei “reactive conductors” pozwalają na definiowanie reakcji na zmiany wartości w interfejsie użytkownika.\nPrzykłady reaktywności w Shiny obejmują dynamiczne odświeżanie wykresów w zależności od wartości wybranych przez użytkownika, automatyczne dostosowanie zakresu danych w oparciu o interakcje użytkownika (np. przesunięcia suwaka), zmiany zależne od wprowadzonych danych (np. obliczenia oparte na wartościach wprowadzonych do pól tekstowych), i wiele innych. Reaktywność umożliwia tworzenie interfejsów, które są interaktywne i dostosowują się do działań użytkownika w czasie rzeczywistym.\n\n\nWyrażenia reaktywne (reactive()):\n\nReaktywne wyrażenia to fragmenty kodu, które automatycznie obliczają i śledzą swoje zależności.\nPrzykład: Reaktywne wyrażenie, które oblicza sumę dwóch wartości wprowadzanych przez użytkownika.\n\n\nKodsuma_reaktywna &lt;- reactive({\n  input$wartosc1 + input$wartosc2\n})\n\n\n\n\nObserwatory (observe()):\n\nObserwatory to fragmenty kodu, które są wykonywane w odpowiedzi na zmiany w danych. Służą najczęściej do działań typu side effect.\nPrzykład: Obserwator, który wypisuje na konsoli aktualną wartość suwaka.\n\n\nKodobserve({\n  cat(\"Aktualna wartość suwaka:\", input$suwak, \"\\n\")\n})\n\n\n\n\nReaktywne Funkcje (render*()):\n\nFunkcje render*()są używane w serwerze do generowania wyników, które są automatycznie aktualizowane w interfejsie w zależności od zmian w danych wejściowych.\nPrzykład: Renderowanie wykresu w zależności od wartości suwaka.\n\n\nKodoutput$wykres &lt;- renderPlot({\n  dane &lt;- seq(1, input$suwak)\n  plot(dane, main = \"Wykres dynamiczny\")\n})\n\n\n\n\nPrzykład 1\nRozważmy prosty przykład zastosowania reaktywności w Shiny, gdzie użytkownik wprowadza dwie liczby za pomocą pól tekstowych, a aplikacja reaguje na te zmiany, automatycznie obliczając i wyświetlając ich sumę. W tym przykładzie wykorzystamy reaktywne wyrażenia.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Sumator\"),\n  textInput(\"liczba1\", \"Wprowadź pierwszą liczbę:\", value = \"\"),\n  textInput(\"liczba2\", \"Wprowadź drugą liczbę:\", value = \"\"),\n  textOutput(\"wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Reaktywne wyrażenie obliczające sumę dwóch liczb\n  suma_reaktywna &lt;- reactive({\n    # Konwertujemy wprowadzone wartości na liczby\n    liczba1 &lt;- as.numeric(input$liczba1)\n    liczba2 &lt;- as.numeric(input$liczba2)\n    \n    # Sprawdzamy, czy wprowadzone wartości są liczbami\n    if (is.na(liczba1) || is.na(liczba2)) {\n      return(NULL)  # Zwracamy NULL, jeśli dane są nieprawidłowe\n    }\n    \n    # Obliczamy sumę\n    suma &lt;- liczba1 + liczba2\n    return(suma)\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$wynik &lt;- renderText({\n    suma &lt;- suma_reaktywna()\n    \n    # Sprawdzamy, czy wynik jest dostępny\n    if (!is.null(suma)) {\n      return(paste(\"Suma: \", suma))\n    } else {\n      return(\"Wprowadź poprawne liczby.\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, kiedy użytkownik wprowadza liczby do pól tekstowych, reaktywne wyrażenie suma_reaktywna automatycznie oblicza sumę tych liczb. Następnie, przy użyciu funkcji renderującej renderText, wynik jest wyświetlany w interfejsie. Dzięki temu podejściu, interfejs jest reaktywny na zmiany wprowadzane przez użytkownika, dostosowując się automatycznie do nowych danych i prezentując aktualny wynik.\n\nPrzykład 2\nRozważmy teraz przykład zastosowania wyrażenia reaktywnego w Shiny. W tej sytuacji, użytkownik będzie mógł kliknąć przycisk, co spowoduje inkrementację wartości licznika. Wykorzystamy do tego celu obiekt reaktywny.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik Kliknięć\"),\n  actionButton(\"przycisk\", \"Kliknij mnie\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Inicjalizacja obiektu reaktywnego dla licznika\n  licznik &lt;- reactiveValues(licznik_wartosc = 0)\n\n  # Obserwator reagujący na kliknięcie przycisku\n  observeEvent(input$przycisk, {\n    # Inkrementacja wartości licznika po kliknięciu przycisku\n    licznik$licznik_wartosc &lt;- licznik$licznik_wartosc + 1\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$licznik_wynik &lt;- renderText({\n    paste(\"Liczba kliknięć: \", licznik$licznik_wartosc)\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, obiekt reaktywny licznik jest używany do przechowywania wartości licznika. Za każdym razem, gdy użytkownik kliknie przycisk, obserwator reaguje na to kliknięcie, inkrementując wartość licznika w obiekcie reaktywnym. Następnie, przy użyciu funkcji renderującej renderText, aktualna wartość licznika jest wyświetlana w interfejsie. Dzięki temu, interfejs jest reaktywny na akcje użytkownika, a wartość licznika automatycznie się aktualizuje.\n\nPrzykład 3\nPrzykład zastosowania obserwatora w Shiny można przedstawić na prostym przypadku, gdzie użytkownik wpisuje tekst do pola tekstowego, a aplikacja reaguje na każdą zmianę i wyświetla liczbę znaków wprowadzonych przez użytkownika. W tym przypadku użyjemy funkcji obserwującej (observe) do reakcji na zmiany w tekście wprowadzonym przez użytkownika.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik Znaków\"),\n  textInput(\"tekst_input\", \"Wprowadź tekst:\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Obserwator reagujący na zmiany w tekście wprowadzonym przez użytkownika\n  observe({\n    # Pobranie tekstu z pola tekstowego\n    wprowadzony_tekst &lt;- input$tekst_input\n    \n    # Obliczenie liczby znaków w tekście\n    liczba_znakow &lt;- nchar(wprowadzony_tekst)\n    \n    # Aktualizacja wyniku w interfejsie\n    output$licznik_wynik &lt;- renderText({\n      paste(\"Liczba znaków: \", liczba_znakow)\n    })\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, funkcja observe śledzi zmiany w polu tekstowym (textInput) o nazwie “tekst_input”. Za każdym razem, gdy użytkownik wprowadza lub zmienia tekst, obserwator automatycznie aktualizuje wynik w interfejsie, wyświetlając liczbę znaków wprowadzonych przez użytkownika. Dzięki obserwatorowi, aplikacja jest reaktywna na zmiany w polu tekstowym bez konieczności odświeżania strony.\n\nPrzykład 4\nPrzykład wykorzystania renderPlot w Shiny może obejmować generowanie dynamicznego wykresu w zależności od interakcji użytkownika. Poniżej przedstawiam prosty scenariusz, w którym użytkownik może wybierać rodzaj wykresu (liniowy lub punktowy) oraz regulować parametry, a aplikacja reaguje, generując i wyświetlając odpowiedni wykres.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny Wykres\"),\n  selectInput(\"typ_wykresu\", \"Wybierz typ wykresu:\",\n              choices = c(\"Linia\", \"Punkty\")),\n  sliderInput(\"ilosc_punktow\", \"Liczba punktów:\", min = 10, max = 100, value = 50),\n  plotOutput(\"wykres\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Renderowanie wykresu w zależności od wyboru użytkownika\n  output$wykres &lt;- renderPlot({\n    typ_wykresu &lt;- input$typ_wykresu\n    ilosc_punktow &lt;- input$ilosc_punktow\n    \n    # Generowanie wykresu w zależności od wyboru użytkownika\n    if (typ_wykresu == \"Linia\") {\n      plot(1:ilosc_punktow, type = \"l\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    } else {\n      plot(1:ilosc_punktow, type = \"p\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, użytkownik ma możliwość wyboru rodzaju wykresu (liniowy lub punktowy) za pomocą rozwijanej listy (selectInput). Ponadto, suwak (sliderInput) pozwala regulować liczbę punktów na wykresie. Funkcja renderPlot reaguje na zmiany w tych parametrach, generując odpowiedni wykres w zależności od wyboru użytkownika. Wykres jest następnie renderowany w sekcji interfejsu o nazwie “wykres”.\n\nKolejność wykonywanych czynności w obiektach reaktywnych.\nW grafie reaktywnym w Shiny, kolejność wykonywania czynności jest określana przez zależności między reaktywnymi elementami. W ogólnym przypadku, Shiny stosuje podejście zwane “reactive programming”, gdzie reaktywne elementy składają się z obiektów reaktywnych, obserwatorów i funkcji renderujących.\nKolejność wykonywania czynności w grafie reaktywnym może być ogólnie opisana następująco:\n\n\nInicjalizacja:\n\nAplikacja Shiny zaczyna od inicjalizacji interfejsu użytkownika (UI) oraz serwera.\nObiekty reaktywne są tworzone i inicjalizowane zgodnie z ich definicjami.\n\n\n\nObserwatory:\n\nObserwatory reagują na zmiany w danych i wykonują odpowiednie akcje.\nObserwatory są wywoływane w odpowiedzi na zdarzenia, takie jak kliknięcia przycisków, zmiany wartości pól tekstowych itp.\n\n\n\nReaktywne Wyrażenia:\n\nReaktywne wyrażenia są obliczane w odpowiedzi na zmiany danych wejściowych, na których zależą.\nReaktywne wyrażenia to fragmenty kodu, które zwracają wartość i śledzą swoje zależności.\n\n\n\nFunkcje Renderujące:\n\nFunkcje renderujące są wywoływane w celu aktualizacji wyników w interfejsie użytkownika na podstawie wartości zwróconych przez reaktywne wyrażenia.\nSą one odpowiedzialne za generowanie treści do wyświetlenia, np. w obszarze tekstowym, wykresie czy tabeli.\n\n\n\nAktualizacja UI:\n\nZaktualizowane wyniki są renderowane w interfejsie użytkownika.\n\n\n\nWażne jest zrozumienie, że Shiny automatycznie dba o zarządzanie zależnościami między reaktywnymi elementami, co oznacza, że jeśli jedna wartość zmieni się, to wszystkie elementy zależne od niej zostaną automatycznie zaktualizowane. Dzięki temu podejściu, Shiny zapewnia spójność danych i dynamiczne dostosowywanie interfejsu użytkownika w zależności od akcji użytkownika lub zmian w danych.\nDla lepszego zrozumienia kolejności wykonywanych działań oraz “magii” jakiej dostarczają obiekty reaktywne, przeanalizujmy następujący przykład:\nPrzykład 5\nNiech rdzeniem naszej1 aplikacji będzie następujący kod:\n1 bezużytecznej\nKodui &lt;- fluidPage(\n  numericInput(\"a\", \"a\", value = 10),\n  numericInput(\"b\", \"b\", value = 1),\n  numericInput(\"c\", \"c\", value = 1),\n  plotOutput(\"x\"),\n  tableOutput(\"y\"),\n  textOutput(\"z\")\n)\n\nserver &lt;- function(input, output, session) {\n  rng &lt;- reactive(input$a * 2)\n  smp &lt;- reactive(sample(rng(), input$b, replace = TRUE))\n  bc &lt;- reactive(input$b * input$c)\n  \n  output$x &lt;- renderPlot(hist(smp()))\n  output$y &lt;- renderTable(max(smp()))\n  output$z &lt;- renderText(bc())\n}\n\n\nW naszej aplikacji występują trzy wejścia (a, b, c) z ustawionymi wartościami domyślnymi, trzy wyrażenia reaktywne (rng, smp, bc) oraz trzema reaktywnymi wyjściami (x,y,z). W momencie inicjalizacji aplikacji stan je można opisać poniższym grafem (wszystkie wyrażenia reaktywne i wyjścia są w stanie określanym jako invalidated):\n\n\n\n\nW momencie egzekucji aplikacji Shiny uruchamiane jest jedno losowe wejście2 (oznaczmy to żółtym kolorem).\n2 najczęściej wyjścia są niezależne, ale w przypadku zagnieżdżeń kolejność wykonywania aplikacji uwzględnia tą zależność\n\n\n\nPonieważ wywołanie to potrzebuje wartości wyrażeń reaktywnych, to tworzy się połączenie z wyrażeniami reaktywnymi, od których zależy wyjście i inicjalizowane są wyrażenia reaktywne. Powiedzmy, że pierwszym wykonującym się wyjściem było output$x. Wtedy wymagane jest wywołanie obiektu reaktywnego smp().\n\n\n\n\nWartość smp() zależy za to od input$b, którego wartość jest określona, ponieważ jest to wartość wejściowa z domyślną wartością 1.\n\n\n\n\nWartość smp() zależy również od innego wyrażenia reaktywnego rng(), które jest znów powiązane z wejściem input$a. Analogicznie do powyższej sytuacji odpowiednie połączenia i egzekucje zostaną wywołane.\n\n\n\n\nW ten sposób wszystko co jest potrzebne do egzekucji wyjścia output$x zostało policzone i można przejść do wywołania wyjścia.\n\n\n\n\nPrzechodzimy zatem do egzekucji kolejnego wyjścia output$y.\n\n\n\n\nPonieważ output$y zależy tylko do smp() a to zostało już policzone i jego stan został “skeszowany”, to nie trzeba po raz kolejny wywoływać tych obliczeń3. W podobny sposób wywoływane są wszystkie wyjścia. Po egzekucji wszystkich wyjść graf przedstawia się następująco4:\n3 to część magii reaktywności4 stan ten się nie zmienia aż do zmiany jakiejś wielkości wejściowej\n\n\n\nJeśli nastąpi zmiana wartości wejściowej, wówczas wejście to jest najpierw oznaczane jako invalidated, a następnie stan invalidated jest nadawany wszystkim obiektom zależnym od tego wejścia, co powoduje, że graf wygląda następująco:\n\n\n\n\nPonadto usuwane są połączenia do obiektów w stanie invalidated i jednocześnie przypisywana jest nowa wartość input$a.\n\n\n\n\nW dalszej kolejności znów jedno z wyjść unieważnionych (ang. invalidated) jest poddane egzekucji, która pociąga za sobą egzekucje tych wejść i wyrażeń reaktywnych, które są wymagane do obliczenia wartości lub wyświetlenia wyjścia.\n\n\n\n\nDalej proces przebiega podobnie. Warto zauważyć, że pewne wejścia i wyrażenia reaktywne nie musiały się wywoływać ponownie.\nPrzeanalizujmy jeszcze jeden krótki przykład aby lepiej zrozumieć reaktywność w Shiny.\nPrzykład 6\nAplikacja jest zbudowana następująco:\n\nKodui &lt;- fluidPage(\n  selectInput(\"choice\", \"A or B?\", c(\"a\", \"b\")),\n  numericInput(\"a\", \"a\", 0),\n  numericInput(\"b\", \"b\", 10),\n  textOutput(\"out\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    if (input$choice == \"a\") {\n      input$a\n    } else {\n      input$b\n    }\n  }) \n}\n\n\nMogłoby się wydawać, że graf dla niej wygląda następująco:\n\n\n\n\nAle ponieważ Shiny dynamicznie rekonstruuje wykres po unieważnieniu danych wyjściowych, w rzeczywistości wygląda on jak jeden z poniższych wykresów, w zależności od wartości input$choice. Zapewnia to, że Shiny wykonuje minimalną ilość pracy, gdy dane wejściowe są unieważniane. W tym przypadku, jeśli input$choice jest ustawiony na b, to wartość input$a nie wpływa na output$out i nie ma potrzeby jej ponownego obliczania.\n\n\n\n\nGdybyśmy nieznacznie zmienili funkcję serwera, to wartość wyjścia stale by zależała od dwóch wejść.\n\nKodoutput$out &lt;- renderText({\n  a &lt;- input$a\n  b &lt;- input$b\n\n  if (input$choice == \"a\") {\n    a\n  } else {\n    b\n  }\n}) \n\n\n\n\n\n\n\n\nWskazówka\n\n\n\nChcąc poznać reguły panujące w złożonych aplikacjach i zależności pomiędzy obiektami, można użyć pakietu reactlog. Uruchamiając przed wywołaniem aplikacji funkcję reactlog::reactlog_enable() powodujemy odpalenie serwera rejestrującego połączenia. Można przeglądać na żywo zmiany stanów poszczególnych obiektów przez wywołanie Ctrl+F3 (Windows) lub Cmd+F3 (MacOS i Linux). Po zakończeniu działania aplikacji możemy też przejrzeć log stanów używając shiny::reactlogShow().",
    "crumbs": [
      "Wykład 3"
    ]
  },
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "Wykład 2",
    "section": "",
    "text": "Przypominając sytuację w jakiej się znajdujemy… utworzyliśmy repozytorium o nazwie DariuszMajerek/Github_tests. Dokonaliśmy w nim kilku zmian commitowanych za każdym razem. Podgląd tych zmian możemy dokonać przez przegląd commitów.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n1 Ewentualne zmiany nie popsują niczego w tym repo, bo jest ono przygotowane do tego typu testów.\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium.\n\n2 Dotąd mamy wszystko zrobione",
    "crumbs": [
      "Wykład 2"
    ]
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "Wykład 2",
    "section": "",
    "text": "Zmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n1 Ewentualne zmiany nie popsują niczego w tym repo, bo jest ono przygotowane do tego typu testów.\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu.",
    "crumbs": [
      "Wykład 2"
    ]
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "Wykład 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request.",
    "crumbs": [
      "Wykład 2"
    ]
  },
  {
    "objectID": "wyk2.html#działanie-na-gałęziach",
    "href": "wyk2.html#działanie-na-gałęziach",
    "title": "Wykład 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium.\n\n2 Dotąd mamy wszystko zrobione",
    "crumbs": [
      "Wykład 2"
    ]
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "Wykład 1",
    "section": "",
    "text": "Ponieważ proces budowy i udoskonalania modelu może trwać długo i być prowadzony przez kilka osób, to kontrolowanie wersji modelu wydaje się być konieczne.\n\n\n\n\n\n\n\nPonadto konieczne w tym procesie jest kontrolowanie zarówno aktualnej wersji modelu, jak i wszystkich przyległości z nim związanych. Idealnym narzędziem do zautomatyzowania czynności polegających na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program działający w terminalu ale istnieją również jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednocześnie połączony z hubem (czyli kontenerem) pozwalającym na przechowywanie i udostępnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usługa serwerowa, która pozwala na zapisywanie i udostępnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\n\n\n\n\n\n\n\nW niniejszym wykładzie zostaną przedstawione rozwiązania z wykorzystaniem Gita i GitHuba.\nPrzykładowe repozytorium projektu tidymodels na stronie GitHub wygląda następująco.\n\n\n\nStrona projektu tidymodels na GitHubie\n\n\nGit w połączeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, który tworzymy, a jednocześnie na udostępnianie go oraz umożliwienie współpracy nad kodem przez wielu użytkowników - współtwórców (ang. contributors) ale nie tylko. Udostępnianie może być zarówno publiczne, jak i prywatne.\nFunkcjonalności GitHub, to:\n\nKontrola wersji kodu.\nKopiowanie kodu na dwa sposoby:\n\nClone:\n\nKlonowanie repozytorium oznacza skopiowanie zdalnego repozytorium na lokalny komputer.\nGdy klonujesz repozytorium, uzyskujesz identyczną kopię zawartości, historii i gałęzi tego repozytorium na swoim lokalnym systemie.\nMożesz pracować nad projektem lokalnie i wysyłać swoje zmiany z powrotem do zdalnego repozytorium.\n\nPrzykład klonowania repozytorium:\n\ngit clone https://github.com/nazwa_uzytkownika/nazwa_repozytorium.git\n\nFork:\n\nForking (rozszerzanie) repozytorium oznacza utworzenie kopii zdalnego repozytorium w obrębie twojego konta na GitHubie.\nKiedy forkujesz repozytorium, masz własną kopię, którą możesz dowolnie modyfikować, nie wpływając na oryginalne repozytorium.\nForkowanie jest często używane w projekcie open source, gdzie chcesz dodać swoje zmiany, ale nie masz bezpośredniego dostępu do repozytorium.\n\nPrzykład forka repozytorium:\n\nNa stronie repozytorium w witrynie GitHub klikasz przycisk “Fork” w prawym górnym rogu. To utworzy kopię tego repozytorium w twoim własnym koncie.\n\nForking pozwala ci pracować niezależnie nad projektem, a następnie możesz zgłosić pull request (prośbę o zaakceptowanie zmian) do oryginalnego repozytorium, aby właściciel mógł uwzględnić twoje zmiany.\n\nZarządzanie Branchami:\n\nGitHub oferuje narzędzia do łatwego zarządzania gałęziami (branches). Możesz tworzyć, usuwać i łączyć gałęzie za pomocą interfejsu graficznego.\n\nKomentarze i Dyskusje:\n\nMożliwość dodawania komentarzy do kodu źródłowego, pull requestów i problemów ułatwia komunikację w zespole.\n\nIssues:\n\nGitHub umożliwia śledzenie problemów i zadań (issues). Możesz tworzyć, przypisywać, zamykać i dyskutować na temat problemów, co ułatwia śledzenie postępów w projekcie.\n\nIntegracje i Webhooks:\n\nGitHub oferuje integracje z różnymi narzędziami i usługami, co umożliwia automatyzację różnych procesów w projekcie. Webhooki pozwalają na powiadamianie zewnętrznych usług o zdarzeniach na GitHubie.\n\nPull Request Reviews:\n\nMożliwość recenzowania kodu źródłowego w ramach pull requestów. Recenzenci mogą komentować zmiany, proponować poprawki i potwierdzać gotowość do zaakceptowania zmian.\n\nGitHub Actions:\n\nGitHub Actions to funkcja pozwalająca na automatyzację procesów budowania, testowania i wdrażania kodu źródłowego za pomocą skryptów.\n\nBezpieczeństwo:\n\nGitHub oferuje funkcje zabezpieczające, takie jak uwierzytelnianie dwuskładnikowe, zarządzanie dostępem i audyt.\n\n\nŁącząc Git z Githubem, programiści zyskują mocne narzędzie do kontroli wersji, współpracy, śledzenia problemów i automatyzacji procesów, co przyczynia się do skutecznego zarządzania projektami oprogramowania1.\n1 Nie wszystkie z powyższych tematów uda nam się omówić na wykładzie ale większość zostanie zademonstrowana.\nTworzenie repozytorium\n\nTworzenie konta na GitHub\nAby stworzyć jakiekolwiek repozytorium, trzeba mieć miejsce, w którym to zrobimy. A zatem utworzymy nowe konto na GitHub.\n\nPrzejdź na stronę https://github.com/\n\n\n\nStrona domowa GitHub\n\n\nNastępnie wpisz w miejsce na email swój adres poczty.\nW kolejnym kroku wypełnij pola na stronie\n\nPo wypełnieniu wszystkich pól zostaniesz poproszony o rozwiązanie testu na sprawdzenie czy jesteś człowiekiem 🙉.\n\nWpisz kod, który otrzymasz na podany przez Ciebie email.\n\nW kolejnym oknie wybierz interesujące Cię funkcjonalności (możesz też nie wybierać żadnej).\n\nNa kolejnej stronie można wybrać darmowe konto regularnego użytkownika ale jest też możliwość założenia konta studenckiego (wówczas trzeba przy logowaniu podać email uczelniany po czym nastąpi weryfikacja). Konto studenckie daje nieco więcej możliwości ale konto darmowe wystarczy do naszych zadań.\n\nW kolejnym kroku powinieneś już zostać przeniesiony do strony głównej Twojego konta na Githubie 👏.\n\n\nChoć wydaje się, że to koniec, to niestety tak nie jest 🤯. W roku 2022 GitHub wprowadził dodatkowe zabezpieczenia i każde połączenie z GitHubem musi być uwierzytelnione (wcześniej też tak było ale mimo to nieco prościej można było to zrobić). Instrukcję jak uwierzytelnić GitHub wraz z instalacją i dodaniem klucza publicznego SSH w Windows można znaleźć pod adresem Instalacja Gita z SSH. Instrukcję dodawania klucza SSH dla różnych platform można znaleźć pod adresem https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account.\nMożemy teraz przystąpić do tworzenia repozytorium 😲 . Załóżmy, że będzie to repozytorium przeznaczone do testów (stąd nazwa Github_tests).\n\n\n\nNazwa ta pewnie jest używana wielokrotnie w całym Githubie (patrz 👉) ale my tworzymy repozytorium w ramach naszego konta dlatego faktycznie nazwa repozytorium będzie następująca DariuszMajerek/Github_tests - czyli jest połączeniem nazwy użytkownika i repozytorium.\n\n\n\n\n\nPuste repozytorium wygląda następująco.\n\n\n\n\n\n\n\nWażne\n\n\n\nNajważniejsze z tej strony jest aby skopiować adres repozytorium w formie HTTPS https://github.com/DariuszMajerek/Github_tests.git lub SSH git@github.com:DariuszMajerek/Github_tests.git.\n\n\n\n\n\nŁączenie repozytorium lokalnego ze zdalnym\nPóki co istniej tylko repozytorium zdalne (na Githubie, z resztą puste) ale nie istnieje jego odpowiednik na dysku lokalnym. W tym celu należy utworzyć katalog o tej samej nazwie co nazwa repozytorium (bez nazwy użytkownika) a następnie przejść do tego katalogu.\n\n\n\nTworzenie katalogu repo\n\n\n\n\n\n\n\n\nZagrożenie\n\n\n\nPowyższy ekran może nieco inaczej wyglądać w innych systemach operacyjnych.\n\n\nW katalogu repo2 inicjujemy repo lokalne poprzez\n2 skrót od repozytoriumgit init\n\n# nastepnie sprawdzamy status repo\ngit status\n\nZainicjowanie lokalnego repo pozwala wymieniać dane pomiędzy repo lokalnym i zdalnym (w obie strony). Możemy o tym myśleć w ten sposób, że są trzy stany naszego repo:\n\nlokalne - na dysku (ang. working dir);\nzdalne - na serwerze np. Github (ang. HEAD);\ntymczasowe - instancja naszego repo w wersji tymczasowej istniejąca na dysku (ang. index), która powinna zostać przesłana (wypchnięta - push) na serwer. Ta czynność jest opisana w tę stronę, bo najczęściej to zmiany na dysku lokalnym, gdzie tworzymy model, wypychamy na serwer.\n\n\n\n\nTrzy stany repo\n\n\nInicjacja jedynie tworzy katalog .git z plikami konfiguracyjnymi repo. Nic poza tym katalogiem nie zawiera. Teraz przystąpimy do dodania pierwszego pliku do repo. Dobrym zwyczajem jest dodanie pliku README.md, w którym znajdą się podstawowe informacje dotyczące repo. Plik ten powinien być napisany w języku markdown aby GitHub mógł bo przetworzyć i wyświetlić w sformatowany sposób.\n# plik README.md można utworzyć na kilka sposóbów, m.in w R\n# w poniższym przykładzie pokazuję jak to można zrobić w terminalu\n# poniższy kod stworzy nowy plik README.md i doda jedynie tytuł rozdziału \necho \"# Github_tests\" &gt;&gt; README.md\nJak widać na załączonym obrazie powstał plik README.md i został wypełniony treścią.\n\nPonieważ nastąpiły pierwsze zmiany w repo (dodaliśmy plik README.md), to możemy te zmiany wysłać na serwer, na którym obecnie zmiany te nie są jeszcze uwzględnione.\n# dodajemy plik README.md do commita, czyli nowej wersji repo\n# commitami oznaczamy nowe wersje repo\ngit add README.md\n\n# jeśli chcemy dodać więcej plików i katalogów jednocześnie (a tak się dzieje najczęściej)\n# bo chcemy commitować stan po zmianach w repo to wywołujemy\ngit add .\nPo tej czynności możemy sprawdzić status repo za pomocą\ngit status\nWynik tych działań jest następujący\n\n\n\nRepo po zmianach\n\n\nJak widać plik README.md został dodany do tymczasowego stanu repo ale nie został on jeszcze przesłany na serwer. Widać też, że żaden commit nie został utworzony. Przez commit rozumiemy jakby snapshot obecnego stanu repo. Póki go nie wypchniemy na serwer zmiany te są zapisane jedynie lokalnie. Przejdźmy do pierwszego commitu naszego repo. Każdy commit powinien być opatrzony komentarzem, który informuje nas co zmieniliśmy w repo3. Flaga -m oznacza chęć dodania komentarza.\n3 wprawdzie na tym etapie dodaliśmy plik README.md ale ponieważ jest to pierwszy commit to tak go nazwaliśmy.git commit -m \"pierwszy commit\"\nPo wykonaniu commita i sprawdzeniu stanu\n\nChoć stworzyliśmy commita, więc zapisaliśmy stan repo po zmianach, to zmiany te nie zostały zaktualizowane na serwerze GitHub. Aby tego dokonać musimy podać adres repo zdalnego oraz wypchnąć lokalne zmiany na serwer.\n# podłączenie zdalnego repo pod nazwą origin\ngit remote add origin \"git@github.com:DariuszMajerek/Github_tests.git\"\n\n\nKomunikacja pomiędzy lokalnym i zdalnym repo\nPozostało nam wypchnąć pliki na serwer.\n# ponieważ wypychamy główną gałąź nazwaną main to komenda jest następująca\ngit push -u origin main\nUstawienie flagi -u w poleceniu git push ustawia tzw upstream. W przyszłości jeśli chcemy wypchnąć stan repo lokalnego wystarczy komenda git push bez origin i main o ile chcemy wysłać wszystko do tej samej gałęzi.\nW momencie wywołania tej komendy będziemy prawdopodobnie poproszeni o hasło do konta GitHub. Jeśli się wszystko powiedzie, to ekran powinien wyglądać następująco.\n\n\n\nREADME.md dodane do repo zdalnego\n\n\nI faktycznie w repo zdalnym się to znajduje\n\n\n\nUwaga: w kolejnej próbie (bo pierwsza się nie udała) dodałem commit z inną nazwą “first commit”\n\n\nPo dodaniu commita i push do gałęzi głównej main stan repo lokalnego (na dysku komputera) i zdalnego są identyczne.\n\nJeśli chcemy pobrać obecny stan repo na dysk lokalny, wówczas używamy komendy git pull remote_name branch_name, gdzie remote_name oznacza adres zdalnego repo, a branch_name nazwę gałęzi jaką chcemy pobrać (w tym momencie nasze repo posiada tylko jedną gałąź ale w przyszłości może mieć ich więcej).\n\n\n\n\n\n\nWażne\n\n\n\nBardzo ważną zasadą jest to aby repo zdalne i lokalne były identyczne. Dbać o to będzie sam git. Natomiast jeśli zaczynamy pracować nad rozwojem repo, dobrą praktyką jest najpierw pobranie obecnego stanu repo zdalnego przez komendę git pull.\n\n\nMoże się również zdarzyć, że współpracownicy, którzy pracują równolegle nad naszym projektem mogą dokonać zmiany zdalnego repo i wówczas pobranie obecnego stanu repo zdalnego jest niemal zawsze konieczne.\nPonieważ zmian w repo zdalnym można dokonywać za pomocą przeglądarki i strony GitHub, to dokonamy rozwinięcia README.md. Zmiany dokonywane na serwerze (poprzez stronę internetową) wymagają również commitowania zmian, tak abyśmy mogli kontrolować wersję naszego repo. W pliku README.md dodałem jedno zdanie o treści “To repozytarium będzie służyć do ćwiczeń związanych z usługami kontroli wersji.” i commitowałem to z komentarzem “Update README.md”.\n\nTo jest stan najbardziej aktualny naszego repo. Dlatego pobierzemy go na dysk aby repo lokalne i zdalne się zgadzały.\n# pobieramy aktualny stan repo zdalnego\n# ponieważ mamy tylko jedną gałąź a origin jest ustawione na właściwe repo\n# ponadto ustawiliśmy wcześniej flagę przy push -u to nie musimy dodawać innych parametrów\ngit pull\n\n\n\nEfekt działania git pull\n\n\nCzujne oko pewnie już zauważyło, że w pliku README.md wpisując zdanie popełniłem błąd (literówkę) w słowie repozytorium. Ponieważ plik mamy pobrany do lokalnego repo, to możemy go poprawić (lokalnie np. w RStudio) i wypchnąć na serwer. Po zmianach lokalnego repo stan jest następujący\n\nJak widać część zmian nie została commitowana. Zmiany dokonane lokalnie najpierw trzeba dodać do tzw Stage, a następnie je commitować.\ngit add . # dodajemy zmiany do Stage\ngit status # po to by zobaczyć stan Stage\ngit commit -m \"Fix typo in README.md\"\ngit stage\n\n# podobnie przy wypychaniu jeśli chcemy wypchnąć do gałęzi głównej\n# to nie musimy dodawać parametrów przy git push\ngit push\n\n\n\nStan po wypchnięciu danych na serwer\n\n\nZmiany na serwerze zostały zapisane.\n\n\n\n\n\n\n\nAdnotacja\n\n\n\nPolecenie git pull jest połączeniem git fetch, które pobiera ostatnie zatwierdzenia w lokalnym repozytorium i git merge, które połączy gałąź ze zdalnej do lokalnej gałęzi.",
    "crumbs": [
      "Wykład 1"
    ]
  },
  {
    "objectID": "wyk5.html",
    "href": "wyk5.html",
    "title": "Wykład 5",
    "section": "",
    "text": "Wykresy interaktywne\nTworzenie interaktywnych wykresów w Shiny jest kluczowym elementem budowy aplikacji, które dynamicznie prezentują dane i umożliwiają użytkownikom interakcję z wygenerowanymi wizualizacjami. Interaktywne wykresy w Shiny pozwalają na tworzenie bardziej angażujących i intuicyjnych interfejsów dla analizy danych, oferując użytkownikom możliwość eksploracji danych w czasie rzeczywistym. Poniżej przedstawiono szczegóły techniczne dotyczące podstaw tworzenia interaktywnych wykresów w Shiny, wraz z przykładami zastosowań.\nPodstawą do tworzenia interaktywnych wykresów w Shiny jest połączenie reaktywności aplikacji z możliwościami bibliotek do tworzenia wykresów. Do najpopularniejszych bibliotek wykorzystywanych w Shiny należą ggplot2 dla statycznych wykresów oraz plotly i highcharter dla interaktywnych wizualizacji. Wykorzystując te narzędzia, można tworzyć wykresy, które aktualizują się automatycznie w odpowiedzi na działania użytkownika, takie jak zmiana parametrów zapytania czy wybór konkretnych danych do analizy.\nInteraktywność wykresów osiąga się poprzez zastosowanie reaktywnych wyrażeń w kodzie serwera Shiny. Reaktywne wyrażenia monitorują zmiany w danych wejściowych (np. suwaki, pola wyboru) i automatycznie aktualizują wykresy, zapewniając dynamiczną prezentację danych. Przykładowo, użycie renderPlot z ggplot2 pozwala na generowanie wykresów, które reagują na zmiany danych wejściowych, podczas gdy plotly::renderPlotly służy do tworzenia interaktywnych wizualizacji z dodatkowymi funkcjami jak tooltipy czy możliwość zoomowania.\n\nKodlibrary(quantmod)\nlibrary(highcharter)\n\nx &lt;- getSymbols(\"GOOG\", auto.assign = FALSE)\ny &lt;- getSymbols(\"AMZN\", auto.assign = FALSE)\n\nhighchart(type = \"stock\") |&gt; \n  hc_add_series(x) |&gt; \n  hc_add_series(y, type = \"ohlc\")\n\n\n\n\n\n\nRys. 1: Przykład wykresu interaktywnego stosując pakiet highcharter\n\n\n\nInteraktywność w Shiny jest kluczową cechą, która odróżnia te aplikacje od statycznych raportów i wizualizacji danych. Umożliwia ona użytkownikom bezpośrednią interakcję z danymi na wykresie, otwierając szeroki zakres możliwości aplikacji - od prostych analiz po zaawansowane eksploracje danych.\n\nKoddf &lt;- data.frame(\n  stringsAsFactors = FALSE,\n  name = c(\n    \"The Left\",\n    \"Social Democratic Party\",\n    \"Alliance 90/The Greens\",\n    \"Free Democratic Party\",\n    \"Christian Democratic Union\",\n    \"Christian Social Union in Bavaria\",\n    \"Alternative for Germany\"\n  ),\n  count = c(69, 153, 67, 80, 200, 46, 94),\n  col = c(\"#BE3075\", \"#EB001F\", \"#64A12D\", \"#FFED00\",\n          \"#000000\", \"#008AC5\", \"#009EE0\"\n  ),\n  abbrv = c(\"DIE LINKE\", \"SPD\", \"GRÜNE\", \"FDP\", \"CDU\", \"CSU\", \"AfD\")\n)\n\nhchart(\n  df,\n  \"item\",\n  hcaes(\n    name = name,\n    y = count,\n    label = abbrv,\n    color = col\n  ),\n  name = \"Representatives\",\n  showInLegend = TRUE,\n  size = \"100%\",\n  center = list(\"50%\", \"75%\"),\n  startAngle = -100,\n  endAngle  = 100\n) %&gt;%\n  hc_title(text = \"Item chart with different layout\") %&gt;%\n  hc_legend(labelFormat = '{name} &lt;span style=\"opacity: 0.4\"&gt;{y}&lt;/span&gt;')\n\n\n\n\n\n\nRys. 2: Inny przykład interaktywności wykresu w highcharter\n\n\n\n\nKodlibrary(dplyr)\nlibrary(forcats)\nlibrary(purrr)\nlibrary(stringr)\npkmn_min &lt;- pokemon |&gt;\n  count(type_1, color = type_1_color) |&gt;\n  mutate(type_1 = fct_reorder(type_1, .x = n)) |&gt;\n  arrange(desc(type_1))\n\npkmn_ddn &lt;- pokemon |&gt;\n  count(type_1, type_2, color = type_mix_color) |&gt;\n  arrange(type_1, desc(n)) |&gt;\n  mutate(type_2 = ifelse(is.na(type_2), str_c(\"only \", type_1), type_2)) |&gt;\n  group_nest(type_1) |&gt;\n  mutate(\n    id = type_1,\n    type = \"column\",\n    # in the drilldown we'll give the mapping via creating the columns\n    data = map(data, mutate, name = type_2, y  = n),\n    data = map(data, list_parse)\n  )\n\nhchart(\n  pkmn_min,\n  type = \"column\",\n  hcaes(x = type_1, y = n, color = color, drilldown = type_1),\n  name = \"Pokémons\"\n  ) |&gt;\n  hc_drilldown(\n    activeAxisLabelStyle = list(textDecoration = \"none\"),\n    allowPointDrilldown = TRUE,\n    series = list_parse(pkmn_ddn)\n  ) |&gt;\n  hc_yAxis(\n    title = list(text = \"\"),\n    endOnTick = FALSE,\n    opposite = TRUE\n    ) |&gt;\n  hc_xAxis(\n    title = list(text = \"\"),\n    endOnTick = FALSE,\n    gridLineWidth = 0,\n    tickWidth = 0\n    ) |&gt;\n  hc_chart(\n    style = list(fontFamily = \"Gloria Hallelujah\")\n  )\n\n\n\n\n\n\nRys. 3: Ciekawy przykład interaktywności wykresu w highcharter\n\n\n\nPodstawy Interaktywności\nW Shiny, interaktywność z wykresami jest możliwa dzięki wykorzystaniu plotOutput(), który nie tylko wyświetla wykresy, ale również może reagować na zdarzenia generowane przez wskaźnik myszy, takie jak kliknięcie, podwójne kliknięcie, najechanie kursorem (ang. hover) czy zaznaczenie obszaru (ang. brush). Aby przekształcić te zdarzenia w dane wejściowe dla Shiny, wystarczy przekazać odpowiedni ciąg znaków do argumentu plotOutput(), np. plotOutput(\"plot\", click = \"plot_click\"). Tworzy to obiekt input$plot_click, który można wykorzystać do obsługi kliknięć na wykresie.\nKlikanie i zaznaczanie\n\nKlikanie - głównym zdarzeniem jest kliknięcie myszą, które zwraca bogatą listę informacji, w tym lokalizację zdarzenia w koordynatach danych. Shiny oferuje pomocnika nearPoints(), który ułatwia identyfikację danych bliskich miejscu kliknięcia, zajmując się szczegółami technicznymi.\nPodwójne kliknięcie i najechanie kursorem - podobne do kliknięcia, te zdarzenia można wykorzystać do różnych interakcji, np. wyświetlenia dodatkowych informacji o punkcie danych lub wyróżnienia go na wykresie.\nZaznaczenie obszaru (brushing) - pozwala na wybór wielu punktów danych za pomocą prostokątnego narzędzia zaznaczającego. Użytkowanie brushedPoints() umożliwia obsługę danych zaznaczonych przez użytkownika.\n\nPrzykład prostego obsługiwania kliknięcia myszą\nZarejestrowanie zdarzenia kliknięcia i aktualizacja innego elementu wyjściowego za pomocą koordynatów miejsca kliknięcia pokazuje, jak można dynamicznie reagować na interakcje użytkownika z danymi.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja interfejsu użytkownika\nui &lt;- fluidPage(\n  titlePanel(\"Interaktywny wykres w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Kliknij na wykresie, aby uzyskać koordynaty punktu.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", click = \"plot_click\"), # Wykres reagujący na kliknięcia\n      verbatimTextOutput(\"info\") # Wyświetlanie informacji o kliknięciu\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$info &lt;- renderPrint({\n    req(input$plot_click) # Zapewnienie, że kliknięcie miało miejsce\n    info &lt;- input$plot_click\n    paste(\"Kliknięto w punkt: x =\", round(info$x, 2), \"y =\", round(info$y, 2))\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\n\n\n\n\n\n\nWażne\n\n\n\nUżycie req() jest po to, aby upewnić się, że aplikacja nie zrobi nic przed pierwszym kliknięciem, oraz że współrzędne są w zakresach bazowych zmiennych wt i mpg.\n\n\nWywołanie tej aplikacji i kliknięcie daje następujący rezultat:\n\n\n\n\n\nRys. 4\n\n\nCiekawą modyfikacją powyższego przykładu mogłoby być użycie funkcji nearPoints w funkcji serwera. Wówczas klikając blisko pewnych punktów1 otrzymamy tabelę punktów leżących blisko punktu kliknięcia.\n1 promień tego obszaru można modyfikować\nKod# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$data &lt;- renderTable({\n    # Zapewnienie, że kliknięcie miało miejsce\n    req(input$plot_click)\n    \n    # Użycie nearPoints do znalezienia punktów blisko kliknięcia\n    near_points &lt;- nearPoints(mtcars, input$plot_click, threshold = 50, maxpoints = 1, xvar = \"wt\", yvar = \"mpg\")\n    \n    # Zwrócenie znalezionych punktów\n    if (nrow(near_points) &gt; 0) {\n      near_points\n    } else {\n      data.frame() # Pusta ramka danych, jeśli nie znaleziono żadnych punktów\n    }\n  })\n}\n\n\nInnym sposobem wykorzystania interaktywności jest funkcja hover, która pozwala na wyświetlanie danych po najechaniu kursorem nad punkt na wykresie.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja UI\nui &lt;- fluidPage(\n  titlePanel(\"Interaktywność z hover w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Najedź myszą na punkty na wykresie, aby zobaczyć szczegóły.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", hover = hoverOpts(id=\"plot_hover\", delay = 100, delayType = \"debounce\")), # Wykres z obsługą hover\n      verbatimTextOutput(\"info\") # Miejsce na informacje o punkcie\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$info &lt;- renderPrint({\n    hover &lt;- input$plot_hover\n    if (!is.null(hover)) {\n      near_points &lt;- nearPoints(mtcars, hover, threshold = 5, maxpoints = 1, addDist = TRUE)\n      if (nrow(near_points) &gt; 0) {\n        cat(\"Waga: \", near_points$wt, \"\\nMile na galon: \", near_points$mpg)\n      } else {\n        \"Nie wykryto punktu.\"\n      }\n    }\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nWynik działania tej aplikacji jest następujący:\n\nPoniżej znajdziesz przykład aplikacji Shiny, która wykorzystuje funkcję brush (czyli zaznaczanie obszaru) do wyboru punktów na wykresie. Użytkownicy mogą zaznaczać obszar na wykresie, a aplikacja wyświetli dane dotyczące punktów znajdujących się w zaznaczonym obszarze.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja UI\nui &lt;- fluidPage(\n  titlePanel(\"Wykorzystanie Brush w Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Zaznacz obszar na wykresie, aby zobaczyć szczegóły punktów.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", brush = \"plot_brush\"), # Wykres z obsługą brush\n      tableOutput(\"selected_data\") # Tabela wyświetlająca zaznaczone dane\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  output$plot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point() +\n      theme_minimal()\n  })\n  \n  output$selected_data &lt;- renderTable({\n    brush &lt;- input$plot_brush\n    if (!is.null(brush)) {\n      # Użycie brushedPoints do znalezienia punktów w zaznaczonym obszarze\n      brushed_points &lt;- brushedPoints(mtcars, brush)\n      if (nrow(brushed_points) &gt; 0) {\n        brushed_points\n      } else {\n        data.frame() # Pusta ramka danych, jeśli nie znaleziono żadnych punktów\n      }\n    }\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nW tej aplikacji:\n\n\nplotOutput(\"plot\", brush = \"plot_brush\") tworzy obszar wykresu, który pozwala użytkownikom na zaznaczanie obszaru przy użyciu myszy. Zaznaczenie jest przekazywane do Shiny jako obiekt brush, który zawiera informacje o zaznaczonym obszarze.\n\nrenderPlot({ ... }) generuje wykres punktowy dla danych mtcars za pomocą ggplot2.\n\nrenderTable({ ... }) wykorzystuje brushedPoints do identyfikacji i wyświetlenia punktów danych, które znajdują się w obrębie zaznaczonego obszaru. Funkcja ta automatycznie filtruje dane z mtcars do tych, które mieszczą się w zaznaczonym obszarze, i wyświetla je w formie tabeli.\n\nTa aplikacja Shiny pokazuje, jak można efektywnie użyć funkcji brush do interaktywnej eksploracji danych na wykresie, dając użytkownikom możliwość zaznaczania i analizowania konkretnych obszarów danych.\n\n\n\n\n\nRys. 5\n\n\nModyfikowanie wykresu\nPrawdziwa moc interaktywności ujawnia się, gdy zmiany wynikające z interakcji użytkownika są odzwierciedlane bezpośrednio na tym samym wykresie, z którym wchodzą w interakcję. Jest to możliwe dzięki zaawansowanym technikom reaktywności w Shiny, takim jak reactiveVal(), które umożliwiają tworzenie dynamicznych i interaktywnych wizualizacji, które reagują na działania użytkownika w czasie rzeczywistym.\nModyfikowanie wykresu w czasie rzeczywistym w odpowiedzi na interakcje użytkownika jest zaawansowaną techniką w aplikacjach Shiny, która znacząco zwiększa interaktywność i użyteczność aplikacji. Pozwala to na dynamiczną zmianę wyglądu wykresu, np. w zależności od danych wybranych przez użytkownika lub w odpowiedzi na inne działania, takie jak kliknięcie czy zaznaczenie obszaru. Poniżej przedstawiono przykład aplikacji Shiny, która ilustruje, jak można modyfikować wykres w odpowiedzi na interakcję z użytkownikiem za pomocą techniki brush.\nPrzykład\nW tym przykładzie użytkownik może zaznaczyć obszar na wykresie punktowym, a aplikacja zaznaczy punkty w obrębie tego obszaru, zmieniając ich kolor. Dodatkowo, po zaznaczeniu obszaru, wyświetlona zostanie tylko część danych odpowiadająca zaznaczonym punktom, co pozwala na szczegółową analizę fragmentu zbioru danych.\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\n# Definicja UI\nui &lt;- fluidPage(\n  titlePanel(\"Modyfikowanie wykresu poprzez brushing\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Zaznacz obszar na wykresie, aby zmienić kolor punktów.\")\n    ),\n    mainPanel(\n      plotOutput(\"plot\", brush = \"plot_brush\") # Wykres z obsługą brush\n    )\n  )\n)\n\n# Definicja serwera\nserver &lt;- function(input, output, session) {\n  # Zmienna reaktywna przechowująca zaznaczone punkty\n  selected_points &lt;- reactiveVal(data.frame(wt = numeric(), mpg = numeric()))\n  \n  observe({\n    brush &lt;- input$plot_brush\n    if (!is.null(brush)) {\n      # Użycie brushedPoints do znalezienia punktów w zaznaczonym obszarze\n      brushed_points &lt;- brushedPoints(mtcars, brush)\n      selected_points(brushed_points) # Aktualizacja zaznaczonych punktów\n    }\n  })\n  \n  output$plot &lt;- renderPlot({\n    # Tworzenie wykresu z zaznaczonymi punktami w innym kolorze\n    ggplot(mtcars, aes(x = wt, y = mpg)) +\n      geom_point(aes(color = ifelse(row.names(mtcars) %in% row.names(selected_points()), \"Zaznaczone\", \"Nie zaznaczone\")),\n                 show.legend = FALSE) +\n      scale_color_manual(values = c(\"Zaznaczone\" = \"red\", \"Nie zaznaczone\" = \"black\")) +\n      theme_minimal()\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nW tej aplikacji:\n\nZmienna reaktywna selected_points przechowuje dane o punktach zaznaczonych przez użytkownika.\nObserwator (observe({ ... })) aktualizuje selected_points za każdym razem, gdy użytkownik zaznacza nowy obszar na wykresie.\nrenderPlot({ ... }) tworzy wykres, na którym punkty są kolorowane różnie w zależności od tego, czy znajdują się w zaznaczonym obszarze. Funkcja ifelse wewnątrz aes zmienia kolor punktów na czerwony, jeśli są zaznaczone, pozostawiając pozostałe punkty czarne.\n\nWynik działania jest następujący:\n\n\n\n\n\nRys. 6\n\n\nWysokość i szerokość dynamiczna\nDynamiczna zmiana wysokości i szerokości wykresów w aplikacjach Shiny to zaawansowana funkcjonalność, która pozwala aplikacjom lepiej dostosować się do różnych urządzeń i rozmiarów ekranu użytkowników, jak również reagować na zmiany w interfejsie użytkownika, takie jak zmiany w układzie paneli czy rozwijane menu, które mogą zmieniać dostępną przestrzeń dla wykresów.\nAby umożliwić dynamiczną zmianę rozmiaru wykresów, Shiny oferuje możliwość przekazania funkcji bezargumentowych do argumentów width i height w renderPlot(). Te funkcje powinny zwracać wartości liczbowe, reprezentujące szerokość i wysokość wykresu w pikselach. Kluczowym aspektem jest to, że funkcje te są wykonywane w środowisku reaktywnym, co oznacza, że mogą dostosowywać rozmiar wykresu w odpowiedzi na zmiany w aplikacji.\nPoniżej znajduje się przykładowy kod, ilustrujący sposób dynamicznego dostosowywania rozmiarów wykresu w aplikacji Shiny:\n\nKodlibrary(shiny)\nlibrary(ggplot2)\n\nui &lt;- fluidPage(\n  sliderInput(\"height\", \"Wysokość wykresu\", min = 200, max = 600, value = 400),\n  sliderInput(\"width\", \"Szerokość wykresu\", min = 200, max = 600, value = 400),\n  plotOutput(\"dynamicPlot\", width = \"auto\", height = \"auto\")\n)\n\nserver &lt;- function(input, output) {\n  output$dynamicPlot &lt;- renderPlot({\n    ggplot(mtcars, aes(x = mpg, y = disp)) + geom_point()\n  }, width = function() { input$width }, height = function() { input$height })\n}\n\nshinyApp(ui = ui, server = server)\n\n\nW tym przykładzie, suwaki umożliwiają użytkownikowi dynamiczne zmienianie wysokości i szerokości wykresu. Funkcje przekazane do width i height w renderPlot() wykorzystują wartości z inputów input$width i input$height do określenia rozmiarów wykresu, umożliwiając w ten sposób dynamiczną reakcję na akcje użytkownika.\n\n\n\n\n\nRys. 7\n\n\nZastosowania\nDynamiczna zmiana rozmiarów wykresów ma szerokie zastosowanie, szczególnie w przypadku:\n\nAdaptacyjnych interfejsów użytkownika - gdzie wykresy muszą dostosowywać się do różnych rozmiarów ekranu, w tym urządzeń mobilnych.\nInteraktywnych dashboardów - pozwalając użytkownikom na personalizację układu i rozmiarów wyświetlanych elementów.\nAplikacji analitycznych - gdzie złożoność danych wymaga elastyczności w prezentacji wyników, aby umożliwić dokładniejszą analizę.\n\nDynamiczne dostosowywanie rozmiaru wykresów znacząco podnosi użyteczność aplikacji Shiny, poprawiając interakcję użytkownika i dostosowanie do różnorodnych scenariuszy użytkowania.\nWyświetlanie obrazów\nWyświetlanie obrazów w aplikacjach Shiny jest kolejną istotną funkcjonalnością, która rozszerza możliwości interaktywnych aplikacji o prezentację zasobów graficznych. Może to obejmować wyświetlanie zdjęć, diagramów, schematów, czy też dynamicznie generowanych wizualizacji. Funkcja renderImage() w Shiny pozwala na łatwe włączenie obrazów do aplikacji, umożliwiając interaktywne ich eksplorowanie oraz dynamiczną zmianę w zależności od akcji użytkownika.\nFunkcja renderImage() jest używana na serwerze aplikacji Shiny do określenia, jak obrazy mają być renderowane i wysyłane do interfejsu użytkownika. Aby wyświetlić obraz, renderImage() musi zwrócić listę zawierającą co najmniej ścieżkę do obrazu (src), a opcjonalnie inne parametry takie jak typ MIME (contentType), szerokość (width), wysokość (height) oraz dodatkowe atrybuty HTML, które zostaną dodane do znacznika &lt;img&gt;.\nPrzykład\nPoniżej znajduje się przykład aplikacji Shiny, która wykorzystuje renderImage() do wyświetlania obrazów w zależności od wyboru użytkownika:\n\nKodlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Wyświetlanie obrazów w Shiny\"),\n  selectInput(\"imageChoice\", \"Wybierz obraz:\", choices = c(\"Screen 1\", \"Screen 2\")),\n  imageOutput(\"selectedImage\")\n)\n\nserver &lt;- function(input, output) {\n  output$selectedImage &lt;- renderImage({\n    # Ścieżki do obrazów\n    imagePath &lt;- switch(input$imageChoice,\n                        \"Screen 1\" = \"~/Desktop/Pollub/wyklady/ModelDeployment/images/Zrzut ekranu 2024-01-20 o 16.41.52.png\",\n                        \"Screen 2\" = \"~/Desktop/Pollub/wyklady/ModelDeployment/images/Zrzut ekranu 2024-01-20 o 16.43.24.png\")\n    \n    # Zwracanie listy z informacjami o obrazie\n    list(src = imagePath,\n         contentType = \"image/jpeg\",\n         width = 400, # Można dostosować\n         height = \"auto\")\n  }, deleteFile = FALSE) # Ustawienie na FALSE, jeśli obrazy nie są tymczasowe\n}\n\nshinyApp(ui = ui, server = server)\n\n\nW tym przykładzie użytkownik może wybrać między dwoma obrazami za pomocą menu rozwijanego. Wybrany obraz jest następnie wyświetlany na stronie dzięki renderImage(), która dynamicznie zwraca właściwy obraz na podstawie wyboru użytkownika.\nWyświetlanie obrazów ma szerokie zastosowanie w aplikacjach Shiny, od prostego pokazywania zdjęć po zaawansowane zastosowania takie jak:\n\nGalerie zdjęć - umożliwiają użytkownikom przeglądanie kolekcji obrazów.\nInstrukcje i schematy - pomagają wizualizować kroki procesów lub detale konstrukcyjne.\nWizualizacje danych - prezentują skomplikowane analizy danych lub wyniki symulacji w formie graficznej.\n\nKluczowym aspektem jest to, że renderImage() zapewnia elastyczność i kontrolę nad sposobem prezentacji obrazów, co pozwala na tworzenie bardziej interaktywnych i angażujących aplikacji Shiny.\nOgraniczenia interaktywności\nOgraniczenia interaktywności w aplikacjach Shiny wynikają głównie z podstawowego przepływu danych i architektury aplikacji. Rozumienie tych ograniczeń jest kluczowe do efektywnego projektowania i optymalizacji interaktywnych aplikacji Shiny. Oto głębsze spojrzenie na ograniczenia interaktywności, szczególnie w kontekście wykresów interaktywnych:\n\nOpóźnienia w interakcji\n\n\nPrzetwarzanie po stronie serwera - wszystkie interakcje użytkownika z wykresami interaktywnymi w Shiny są przetwarzane po stronie serwera. Oznacza to, że zdarzenia, takie jak kliknięcia myszką czy zaznaczanie obszaru, muszą być najpierw przesłane do serwera, przetworzone przez R, a następnie wyniki muszą być wysłane z powrotem do klienta. Ten przepływ może prowadzić do opóźnień, zwłaszcza w aplikacjach hostowanych zdalnie.\nPrzesyłanie danych - dla aplikacji hostowanych, czas potrzebny na przesyłanie zdarzeń od klienta do serwera i z powrotem może wpływać na responsywność aplikacji. Opóźnienia te mogą być szczególnie zauważalne w przypadku wolnych połączeń internetowych.\n\n\nOgraniczenia wydajności\n\n\nZłożoność wykresów - bardziej złożone wykresy z większą ilością punktów danych lub z bardziej skomplikowanymi obliczeniami do ich generowania mogą znacząco obciążać serwer, prowadząc do dłuższego czasu odpowiedzi. Przy każdej interakcji użytkownika wykres musi być ponownie generowany, co może być kosztowne obliczeniowo.\nRównoczesne użytkowanie - aplikacje Shiny mogą doświadczać spadków wydajności podczas obsługi wielu użytkowników jednocześnie, zwłaszcza gdy każdy użytkownik generuje intensywny ruch danych z interaktywnymi wykresami.\n\n\nOgraniczenia skalowalności - skalowanie aplikacji Shiny do obsługi dużej liczby użytkowników równocześnie, każdego z potencjalnie interaktywnymi wykresami, wymaga znacznych zasobów serwerowych. Może to być wyzwaniem w kontekście zarządzania zasobami i optymalizacji wydajności.\nAlternatywne rozwiązania\n\n\nObliczenia po stronie klienta - w niektórych przypadkach, przeniesienie części obliczeń do przeglądarki klienta za pomocą JavaScript może pomóc zmniejszyć obciążenie serwera i poprawić responsywność aplikacji. Narzędzia takie jak biblioteka plotly czy leaflet dla map oferują bardziej zaawansowane możliwości interaktywne, które działają po stronie klienta.\nAsynchroniczne przetwarzanie - wykorzystanie asynchronicznych wzorców przetwarzania w Shiny (np. przy użyciu future i promises) może poprawić reaktywność aplikacji poprzez umożliwienie serwerowi obsługi innych zadań podczas oczekiwania na zakończenie długotrwałych operacji.\n\nRozumienie i akceptacja tych ograniczeń są kluczowe przy projektowaniu interaktywnych aplikacji Shiny, zwłaszcza tych, które są intensywnie wykorzystywane przez użytkowników lub zawierają skomplikowane wizualizacje danych. Planowanie architektury aplikacji z myślą o tych ograniczeniach może pomóc w tworzeniu bardziej wydajnych i responsywnych rozwiązań.",
    "crumbs": [
      "Wykład 5"
    ]
  },
  {
    "objectID": "wyk6.html",
    "href": "wyk6.html",
    "title": "Wykład 6",
    "section": "",
    "text": "Rozdział będzie dotyczył funkcji upload i download w aplikacjach Shiny w R. Prezentuje on kluczowe informacje dotyczące transferu plików między użytkownikiem a aplikacją. Możliwość przesyłania plików do aplikacji oraz pobierania ich z aplikacji jest ważną funkcjonalnością, pozwalającą na analizę danych przesłanych przez użytkownika oraz udostępnianie wyników tej analizy w formie zbiorów danych lub raportów.\n\nInterfejs użytkownika dla uploadu jest prosty i wymaga dodania funkcji fileInput() do UI aplikacji Shiny. Argumenty id oraz label są obowiązkowe, ale istnieje możliwość dostosowania wyglądu przycisku poprzez argumenty takie jak width, buttonLabel i placeholder.\n\nKodui &lt;- fluidPage(\n  # funkcja ta ma możliwość wczytywania kilku plików jednocześnie \n  # poprzez ustawienie flagi multiple = TRUE\n  fileInput(\"upload\", \"Upload a file\")\n)\n\n\nSerwer uploadu plików w aplikacji Shiny odgrywa kluczową rolę w przetwarzaniu przesłanych danych. Aby obsłużyć przesyłane pliki, konieczne jest zrozumienie struktury danych zwracanej przez fileInput(), a następnie odpowiednie zarządzanie tymi danymi na serwerze.\nPoniżej przedstawiam szczegółowy opis oraz przykład implementacji obsługi uploadu na serwerze w aplikacji Shiny.\n\nfileInput() zwraca ramkę danych z czterema kolumnami:\n\nname - oryginalna nazwa pliku na komputerze użytkownika. Może być używana do wyświetlania nazwy pliku w interfejsie użytkownika lub do logów.\nsize - rozmiar pliku w bajtach. Informacja ta może być używana do walidacji rozmiaru przesłanego pliku.\ntype - typ MIME pliku, który jest formalną specyfikacją typu pliku, zwykle pochodzącą z rozszerzenia. Rzadko wymagana bezpośrednio w aplikacjach Shiny, ale może być przydatna do walidacji typu pliku.\ndatapath - ścieżka do miejsca, gdzie plik został tymczasowo zapisany na serwerze. Jest to kluczowy element, ponieważ to właśnie z tej lokalizacji należy odczytać przesłany plik, aby móc go przetworzyć.\n\nImplementacja na serwerze wymaga użycia funkcji reaktywnej, która będzie nasłuchiwać zmian w input$upload (gdzie upload to identyfikator przypisany do fileInput() w UI). Gdy plik zostanie przesłany, można przetworzyć go zgodnie z potrzebami aplikacji - czy to odczytując dane, walidując plik, czy przeprowadzając inne operacje.\n\n\nKodserver &lt;- function(input, output, session) {\n  # Reaktywna ekspresja do przetwarzania przesłanych plików\n  uploadedData &lt;- reactive({\n    # Wymaga, aby użytkownik przesłał plik\n    req(input$upload)\n    \n    # Odczytanie danych z pliku\n    inFile &lt;- input$upload\n    \n    # Walidacja typu pliku - akceptujemy tylko pliki CSV\n    validTypes &lt;- c(\"text/csv\", \"text/comma-separated-values\", \"application/vnd.ms-excel\")\n    if (!inFile$type %in% validTypes) {\n      stop(\"Nieprawidłowy typ pliku. Proszę przesłać plik CSV.\")\n    }\n    \n    # Przetwarzanie pliku - przykład odczytu pliku CSV\n    tryCatch({\n      read.csv(inFile$datapath)\n    }, error = function(e) {\n      stop(\"Wystąpił błąd podczas odczytu pliku: \", e$message)\n    })\n  })\n  \n  # Wyświetlanie danych z przesłanego pliku\n  output$contents &lt;- renderTable({\n    uploadedData()\n  }, error = function(e) {\n    # Wyświetlenie komunikatu o błędzie, jeśli walidacja lub odczyt się nie powiodą\n    div(style = \"color: red;\", e$message)\n  })\n}\n\n\nSzczegółowe wyjaśnienie wszystkich aspektów tego kodu:\n\nInicjacja reaktywnej ekspresji - uploadedData &lt;- reactive({ ... }) tworzy wyrażenie reaktywne, które aktualizuje się za każdym razem, gdy użytkownik przesyła plik. Wszystkie operacje wewnątrz tej ekspresji zostaną ponownie wykonane, kiedy input$upload zostanie zmieniony (np. gdy użytkownik przesła nowy plik).\nWymaganie przesłania pliku - req(input$upload), gdzie funkcja req() sprawdza, czy jej argumenty są “truthy” (tj. nie są NULL ani nie są puste). Jeśli input$upload jest NULL, co oznacza, że żaden plik nie został jeszcze przesłany, reszta kodu w wyrażeniu reaktywnym nie zostanie wykonana.\nOdczytanie danych z przesłanego pliku - inFile &lt;- input$upload, który zapisuje informacje o przesłanym pliku do zmiennej inFile. input$upload zwraca ramkę danych zawierającą szczegóły przesłanego pliku, takie jak jego nazwa (name), typ MIME (type), rozmiar (size) i ścieżka do tymczasowego pliku na serwerze (datapath).\nWalidacja typu pliku:\n\n\nvalidTypes &lt;- c(\"text/csv\", \"text/comma-separated-values\", \"application/vnd.ms-excel\") - definiuje listę akceptowalnych typów MIME dla przesłanych plików. Lista ta obejmuje typy związane z plikami CSV.\n\nif (!inFile$type %in% validTypes) { stop(\"Nieprawidłowy typ pliku. Proszę przesłać plik CSV.\") } - sprawdza, czy typ MIME przesłanego pliku znajduje się na liście validTypes. Jeśli nie, wykonanie kodu zostaje zatrzymane, a użytkownik otrzymuje komunikat o błędzie.\n\n\nOdczyt pliku i obsługa błędów - tryCatch({ read.csv(inFile$datapath) }, error = function(e) { stop(\"Wystąpił błąd podczas odczytu pliku: \", e$message) }), który próbuje odczytać przesłany plik jako plik CSV. Jeśli podczas odczytu wystąpi błąd, przechwytuje go i generuje komunikat o błędzie. e$message zawiera szczegółowe informacje o błędzie, co pomaga w jego zdiagnozowaniu.\nWyświetlanie danych z przesłanego pliku - output$contents &lt;- renderTable({ uploadedData() }, error = function(e) { div(style = \"color: red;\", e$message) }), która próbuje wyświetlić zawartość przesłanego pliku w formie tabeli. Jeśli w wyrażeniu reaktywnym uploadedData wystąpi błąd (np. z powodu nieprawidłowego typu pliku lub błędu odczytu), błąd ten jest obsługiwany i komunikat o błędzie jest wyświetlany użytkownikowi.\n\nPrzykład aplikacji pozwalającej na upload zbioru z dysku.\n\nKodlibrary(shiny)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Przesyłanie pliku w aplikacji Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"file1\", \"Wybierz plik CSV:\",\n                accept = c(\"text/csv\", \n                           \"text/comma-separated-values,text/plain\", \n                           \".csv\")),\n      tags$hr(),\n      checkboxInput(\"header\", \"Czy plik zawiera nagłówek?\", TRUE),\n      radioButtons(\"sep\", \"Separator:\",\n                   choices = c(Komma = \",\", Średnik = \";\", Tabulacja = \"\\t\"),\n                   selected = \",\")\n    ),\n    mainPanel(\n      tableOutput(\"contents\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    # Sprawdzenie, czy plik został przesłany\n    req(input$file1)\n    \n    # Odczytanie pliku\n    inFile &lt;- input$file1\n    \n    # Odczytanie danych z przesłanego pliku\n    read.csv(inFile$datapath, header = input$header, sep = input$sep)\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nWynikiem jej działania jest:\n\n\n\n\n\nRys. 1\n\n\n\nCzęść dotycząca downloadu w aplikacji Shiny umożliwia użytkownikom pobieranie danych lub raportów bezpośrednio z aplikacji. Aby to umożliwić, Shiny oferuje funkcje downloadButton() lub downloadLink() do interfejsu użytkownika (UI) oraz downloadHandler() do logiki serwera. Poniżej rozwinę koncept na przykładzie aplikacji, która pozwala użytkownikom pobierać wygenerowany na podstawie danych wejściowych plik CSV.\n\nW interfejsie użytkownika dodajesz element, który użytkownik może kliknąć, aby zainicjować pobieranie. Może to być przycisk lub link. Przykładowo:\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Pobieranie danych z aplikacji Shiny\"),\n  downloadButton(\"downloadData\", \"Pobierz Dane\")\n)\n\n\nW powyższym przykładzie downloadButton() tworzy przycisk z identyfikatorem \"downloadData\" i etykietą \"Pobierz Dane\".\n\nNa serwerze definiujesz, co się stanie, gdy użytkownik kliknie przycisk pobierania. Używasz do tego downloadHandler(), który pozwala określić nazwę pliku oraz sposób generowania zawartości pliku.\n\nKodserver &lt;- function(input, output) {\n  output$downloadData &lt;- downloadHandler(\n    filename = function() {\n      paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(mtcars, file)\n    }\n  )\n}\n\n\nW tym przykładzie, gdy użytkownik kliknie przycisk pobierania:\n\n\nfilename - funkcja ta generuje nazwę pliku, która zawiera datę pobrania. Umożliwia to uniknięcie nadpisania plików przy wielokrotnym pobieraniu.\n\ncontent - w funkcji tej określasz, jakie dane zostaną zapisane do pliku. W przykładzie użyto wbudowanego zbioru danych mtcars, który jest zapisywany do pliku CSV poprzez write.csv. Zmienna file reprezentuje tymczasową ścieżkę pliku, do której dane mają być zapisane.\n\nŁącząc obie części, otrzymujemy pełny kod aplikacji, która umożliwia pobieranie pliku CSV z danymi mtcars:\n\nKodlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Pobieranie danych z aplikacji Shiny\"),\n  downloadButton(\"downloadData\", \"Pobierz Dane\")\n)\n\nserver &lt;- function(input, output) {\n  output$downloadData &lt;- downloadHandler(\n    filename = function() {\n      paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(mtcars, file)\n    }\n  )\n}\n\nshinyApp(ui = ui, server = server)\n\n\nTen prosty przykład demonstruje, jak zaimplementować funkcjonalność pobierania w aplikacji Shiny. Możesz modyfikować logikę wewnątrz downloadHandler() aby dostosować dane wyjściowe do potrzeb użytkowników, np. generując raporty w formacie PDF za pomocą pakietu rmarkdown lub dostosowując zbiór danych do wybranych przez użytkownika kryteriów.\n\nFunkcjonalność pobierania raportów w aplikacjach Shiny otwiera nowe możliwości dla twórców aplikacji oraz ich użytkowników, umożliwiając generowanie spersonalizowanych raportów na podstawie interaktywnej eksploracji danych. Kluczowym narzędziem wykorzystywanym do tego celu jest RMarkdown, który pozwala na tworzenie dynamicznych dokumentów z wykorzystaniem parametryzacji1.\n1 więcej na ten temat można znaleźć pod https://shiny.rstudio.com/articles/generating-reports.html\nRaporty generowane za pomocą RMarkdown mogą przyjmować parametry, co umożliwia dostosowanie zawartości raportu do potrzeb użytkownika. W metadanych YAML dokumentu RMarkdown definiuje się pola params, które mogą być następnie wykorzystywane w dokumencie do dynamicznego generowania treści. Parametry te mogą być przekazywane do dokumentu RMarkdown bezpośrednio z aplikacji Shiny za pomocą funkcji rmarkdown::render(), co pozwala na tworzenie zindywidualizowanych raportów dla różnych użytkowników lub zapytań.\ntitle: My Document\noutput: html_document\nparams:\n  year: 2018\n  region: Europe\n  printcode: TRUE\n  data: file.csv\n\n\nKodui &lt;- fluidPage(\n  sliderInput(\"n\", \"Number of points\", 1, 100, 50),\n  downloadButton(\"report\", \"Generate report\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$report &lt;- downloadHandler(\n    filename = \"report.html\",\n    content = function(file) {\n      params &lt;- list(n = input$n)\n      \n      id &lt;- showNotification(\n        \"Rendering report...\", \n        duration = NULL, \n        closeButton = FALSE\n      )\n      on.exit(removeNotification(id), add = TRUE)\n\n      rmarkdown::render(\"report.Rmd\", \n        output_file = file,\n        params = params,\n        envir = new.env(parent = globalenv())\n      )\n    }\n  )\n}\n\n\nW podanym przykładzie użytkownik aplikacji Shiny ma możliwość wygenerowania raportu, którego zawartość zależy od liczby punktów wybranej za pomocą suwaka (sliderInput). Po kliknięciu przycisku “Generate report”, aplikacja generuje raport HTML, wykorzystując do tego parametryzowany dokument RMarkdown. Podczas generowania raportu wykorzystywane są następujące praktyki:\n\nwyświetlanie powiadomień - aplikacja informuje użytkownika o trwającym procesie generowania raportu za pomocą powiadomień. Jest to przydatne, ponieważ renderowanie dokumentu RMarkdown może zająć kilka sekund.\npraca z katalogiem tymczasowym - aby uniknąć problemów związanych z lokalizacją plików podczas wdrażania aplikacji (np. na shinyapps.io), raport RMarkdown jest kopiowany do katalogu tymczasowego przed renderowaniem. Dzięki temu unika się problemów związanych z uprawnieniami do plików czy ich lokalizacją.\noddzielenie procesu renderowania - dla większej niezawodności, proces renderowania raportu może być wykonany w oddzielnej sesji R za pomocą pakietu callr. Zapewnia to izolację środowiska renderowania od środowiska aplikacji Shiny, co może przyczynić się do uniknięcia potencjalnych konfliktów.\n\nPakiet shinymeta rozwiązuje problem reproducyjności raportów generowanych na podstawie interaktywnej eksploracji w aplikacjach Shiny. Umożliwia on zapisanie bieżącego stanu aplikacji w taki sposób, aby można było go później odtworzyć i wygenerować identyczny raport. Jest to szczególnie przydatne w aplikacjach, gdzie zachowanie interaktywności idzie w parze z potrzebą reproducyjności wyników analiz.\n\nPrzykład pokazuje, jak zbudować aplikację Shiny, która umożliwia użytkownikom przesłanie własnego pliku danych, przeprowadzenie na nim opcjonalnych transformacji, a następnie pobranie przetworzonych danych w formacie .tsv. Ten proces składa się z kilku kroków, które są zaprezentowane poniżej w sposób bardziej szczegółowy.\n\nPierwszym krokiem jest stworzenie interfejsu umożliwiającego użytkownikowi przesłanie pliku danych. Użytkownik może również określić separator danych (np. przecinek, średnik, tabulator) oraz inne opcje, takie jak liczba wierszy do pominięcia na początku pliku czy liczba wierszy do wyświetlenia w podglądzie.\nPrzykład interfejsu dla uploadu i parsowania pliku:\n\nKodui_upload &lt;- sidebarLayout(\n  sidebarPanel(\n    fileInput(\"file\", \"Data\", buttonLabel = \"Upload...\"),\n    textInput(\"delim\", \"Delimiter (leave blank to guess)\", \"\"),\n    numericInput(\"skip\", \"Rows to skip\", 0, min = 0),\n    numericInput(\"rows\", \"Rows to preview\", 10, min = 1)\n  ),\n  mainPanel(\n    h3(\"Raw data\"),\n    tableOutput(\"preview1\")\n  )\n)\n\n\nNa serwerze plik jest odczytywany z wykorzystaniem podanych przez użytkownika opcji, a następnie wyświetlany jest jego podgląd:\n\nKodraw &lt;- reactive({\n  req(input$file)\n  delim &lt;- if (input$delim == \"\") NULL else input$delim\n  vroom::vroom(input$file$datapath, delim = delim, skip = input$skip)\n})\noutput$preview1 &lt;- renderTable(head(raw(), input$rows))\n\n\n\nDrugi krok umożliwia użytkownikowi wykonanie opcjonalnych transformacji danych, takich jak zmiana nazw kolumn na snake case, usunięcie kolumn o stałej wartości lub pustych kolumn.\nPrzykład interfejsu dla czyszczenia danych:\n\nKodui_clean &lt;- sidebarLayout(\n  sidebarPanel(\n    checkboxInput(\"snake\", \"Rename columns to snake case?\"),\n    checkboxInput(\"constant\", \"Remove constant columns?\"),\n    checkboxInput(\"empty\", \"Remove empty cols?\")\n  ),\n  mainPanel(\n    h3(\"Cleaner data\"),\n    tableOutput(\"preview2\")\n  )\n)\n\n\nLogika serwera przetwarzająca dane zgodnie z wybranymi opcjami:\n\nKodtidied &lt;- reactive({\n  out &lt;- raw()\n  if (input$snake) {\n    names(out) &lt;- janitor::make_clean_names(names(out))\n  }\n  if (input$empty) {\n    out &lt;- janitor::remove_empty(out, \"cols\")\n  }\n  if (input$constant) {\n    out &lt;- janitor::remove_constant(out)\n  }\n  out\n})\noutput$preview2 &lt;- renderTable(head(tidied(), input$rows))\n\n\n\nOstatnim krokiem jest umożliwienie użytkownikowi pobrania przetworzonych danych w formacie .tsv. Do tego celu używany jest downloadButton w interfejsie użytkownika oraz downloadHandler w logice serwera.\nPrzykład interfejsu dla pobierania danych:\n\nKodui_download &lt;- fluidRow(\n  column(width = 12, downloadButton(\"download\", class = \"btn-block\"))\n)\n\n\nImplementacja serwera obsługującego pobieranie:\n\nKodoutput$download &lt;- downloadHandler(\n  filename = function() {\n    paste0(tools::file_path_sans_ext(input$file$name), \".tsv\")\n  },\n  content = function(file) {\n    vroom::vroom_write(tidied(), file, delim = \"\\t\")\n  }\n)\n\n\n\nPrzedstawione case study ilustruje, jak można zbudować kompleksową aplikację Shiny służącą do uploadu, przetwarzania i pobierania danych. Wykorzystanie funkcji reaktywnych pozwala na dynamiczne dostosowanie przepływu danych i interakcji z użytkownikiem, zapewniając jednocześnie, że aplikacja pozostaje responsywna i intuicyjna w obsłudze. Takie podejście sprawdza się w różnych scenariuszach analizy danych, oferując użytkownikom potężne narzędzie do pracy z danymi bez konieczności opuszczania interfejsu aplikacji2.\n\n\n2 cały przykład w postaci aplikacji Shiny można znaleźć pod adresem https://github.com/dax44/ModelsDeployment/blob/master/upload.R",
    "crumbs": [
      "Wykład 6"
    ]
  },
  {
    "objectID": "wyk6.html#upload",
    "href": "wyk6.html#upload",
    "title": "Wykład 6",
    "section": "",
    "text": "Interfejs użytkownika dla uploadu jest prosty i wymaga dodania funkcji fileInput() do UI aplikacji Shiny. Argumenty id oraz label są obowiązkowe, ale istnieje możliwość dostosowania wyglądu przycisku poprzez argumenty takie jak width, buttonLabel i placeholder.\n\nKodui &lt;- fluidPage(\n  # funkcja ta ma możliwość wczytywania kilku plików jednocześnie \n  # poprzez ustawienie flagi multiple = TRUE\n  fileInput(\"upload\", \"Upload a file\")\n)\n\n\nSerwer uploadu plików w aplikacji Shiny odgrywa kluczową rolę w przetwarzaniu przesłanych danych. Aby obsłużyć przesyłane pliki, konieczne jest zrozumienie struktury danych zwracanej przez fileInput(), a następnie odpowiednie zarządzanie tymi danymi na serwerze.\nPoniżej przedstawiam szczegółowy opis oraz przykład implementacji obsługi uploadu na serwerze w aplikacji Shiny.\n\nfileInput() zwraca ramkę danych z czterema kolumnami:\n\nname - oryginalna nazwa pliku na komputerze użytkownika. Może być używana do wyświetlania nazwy pliku w interfejsie użytkownika lub do logów.\nsize - rozmiar pliku w bajtach. Informacja ta może być używana do walidacji rozmiaru przesłanego pliku.\ntype - typ MIME pliku, który jest formalną specyfikacją typu pliku, zwykle pochodzącą z rozszerzenia. Rzadko wymagana bezpośrednio w aplikacjach Shiny, ale może być przydatna do walidacji typu pliku.\ndatapath - ścieżka do miejsca, gdzie plik został tymczasowo zapisany na serwerze. Jest to kluczowy element, ponieważ to właśnie z tej lokalizacji należy odczytać przesłany plik, aby móc go przetworzyć.\n\nImplementacja na serwerze wymaga użycia funkcji reaktywnej, która będzie nasłuchiwać zmian w input$upload (gdzie upload to identyfikator przypisany do fileInput() w UI). Gdy plik zostanie przesłany, można przetworzyć go zgodnie z potrzebami aplikacji - czy to odczytując dane, walidując plik, czy przeprowadzając inne operacje.\n\n\nKodserver &lt;- function(input, output, session) {\n  # Reaktywna ekspresja do przetwarzania przesłanych plików\n  uploadedData &lt;- reactive({\n    # Wymaga, aby użytkownik przesłał plik\n    req(input$upload)\n    \n    # Odczytanie danych z pliku\n    inFile &lt;- input$upload\n    \n    # Walidacja typu pliku - akceptujemy tylko pliki CSV\n    validTypes &lt;- c(\"text/csv\", \"text/comma-separated-values\", \"application/vnd.ms-excel\")\n    if (!inFile$type %in% validTypes) {\n      stop(\"Nieprawidłowy typ pliku. Proszę przesłać plik CSV.\")\n    }\n    \n    # Przetwarzanie pliku - przykład odczytu pliku CSV\n    tryCatch({\n      read.csv(inFile$datapath)\n    }, error = function(e) {\n      stop(\"Wystąpił błąd podczas odczytu pliku: \", e$message)\n    })\n  })\n  \n  # Wyświetlanie danych z przesłanego pliku\n  output$contents &lt;- renderTable({\n    uploadedData()\n  }, error = function(e) {\n    # Wyświetlenie komunikatu o błędzie, jeśli walidacja lub odczyt się nie powiodą\n    div(style = \"color: red;\", e$message)\n  })\n}\n\n\nSzczegółowe wyjaśnienie wszystkich aspektów tego kodu:\n\nInicjacja reaktywnej ekspresji - uploadedData &lt;- reactive({ ... }) tworzy wyrażenie reaktywne, które aktualizuje się za każdym razem, gdy użytkownik przesyła plik. Wszystkie operacje wewnątrz tej ekspresji zostaną ponownie wykonane, kiedy input$upload zostanie zmieniony (np. gdy użytkownik przesła nowy plik).\nWymaganie przesłania pliku - req(input$upload), gdzie funkcja req() sprawdza, czy jej argumenty są “truthy” (tj. nie są NULL ani nie są puste). Jeśli input$upload jest NULL, co oznacza, że żaden plik nie został jeszcze przesłany, reszta kodu w wyrażeniu reaktywnym nie zostanie wykonana.\nOdczytanie danych z przesłanego pliku - inFile &lt;- input$upload, który zapisuje informacje o przesłanym pliku do zmiennej inFile. input$upload zwraca ramkę danych zawierającą szczegóły przesłanego pliku, takie jak jego nazwa (name), typ MIME (type), rozmiar (size) i ścieżka do tymczasowego pliku na serwerze (datapath).\nWalidacja typu pliku:\n\n\nvalidTypes &lt;- c(\"text/csv\", \"text/comma-separated-values\", \"application/vnd.ms-excel\") - definiuje listę akceptowalnych typów MIME dla przesłanych plików. Lista ta obejmuje typy związane z plikami CSV.\n\nif (!inFile$type %in% validTypes) { stop(\"Nieprawidłowy typ pliku. Proszę przesłać plik CSV.\") } - sprawdza, czy typ MIME przesłanego pliku znajduje się na liście validTypes. Jeśli nie, wykonanie kodu zostaje zatrzymane, a użytkownik otrzymuje komunikat o błędzie.\n\n\nOdczyt pliku i obsługa błędów - tryCatch({ read.csv(inFile$datapath) }, error = function(e) { stop(\"Wystąpił błąd podczas odczytu pliku: \", e$message) }), który próbuje odczytać przesłany plik jako plik CSV. Jeśli podczas odczytu wystąpi błąd, przechwytuje go i generuje komunikat o błędzie. e$message zawiera szczegółowe informacje o błędzie, co pomaga w jego zdiagnozowaniu.\nWyświetlanie danych z przesłanego pliku - output$contents &lt;- renderTable({ uploadedData() }, error = function(e) { div(style = \"color: red;\", e$message) }), która próbuje wyświetlić zawartość przesłanego pliku w formie tabeli. Jeśli w wyrażeniu reaktywnym uploadedData wystąpi błąd (np. z powodu nieprawidłowego typu pliku lub błędu odczytu), błąd ten jest obsługiwany i komunikat o błędzie jest wyświetlany użytkownikowi.\n\nPrzykład aplikacji pozwalającej na upload zbioru z dysku.\n\nKodlibrary(shiny)\n\n# UI\nui &lt;- fluidPage(\n  titlePanel(\"Przesyłanie pliku w aplikacji Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      fileInput(\"file1\", \"Wybierz plik CSV:\",\n                accept = c(\"text/csv\", \n                           \"text/comma-separated-values,text/plain\", \n                           \".csv\")),\n      tags$hr(),\n      checkboxInput(\"header\", \"Czy plik zawiera nagłówek?\", TRUE),\n      radioButtons(\"sep\", \"Separator:\",\n                   choices = c(Komma = \",\", Średnik = \";\", Tabulacja = \"\\t\"),\n                   selected = \",\")\n    ),\n    mainPanel(\n      tableOutput(\"contents\")\n    )\n  )\n)\n\n# Server\nserver &lt;- function(input, output) {\n  output$contents &lt;- renderTable({\n    # Sprawdzenie, czy plik został przesłany\n    req(input$file1)\n    \n    # Odczytanie pliku\n    inFile &lt;- input$file1\n    \n    # Odczytanie danych z przesłanego pliku\n    read.csv(inFile$datapath, header = input$header, sep = input$sep)\n  })\n}\n\n# Uruchomienie aplikacji\nshinyApp(ui = ui, server = server)\n\n\nWynikiem jej działania jest:\n\n\n\n\n\nRys. 1",
    "crumbs": [
      "Wykład 6"
    ]
  },
  {
    "objectID": "wyk6.html#download",
    "href": "wyk6.html#download",
    "title": "Wykład 6",
    "section": "",
    "text": "Część dotycząca downloadu w aplikacji Shiny umożliwia użytkownikom pobieranie danych lub raportów bezpośrednio z aplikacji. Aby to umożliwić, Shiny oferuje funkcje downloadButton() lub downloadLink() do interfejsu użytkownika (UI) oraz downloadHandler() do logiki serwera. Poniżej rozwinę koncept na przykładzie aplikacji, która pozwala użytkownikom pobierać wygenerowany na podstawie danych wejściowych plik CSV.\n\nW interfejsie użytkownika dodajesz element, który użytkownik może kliknąć, aby zainicjować pobieranie. Może to być przycisk lub link. Przykładowo:\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Pobieranie danych z aplikacji Shiny\"),\n  downloadButton(\"downloadData\", \"Pobierz Dane\")\n)\n\n\nW powyższym przykładzie downloadButton() tworzy przycisk z identyfikatorem \"downloadData\" i etykietą \"Pobierz Dane\".\n\nNa serwerze definiujesz, co się stanie, gdy użytkownik kliknie przycisk pobierania. Używasz do tego downloadHandler(), który pozwala określić nazwę pliku oraz sposób generowania zawartości pliku.\n\nKodserver &lt;- function(input, output) {\n  output$downloadData &lt;- downloadHandler(\n    filename = function() {\n      paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(mtcars, file)\n    }\n  )\n}\n\n\nW tym przykładzie, gdy użytkownik kliknie przycisk pobierania:\n\n\nfilename - funkcja ta generuje nazwę pliku, która zawiera datę pobrania. Umożliwia to uniknięcie nadpisania plików przy wielokrotnym pobieraniu.\n\ncontent - w funkcji tej określasz, jakie dane zostaną zapisane do pliku. W przykładzie użyto wbudowanego zbioru danych mtcars, który jest zapisywany do pliku CSV poprzez write.csv. Zmienna file reprezentuje tymczasową ścieżkę pliku, do której dane mają być zapisane.\n\nŁącząc obie części, otrzymujemy pełny kod aplikacji, która umożliwia pobieranie pliku CSV z danymi mtcars:\n\nKodlibrary(shiny)\n\nui &lt;- fluidPage(\n  titlePanel(\"Pobieranie danych z aplikacji Shiny\"),\n  downloadButton(\"downloadData\", \"Pobierz Dane\")\n)\n\nserver &lt;- function(input, output) {\n  output$downloadData &lt;- downloadHandler(\n    filename = function() {\n      paste(\"data-\", Sys.Date(), \".csv\", sep=\"\")\n    },\n    content = function(file) {\n      write.csv(mtcars, file)\n    }\n  )\n}\n\nshinyApp(ui = ui, server = server)\n\n\nTen prosty przykład demonstruje, jak zaimplementować funkcjonalność pobierania w aplikacji Shiny. Możesz modyfikować logikę wewnątrz downloadHandler() aby dostosować dane wyjściowe do potrzeb użytkowników, np. generując raporty w formacie PDF za pomocą pakietu rmarkdown lub dostosowując zbiór danych do wybranych przez użytkownika kryteriów.\n\nFunkcjonalność pobierania raportów w aplikacjach Shiny otwiera nowe możliwości dla twórców aplikacji oraz ich użytkowników, umożliwiając generowanie spersonalizowanych raportów na podstawie interaktywnej eksploracji danych. Kluczowym narzędziem wykorzystywanym do tego celu jest RMarkdown, który pozwala na tworzenie dynamicznych dokumentów z wykorzystaniem parametryzacji1.\n1 więcej na ten temat można znaleźć pod https://shiny.rstudio.com/articles/generating-reports.html\nRaporty generowane za pomocą RMarkdown mogą przyjmować parametry, co umożliwia dostosowanie zawartości raportu do potrzeb użytkownika. W metadanych YAML dokumentu RMarkdown definiuje się pola params, które mogą być następnie wykorzystywane w dokumencie do dynamicznego generowania treści. Parametry te mogą być przekazywane do dokumentu RMarkdown bezpośrednio z aplikacji Shiny za pomocą funkcji rmarkdown::render(), co pozwala na tworzenie zindywidualizowanych raportów dla różnych użytkowników lub zapytań.\ntitle: My Document\noutput: html_document\nparams:\n  year: 2018\n  region: Europe\n  printcode: TRUE\n  data: file.csv\n\n\nKodui &lt;- fluidPage(\n  sliderInput(\"n\", \"Number of points\", 1, 100, 50),\n  downloadButton(\"report\", \"Generate report\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$report &lt;- downloadHandler(\n    filename = \"report.html\",\n    content = function(file) {\n      params &lt;- list(n = input$n)\n      \n      id &lt;- showNotification(\n        \"Rendering report...\", \n        duration = NULL, \n        closeButton = FALSE\n      )\n      on.exit(removeNotification(id), add = TRUE)\n\n      rmarkdown::render(\"report.Rmd\", \n        output_file = file,\n        params = params,\n        envir = new.env(parent = globalenv())\n      )\n    }\n  )\n}\n\n\nW podanym przykładzie użytkownik aplikacji Shiny ma możliwość wygenerowania raportu, którego zawartość zależy od liczby punktów wybranej za pomocą suwaka (sliderInput). Po kliknięciu przycisku “Generate report”, aplikacja generuje raport HTML, wykorzystując do tego parametryzowany dokument RMarkdown. Podczas generowania raportu wykorzystywane są następujące praktyki:\n\nwyświetlanie powiadomień - aplikacja informuje użytkownika o trwającym procesie generowania raportu za pomocą powiadomień. Jest to przydatne, ponieważ renderowanie dokumentu RMarkdown może zająć kilka sekund.\npraca z katalogiem tymczasowym - aby uniknąć problemów związanych z lokalizacją plików podczas wdrażania aplikacji (np. na shinyapps.io), raport RMarkdown jest kopiowany do katalogu tymczasowego przed renderowaniem. Dzięki temu unika się problemów związanych z uprawnieniami do plików czy ich lokalizacją.\noddzielenie procesu renderowania - dla większej niezawodności, proces renderowania raportu może być wykonany w oddzielnej sesji R za pomocą pakietu callr. Zapewnia to izolację środowiska renderowania od środowiska aplikacji Shiny, co może przyczynić się do uniknięcia potencjalnych konfliktów.\n\nPakiet shinymeta rozwiązuje problem reproducyjności raportów generowanych na podstawie interaktywnej eksploracji w aplikacjach Shiny. Umożliwia on zapisanie bieżącego stanu aplikacji w taki sposób, aby można było go później odtworzyć i wygenerować identyczny raport. Jest to szczególnie przydatne w aplikacjach, gdzie zachowanie interaktywności idzie w parze z potrzebą reproducyjności wyników analiz.",
    "crumbs": [
      "Wykład 6"
    ]
  },
  {
    "objectID": "wyk6.html#przykład",
    "href": "wyk6.html#przykład",
    "title": "Wykład 6",
    "section": "",
    "text": "Przykład pokazuje, jak zbudować aplikację Shiny, która umożliwia użytkownikom przesłanie własnego pliku danych, przeprowadzenie na nim opcjonalnych transformacji, a następnie pobranie przetworzonych danych w formacie .tsv. Ten proces składa się z kilku kroków, które są zaprezentowane poniżej w sposób bardziej szczegółowy.\n\nPierwszym krokiem jest stworzenie interfejsu umożliwiającego użytkownikowi przesłanie pliku danych. Użytkownik może również określić separator danych (np. przecinek, średnik, tabulator) oraz inne opcje, takie jak liczba wierszy do pominięcia na początku pliku czy liczba wierszy do wyświetlenia w podglądzie.\nPrzykład interfejsu dla uploadu i parsowania pliku:\n\nKodui_upload &lt;- sidebarLayout(\n  sidebarPanel(\n    fileInput(\"file\", \"Data\", buttonLabel = \"Upload...\"),\n    textInput(\"delim\", \"Delimiter (leave blank to guess)\", \"\"),\n    numericInput(\"skip\", \"Rows to skip\", 0, min = 0),\n    numericInput(\"rows\", \"Rows to preview\", 10, min = 1)\n  ),\n  mainPanel(\n    h3(\"Raw data\"),\n    tableOutput(\"preview1\")\n  )\n)\n\n\nNa serwerze plik jest odczytywany z wykorzystaniem podanych przez użytkownika opcji, a następnie wyświetlany jest jego podgląd:\n\nKodraw &lt;- reactive({\n  req(input$file)\n  delim &lt;- if (input$delim == \"\") NULL else input$delim\n  vroom::vroom(input$file$datapath, delim = delim, skip = input$skip)\n})\noutput$preview1 &lt;- renderTable(head(raw(), input$rows))\n\n\n\nDrugi krok umożliwia użytkownikowi wykonanie opcjonalnych transformacji danych, takich jak zmiana nazw kolumn na snake case, usunięcie kolumn o stałej wartości lub pustych kolumn.\nPrzykład interfejsu dla czyszczenia danych:\n\nKodui_clean &lt;- sidebarLayout(\n  sidebarPanel(\n    checkboxInput(\"snake\", \"Rename columns to snake case?\"),\n    checkboxInput(\"constant\", \"Remove constant columns?\"),\n    checkboxInput(\"empty\", \"Remove empty cols?\")\n  ),\n  mainPanel(\n    h3(\"Cleaner data\"),\n    tableOutput(\"preview2\")\n  )\n)\n\n\nLogika serwera przetwarzająca dane zgodnie z wybranymi opcjami:\n\nKodtidied &lt;- reactive({\n  out &lt;- raw()\n  if (input$snake) {\n    names(out) &lt;- janitor::make_clean_names(names(out))\n  }\n  if (input$empty) {\n    out &lt;- janitor::remove_empty(out, \"cols\")\n  }\n  if (input$constant) {\n    out &lt;- janitor::remove_constant(out)\n  }\n  out\n})\noutput$preview2 &lt;- renderTable(head(tidied(), input$rows))\n\n\n\nOstatnim krokiem jest umożliwienie użytkownikowi pobrania przetworzonych danych w formacie .tsv. Do tego celu używany jest downloadButton w interfejsie użytkownika oraz downloadHandler w logice serwera.\nPrzykład interfejsu dla pobierania danych:\n\nKodui_download &lt;- fluidRow(\n  column(width = 12, downloadButton(\"download\", class = \"btn-block\"))\n)\n\n\nImplementacja serwera obsługującego pobieranie:\n\nKodoutput$download &lt;- downloadHandler(\n  filename = function() {\n    paste0(tools::file_path_sans_ext(input$file$name), \".tsv\")\n  },\n  content = function(file) {\n    vroom::vroom_write(tidied(), file, delim = \"\\t\")\n  }\n)\n\n\n\nPrzedstawione case study ilustruje, jak można zbudować kompleksową aplikację Shiny służącą do uploadu, przetwarzania i pobierania danych. Wykorzystanie funkcji reaktywnych pozwala na dynamiczne dostosowanie przepływu danych i interakcji z użytkownikiem, zapewniając jednocześnie, że aplikacja pozostaje responsywna i intuicyjna w obsłudze. Takie podejście sprawdza się w różnych scenariuszach analizy danych, oferując użytkownikom potężne narzędzie do pracy z danymi bez konieczności opuszczania interfejsu aplikacji2.\n\n\n2 cały przykład w postaci aplikacji Shiny można znaleźć pod adresem https://github.com/dax44/ModelsDeployment/blob/master/upload.R",
    "crumbs": [
      "Wykład 6"
    ]
  }
]