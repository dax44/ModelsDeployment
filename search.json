[
  {
    "objectID": "Wdrażanie modeli uczenia maszynowego.html",
    "href": "Wdrażanie modeli uczenia maszynowego.html",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych."
  },
  {
    "objectID": "Wdrażanie modeli uczenia maszynowego.html#przebieg-prac-nad-wdrożeniem-modelu",
    "href": "Wdrażanie modeli uczenia maszynowego.html#przebieg-prac-nad-wdrożeniem-modelu",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych."
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "Wykład 1",
    "section": "",
    "text": "Ponieważ proces budowy i udoskonalania modelu może trwać długo i być prowadzony przez kilka osób, to kontrolowanie wersji modelu wydaje się być konieczne.\nPonadto konieczne w tym procesie jest kontrolowanie zarówno aktualnej wersji modelu, jak i wszystkich przyległości z nim związanych. Idealnym narzędziem do zautomatyzowania czynności polegających na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program działający w terminalu ale istnieją również jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednocześnie połączony z hubem (czyli kontenerem) pozwalającym na przechowywanie i udostępnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usługa serwerowa, która pozwala na zapisywanie i udostępnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\nW niniejszym wykładzie zostaną przedstawione rozwiązania z wykorzystaniem Gita i GitHuba.\nPrzykładowe repozytorium projektu tidymodels na stronie GitHub wygląda następująco.\nGit w połączeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, który tworzymy, a jednocześnie na udostępnianie go oraz umożliwienie współpracy nad kodem przez wielu użytkowników - współtwórców (ang. contributors) ale nie tylko. Udostępnianie może być zarówno publiczne, jak i prywatne.\nFunkcjonalności GitHub, to:\nŁącząc Git z Githubem, programiści zyskują mocne narzędzie do kontroli wersji, współpracy, śledzenia problemów i automatyzacji procesów, co przyczynia się do skutecznego zarządzania projektami oprogramowania1."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "Wykład 1",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nNie wszystkie z powyższych tematów uda nam się omówić na wykładzie ale większość zostanie zademonstrowana.↩︎\nskrót od repozytorium↩︎\nwprawdzie na tym etapie dodaliśmy plik README.md ale ponieważ jest to pierwszy commit to tak go nazwaliśmy.↩︎"
  },
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "Wykład 2",
    "section": "",
    "text": "Przypominając sytuację w jakiej się znajdujemy… utworzyliśmy repozytorium o nazwie DariuszMajerek/Github_tests. Dokonaliśmy w nim kilku zmian commitowanych za każdym razem. Podgląd tych zmian możemy dokonać przez przegląd commitów.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "Wykład 2",
    "section": "",
    "text": "Zmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "Wykład 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request."
  },
  {
    "objectID": "wyk2.html#działanie-na-gałęziach",
    "href": "wyk2.html#działanie-na-gałęziach",
    "title": "Wykład 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "Wykład 2",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nEwentualne zmiany nie popsują niczego w tym repo, bo jest ono przygotowane do tego typu testów.↩︎\nDotąd mamy wszystko zrobione↩︎"
  },
  {
    "objectID": "wyk3.html",
    "href": "wyk3.html",
    "title": "Wykład 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w języku R i Python (od niedawna, jak jednak będę się skupiał na R). Jest to obszar, w którym inżynierowie danych i analitycy mogą tworzyć interaktywne aplikacje internetowe, wykorzystując całą swoją wiedzę i analizy zgromadzoną w języku R. Dzięki Shiny, użytkownicy mogą łatwo przekształcać swoje skrypty i modele w interaktywne aplikacje internetowe, bez konieczności posiadania wcześniejszego doświadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera się na paradygmacie “reactive programming”, co oznacza, że aplikacje tworzone przy jego użyciu są dynamiczne i reagują na zmiany danych w czasie rzeczywistym. Oznacza to, że użytkownicy mogą manipulować danymi i obserwować, jak te zmiany wpływają na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementów Shiny jest jego prostota użycia. Za pomocą kilku linii kodu w języku R, można stworzyć interaktywny interfejs, który pozwala użytkownikowi na łatwe eksplorowanie danych. Warto również podkreślić, że Shiny integruje się z istniejącymi narzędziami analizy danych w R, takimi jak ggplot2 czy dplyr, co ułatwia korzystanie z istniejących umiejętności programistycznych.\nShiny oferuje różnorodne elementy interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umożliwiając tworzenie rozbudowanych interfejsów. Ponadto, framework ten obsługuje również funkcje uwierzytelniania i autoryzacji, co pozwala kontrolować dostęp do aplikacji w zależności od potrzeb.\nDzięki Shiny, analiza danych staje się bardziej dostępna i przyjazna dla użytkownika końcowego, umożliwiając interaktywną eksplorację wyników analizy danych bez konieczności głębokiego zrozumienia kodu R. To narzędzie jest szczególnie przydatne dla osób pracujących w dziedzinie analizy danych, statystyki, czy nauk społecznych, które chcą szybko i efektywnie udostępnić swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#czym-jest-shiny",
    "href": "wyk3.html#czym-jest-shiny",
    "title": "Wykład 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w języku R i Python (od niedawna, jak jednak będę się skupiał na R). Jest to obszar, w którym inżynierowie danych i analitycy mogą tworzyć interaktywne aplikacje internetowe, wykorzystując całą swoją wiedzę i analizy zgromadzoną w języku R. Dzięki Shiny, użytkownicy mogą łatwo przekształcać swoje skrypty i modele w interaktywne aplikacje internetowe, bez konieczności posiadania wcześniejszego doświadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera się na paradygmacie “reactive programming”, co oznacza, że aplikacje tworzone przy jego użyciu są dynamiczne i reagują na zmiany danych w czasie rzeczywistym. Oznacza to, że użytkownicy mogą manipulować danymi i obserwować, jak te zmiany wpływają na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementów Shiny jest jego prostota użycia. Za pomocą kilku linii kodu w języku R, można stworzyć interaktywny interfejs, który pozwala użytkownikowi na łatwe eksplorowanie danych. Warto również podkreślić, że Shiny integruje się z istniejącymi narzędziami analizy danych w R, takimi jak ggplot2 czy dplyr, co ułatwia korzystanie z istniejących umiejętności programistycznych.\nShiny oferuje różnorodne elementy interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umożliwiając tworzenie rozbudowanych interfejsów. Ponadto, framework ten obsługuje również funkcje uwierzytelniania i autoryzacji, co pozwala kontrolować dostęp do aplikacji w zależności od potrzeb.\nDzięki Shiny, analiza danych staje się bardziej dostępna i przyjazna dla użytkownika końcowego, umożliwiając interaktywną eksplorację wyników analizy danych bez konieczności głębokiego zrozumienia kodu R. To narzędzie jest szczególnie przydatne dla osób pracujących w dziedzinie analizy danych, statystyki, czy nauk społecznych, które chcą szybko i efektywnie udostępnić swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#części-składowe-aplikacji-shiny",
    "href": "wyk3.html#części-składowe-aplikacji-shiny",
    "title": "Wykład 3",
    "section": "Części składowe aplikacji Shiny",
    "text": "Części składowe aplikacji Shiny\nDo poprawnego działania aplikacji Shiny konieczne jest zainstalowanie pakietu shiny.\nW każdej aplikacji Shiny można wyróżnić trzy podstawowe części:\n\n\nUI (Interfejs Użytkownika):\n\n\nElementy Interfejsu - definiują strukturę interfejsu użytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele, wykresy itp.\n\nUkład Strony - określa rozmieszczenie i stylizację elementów na stronie.\n\nDefinicja UI - jest to miejsce, w którym programista określa, jak mają wyglądać interaktywne elementy widoczne dla użytkownika.\n\n\n\nPrzykład definicji UI w Shiny może wyglądać następująco:\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Moja Aplikacja Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"slider\", \"Wybierz wartość:\", min = 1, max = 100, value = 50)\n    ),\n    mainPanel(\n      plotOutput(\"wykres\")\n    )\n  )\n)\n\n\n\n\nServer (Serwer):\n\n\nFunkcje Obliczeniowe - zawierają kod R odpowiedzialny za przetwarzanie danych, generowanie wyników oraz reakcję na interakcje użytkownika.\n\nReaktywność - serwer Shiny korzysta z obiektów reaktywnych do śledzenia zmian w danych i automatycznego aktualizowania wyników w interfejsie użytkownika.\n\n\n\nPrzykład definicji serwera w Shiny może wyglądać tak:\n\nKodserver &lt;- function(input, output) {\n  output$wykres &lt;- renderPlot({\n    dane &lt;- seq(1, input$slider)\n    plot(dane, main = \"Wykres dynamiczny\")\n  })\n}\n\n\n\n\nSesja Shiny:\n\n\nKomunikacja UI-Server - każda sesja Shiny umożliwia komunikację między interfejsem użytkownika a serwerem, przesyłanie danych i instrukcji między dwiema warstwami aplikacji.\n\nŻywotność Aplikacji - sesja utrzymuje stan aplikacji, umożliwiając śledzenie i reakcję na zmiany dokonywane przez użytkownika.\n\n\n\nPrzykład uruchamiania aplikacji Shiny zdefiniowanej powyżej:\n\nKodshinyApp(ui, server)\n\n\nDo zapoznania się z możliwościami aplikacji Shiny zachęcam do uruchomienia następujących przykładów aplikacji.\n\nKodrunExample(\"01_hello\")      # a histogram\nrunExample(\"02_text\")       # tables and data frames\nrunExample(\"03_reactivity\") # a reactive expression\nrunExample(\"04_mpg\")        # global variables\nrunExample(\"05_sliders\")    # slider bars\nrunExample(\"06_tabsets\")    # tabbed panels\nrunExample(\"07_widgets\")    # help text and submit buttons\nrunExample(\"08_html\")       # Shiny app built from HTML\nrunExample(\"09_upload\")     # file upload wizard\nrunExample(\"10_download\")   # file download wizard\nrunExample(\"11_timer\")      # an automated timer\n\n\n\n\nPrzykład wywołania przykładu ‘01_hello’\n\nReaktywność w Shiny\nReaktywność jest kluczowym konceptem w Shiny, który pozwala interakcji między komponentami interfejsu użytkownika a kodem R. W Shiny, gdy użytkownik wykonuje interakcję (na przykład klikając przycisk, wpisując tekst, wybierając wartość z rozwijanej listy), aplikacja automatycznie reaguje na tę interakcję. To oznacza, że wynik generowany przez aplikację jest zmienny i dynamicznie dostosowuje się do akcji użytkownika, bez konieczności odświeżania strony.\nReaktywność w Shiny opiera się na tzw. “reactive expressions” oraz “reactive conductors”. “Reactive expressions” są funkcjami, które automatycznie aktualizują wynik w zależności od zmian w ich zmiennych wejściowych. Z kolei “reactive conductors” pozwalają na definiowanie reakcji na zmiany wartości w interfejsie użytkownika.\nPrzykłady reaktywności w Shiny obejmują dynamiczne odświeżanie wykresów w zależności od wartości wybranych przez użytkownika, automatyczne dostosowanie zakresu danych w oparciu o interakcje użytkownika (np. przesunięcia suwaka), zmiany zależne od wprowadzonych danych (np. obliczenia oparte na wartościach wprowadzonych do pól tekstowych), i wiele innych. Reaktywność umożliwia tworzenie interfejsów, które są interaktywne i dostosowują się do działań użytkownika w czasie rzeczywistym.\n\n\nWyrażenia reaktywne (reactive()):\n\nReaktywne wyrażenia to fragmenty kodu, które automatycznie obliczają i śledzą swoje zależności.\nPrzykład: Reaktywne wyrażenie, które oblicza sumę dwóch wartości wprowadzanych przez użytkownika.\n\n\nKodsuma_reaktywna &lt;- reactive({\n  input$wartosc1 + input$wartosc2\n})\n\n\n\n\nObserwatory (observe()):\n\nObserwatory to fragmenty kodu, które są wykonywane w odpowiedzi na zmiany w danych. Służą najczęściej do działań typu side effect.\nPrzykład: Obserwator, który wypisuje na konsoli aktualną wartość suwaka.\n\n\nKodobserve({\n  cat(\"Aktualna wartość suwaka:\", input$suwak, \"\\n\")\n})\n\n\n\n\nReaktywne Funkcje (render*()):\n\nFunkcje render*()są używane w serwerze do generowania wyników, które są automatycznie aktualizowane w interfejsie w zależności od zmian w danych wejściowych.\nPrzykład: Renderowanie wykresu w zależności od wartości suwaka.\n\n\nKodoutput$wykres &lt;- renderPlot({\n  dane &lt;- seq(1, input$suwak)\n  plot(dane, main = \"Wykres dynamiczny\")\n})\n\n\n\n\nPrzykład 1\nRozważmy prosty przykład zastosowania reaktywności w Shiny, gdzie użytkownik wprowadza dwie liczby za pomocą pól tekstowych, a aplikacja reaguje na te zmiany, automatycznie obliczając i wyświetlając ich sumę. W tym przykładzie wykorzystamy reaktywne wyrażenia.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Sumator\"),\n  textInput(\"liczba1\", \"Wprowadź pierwszą liczbę:\", value = \"\"),\n  textInput(\"liczba2\", \"Wprowadź drugą liczbę:\", value = \"\"),\n  textOutput(\"wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Reaktywne wyrażenie obliczające sumę dwóch liczb\n  suma_reaktywna &lt;- reactive({\n    # Konwertujemy wprowadzone wartości na liczby\n    liczba1 &lt;- as.numeric(input$liczba1)\n    liczba2 &lt;- as.numeric(input$liczba2)\n    \n    # Sprawdzamy, czy wprowadzone wartości są liczbami\n    if (is.na(liczba1) || is.na(liczba2)) {\n      return(NULL)  # Zwracamy NULL, jeśli dane są nieprawidłowe\n    }\n    \n    # Obliczamy sumę\n    suma &lt;- liczba1 + liczba2\n    return(suma)\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$wynik &lt;- renderText({\n    suma &lt;- suma_reaktywna()\n    \n    # Sprawdzamy, czy wynik jest dostępny\n    if (!is.null(suma)) {\n      return(paste(\"Suma: \", suma))\n    } else {\n      return(\"Wprowadź poprawne liczby.\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, kiedy użytkownik wprowadza liczby do pól tekstowych, reaktywne wyrażenie suma_reaktywna automatycznie oblicza sumę tych liczb. Następnie, przy użyciu funkcji renderującej renderText, wynik jest wyświetlany w interfejsie. Dzięki temu podejściu, interfejs jest reaktywny na zmiany wprowadzane przez użytkownika, dostosowując się automatycznie do nowych danych i prezentując aktualny wynik.\n\nPrzykład 2\nRozważmy teraz przykład zastosowania wyrażenia reaktywnego w Shiny. W tej sytuacji, użytkownik będzie mógł kliknąć przycisk, co spowoduje inkrementację wartości licznika. Wykorzystamy do tego celu obiekt reaktywny.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik Kliknięć\"),\n  actionButton(\"przycisk\", \"Kliknij mnie\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Inicjalizacja obiektu reaktywnego dla licznika\n  licznik &lt;- reactiveValues(licznik_wartosc = 0)\n\n  # Obserwator reagujący na kliknięcie przycisku\n  observeEvent(input$przycisk, {\n    # Inkrementacja wartości licznika po kliknięciu przycisku\n    licznik$licznik_wartosc &lt;- licznik$licznik_wartosc + 1\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$licznik_wynik &lt;- renderText({\n    paste(\"Liczba kliknięć: \", licznik$licznik_wartosc)\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, obiekt reaktywny licznik jest używany do przechowywania wartości licznika. Za każdym razem, gdy użytkownik kliknie przycisk, obserwator reaguje na to kliknięcie, inkrementując wartość licznika w obiekcie reaktywnym. Następnie, przy użyciu funkcji renderującej renderText, aktualna wartość licznika jest wyświetlana w interfejsie. Dzięki temu, interfejs jest reaktywny na akcje użytkownika, a wartość licznika automatycznie się aktualizuje.\n\nPrzykład 3\nPrzykład zastosowania obserwatora w Shiny można przedstawić na prostym przypadku, gdzie użytkownik wpisuje tekst do pola tekstowego, a aplikacja reaguje na każdą zmianę i wyświetla liczbę znaków wprowadzonych przez użytkownika. W tym przypadku użyjemy funkcji obserwującej (observe) do reakcji na zmiany w tekście wprowadzonym przez użytkownika.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik Znaków\"),\n  textInput(\"tekst_input\", \"Wprowadź tekst:\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Obserwator reagujący na zmiany w tekście wprowadzonym przez użytkownika\n  observe({\n    # Pobranie tekstu z pola tekstowego\n    wprowadzony_tekst &lt;- input$tekst_input\n    \n    # Obliczenie liczby znaków w tekście\n    liczba_znakow &lt;- nchar(wprowadzony_tekst)\n    \n    # Aktualizacja wyniku w interfejsie\n    output$licznik_wynik &lt;- renderText({\n      paste(\"Liczba znaków: \", liczba_znakow)\n    })\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, funkcja observe śledzi zmiany w polu tekstowym (textInput) o nazwie “tekst_input”. Za każdym razem, gdy użytkownik wprowadza lub zmienia tekst, obserwator automatycznie aktualizuje wynik w interfejsie, wyświetlając liczbę znaków wprowadzonych przez użytkownika. Dzięki obserwatorowi, aplikacja jest reaktywna na zmiany w polu tekstowym bez konieczności odświeżania strony.\n\nPrzykład 4\nPrzykład wykorzystania renderPlot w Shiny może obejmować generowanie dynamicznego wykresu w zależności od interakcji użytkownika. Poniżej przedstawiam prosty scenariusz, w którym użytkownik może wybierać rodzaj wykresu (liniowy lub punktowy) oraz regulować parametry, a aplikacja reaguje, generując i wyświetlając odpowiedni wykres.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu użytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny Wykres\"),\n  selectInput(\"typ_wykresu\", \"Wybierz typ wykresu:\",\n              choices = c(\"Linia\", \"Punkty\")),\n  sliderInput(\"ilosc_punktow\", \"Liczba punktów:\", min = 10, max = 100, value = 50),\n  plotOutput(\"wykres\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Renderowanie wykresu w zależności od wyboru użytkownika\n  output$wykres &lt;- renderPlot({\n    typ_wykresu &lt;- input$typ_wykresu\n    ilosc_punktow &lt;- input$ilosc_punktow\n    \n    # Generowanie wykresu w zależności od wyboru użytkownika\n    if (typ_wykresu == \"Linia\") {\n      plot(1:ilosc_punktow, type = \"l\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    } else {\n      plot(1:ilosc_punktow, type = \"p\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykładzie, użytkownik ma możliwość wyboru rodzaju wykresu (liniowy lub punktowy) za pomocą rozwijanej listy (selectInput). Ponadto, suwak (sliderInput) pozwala regulować liczbę punktów na wykresie. Funkcja renderPlot reaguje na zmiany w tych parametrach, generując odpowiedni wykres w zależności od wyboru użytkownika. Wykres jest następnie renderowany w sekcji interfejsu o nazwie “wykres”.\n\nKolejność wykonywanych czynności w obiektach reaktywnych.\nW grafie reaktywnym w Shiny, kolejność wykonywania czynności jest określana przez zależności między reaktywnymi elementami. W ogólnym przypadku, Shiny stosuje podejście zwane “reactive programming”, gdzie reaktywne elementy składają się z obiektów reaktywnych, obserwatorów i funkcji renderujących.\nKolejność wykonywania czynności w grafie reaktywnym może być ogólnie opisana następująco:\n\n\nInicjalizacja:\n\nAplikacja Shiny zaczyna od inicjalizacji interfejsu użytkownika (UI) oraz serwera.\nObiekty reaktywne są tworzone i inicjalizowane zgodnie z ich definicjami.\n\n\n\nObserwatory:\n\nObserwatory reagują na zmiany w danych i wykonują odpowiednie akcje.\nObserwatory są wywoływane w odpowiedzi na zdarzenia, takie jak kliknięcia przycisków, zmiany wartości pól tekstowych itp.\n\n\n\nReaktywne Wyrażenia:\n\nReaktywne wyrażenia są obliczane w odpowiedzi na zmiany danych wejściowych, na których zależą.\nReaktywne wyrażenia to fragmenty kodu, które zwracają wartość i śledzą swoje zależności.\n\n\n\nFunkcje Renderujące:\n\nFunkcje renderujące są wywoływane w celu aktualizacji wyników w interfejsie użytkownika na podstawie wartości zwróconych przez reaktywne wyrażenia.\nSą one odpowiedzialne za generowanie treści do wyświetlenia, np. w obszarze tekstowym, wykresie czy tabeli.\n\n\n\nAktualizacja UI:\n\nZaktualizowane wyniki są renderowane w interfejsie użytkownika.\n\n\n\nWażne jest zrozumienie, że Shiny automatycznie dba o zarządzanie zależnościami między reaktywnymi elementami, co oznacza, że jeśli jedna wartość zmieni się, to wszystkie elementy zależne od niej zostaną automatycznie zaktualizowane. Dzięki temu podejściu, Shiny zapewnia spójność danych i dynamiczne dostosowywanie interfejsu użytkownika w zależności od akcji użytkownika lub zmian w danych.\nDla lepszego zrozumienia kolejności wykonywanych działań oraz “magii” jakiej dostarczają obiekty reaktywne, przeanalizujmy następujący przykład:\nPrzykład 5\nNiech rdzeniem naszej1 aplikacji będzie następujący kod:\n\nKodui &lt;- fluidPage(\n  numericInput(\"a\", \"a\", value = 10),\n  numericInput(\"b\", \"b\", value = 1),\n  numericInput(\"c\", \"c\", value = 1),\n  plotOutput(\"x\"),\n  tableOutput(\"y\"),\n  textOutput(\"z\")\n)\n\nserver &lt;- function(input, output, session) {\n  rng &lt;- reactive(input$a * 2)\n  smp &lt;- reactive(sample(rng(), input$b, replace = TRUE))\n  bc &lt;- reactive(input$b * input$c)\n  \n  output$x &lt;- renderPlot(hist(smp()))\n  output$y &lt;- renderTable(max(smp()))\n  output$z &lt;- renderText(bc())\n}\n\n\nW naszej aplikacji występują trzy wejścia (a, b, c) z ustawionymi wartościami domyślnymi, trzy wyrażenia reaktywne (rng, smp, bc) oraz trzema reaktywnymi wyjściami (x,y,z). W momencie inicjalizacji aplikacji stan je można opisać poniższym grafem (wszystkie wyrażenia reaktywne i wyjścia są w stanie określanym jako invalidated):\n\n\n\n\nW momencie egzekucji aplikacji Shiny uruchamiane jest jedno losowe wejście2 (oznaczmy to żółtym kolorem).\n\n\n\n\nPonieważ wywołanie to potrzebuje wartości wyrażeń reaktywnych, to tworzy się połączenie z wyrażeniami reaktywnymi, od których zależy wyjście i inicjalizowane są wyrażenia reaktywne. Powiedzmy, że pierwszym wykonującym się wyjściem było output$x. Wtedy wymagane jest wywołanie obiektu reaktywnego smp().\n\n\n\n\nWartość smp() zależy za to od input$b, którego wartość jest określona, ponieważ jest to wartość wejściowa z domyślną wartością 1.\n\n\n\n\nWartość smp() zależy również od innego wyrażenia reaktywnego rng(), które jest znów powiązane z wejściem input$a. Analogicznie do powyższej sytuacji odpowiednie połączenia i egzekucje zostaną wywołane.\n\n\n\n\nW ten sposób wszystko co jest potrzebne do egzekucji wyjścia output$x zostało policzone i można przejść do wywołania wyjścia.\n\n\n\n\nPrzechodzimy zatem do egzekucji kolejnego wyjścia output$y.\n\n\n\n\nPonieważ output$y zależy tylko do smp() a to zostało już policzone i jego stan został “skeszowany”, to nie trzeba po raz kolejny wywoływać tych obliczeń3. W podobny sposób wywoływane są wszystkie wyjścia. Po egzekucji wszystkich wyjść graf przedstawia się następująco4:\n\n\n\n\nJeśli nastąpi zmiana wartości wejściowej, wówczas wejście to jest najpierw oznaczane jako invalidated, a następnie stan invalidated jest nadawany wszystkim obiektom zależnym od tego wejścia, co powoduje, że graf wygląda następująco:\n\n\n\n\nPonadto usuwane są połączenia do obiektów w stanie invalidated i jednocześnie przypisywana jest nowa wartość input$a.\n\n\n\n\nW dalszej kolejności znów jedno z wyjść unieważnionych (ang. invalidated) jest poddane egzekucji, która pociąga za sobą egzekucje tych wejść i wyrażeń reaktywnych, które są wymagane do obliczenia wartości lub wyświetlenia wyjścia.\n\n\n\n\nDalej proces przebiega podobnie. Warto zauważyć, że pewne wejścia i wyrażenia reaktywne nie musiały się wywoływać ponownie.\nPrzeanalizujmy jeszcze jeden krótki przykład aby lepiej zrozumieć reaktywność w Shiny.\nPrzykład 6\nAplikacja jest zbudowana następująco:\n\nKodui &lt;- fluidPage(\n  selectInput(\"choice\", \"A or B?\", c(\"a\", \"b\")),\n  numericInput(\"a\", \"a\", 0),\n  numericInput(\"b\", \"b\", 10),\n  textOutput(\"out\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    if (input$choice == \"a\") {\n      input$a\n    } else {\n      input$b\n    }\n  }) \n}\n\n\nMogłoby się wydawać, że graf dla niej wygląda następująco:\n\n\n\n\nAle ponieważ Shiny dynamicznie rekonstruuje wykres po unieważnieniu danych wyjściowych, w rzeczywistości wygląda on jak jeden z poniższych wykresów, w zależności od wartości input$choice. Zapewnia to, że Shiny wykonuje minimalną ilość pracy, gdy dane wejściowe są unieważniane. W tym przypadku, jeśli input$choice jest ustawiony na b, to wartość input$a nie wpływa na output$out i nie ma potrzeby jej ponownego obliczania.\n\n\n\n\nGdybyśmy nieznacznie zmienili funkcję serwera, to wartość wyjścia stale by zależała od dwóch wejść.\n\nKodoutput$out &lt;- renderText({\n  a &lt;- input$a\n  b &lt;- input$b\n\n  if (input$choice == \"a\") {\n    a\n  } else {\n    b\n  }\n}) \n\n\n\n\n\n\n\n\nWskazówka\n\n\n\nChcąc poznać reguły panujące w złożonych aplikacjach i zależności pomiędzy obiektami, można użyć pakietu reactlog. Uruchamiając przed wywołaniem aplikacji funkcję reactlog::reactlog_enable() powodujemy odpalenie serwera rejestrującego połączenia. Można przeglądać na żywo zmiany stanów poszczególnych obiektów przez wywołanie Ctrl+F3 (Windows) lub Cmd+F3 (MacOS i Linux). Po zakończeniu działania aplikacji możemy też przejrzeć log stanów używając shiny::reactlogShow()."
  },
  {
    "objectID": "wyk3.html#footnotes",
    "href": "wyk3.html#footnotes",
    "title": "Wykład 3",
    "section": "Przypisy",
    "text": "Przypisy\n\nbezużytecznej↩︎\nnajczęściej wyjścia są niezależne, ale w przypadku zagnieżdżeń kolejność wykonywania aplikacji uwzględnia tą zależność↩︎\nto część magii reaktywności↩︎\nstan ten się nie zmienia aż do zmiany jakiejś wielkości wejściowej↩︎"
  },
  {
    "objectID": "wyk4.html",
    "href": "wyk4.html",
    "title": "Wykład 4",
    "section": "",
    "text": "Shiny oferuje wiele możliwości do tworzenia interaktywnych i estetycznych layoutów dla aplikacji. Można korzystać z różnych funkcji i elementów interfejsu użytkownika, aby dostosować wygląd i układ strony. Poniżej przedstawiam kilka kluczowych możliwości i technik budowy layoutów w Shiny:\n\n\nFluid Grid Layout:\n\n\nfluidPage() to podstawowa funkcja służąca do tworzenia responsywnego układu strony.\nObejmuje różne sekcje takie jak titlePanel, sidebarLayout, mainPanel itp., które pomagają w organizacji i strukturyzacji interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Elementy boczne, np. suwaki, przyciski\n    ),\n    mainPanel(\n      # Główna zawartość, np. wykresy, tabele\n    )\n  )\n)\n\n\n\n\nColumn Layout:\n\nMożna używać column() do podziału obszaru głównego na kolumny, co pozwala na bardziej elastyczny układ strony.\nTo przydatne, gdy chcemy umieścić różne elementy obok siebie.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  column(\n    width = 4,\n    # Pierwsza kolumna\n  ),\n  column(\n    width = 8,\n    # Druga kolumna\n  )\n)\n\n\n\n\nTabset Panel:\n\n\ntabsetPanel() umożliwia organizację interfejsu za pomocą zakładek.\nKażda zakładka może mieć własny zestaw elementów interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  tabsetPanel(\n    tabPanel(\"Zakładka 1\", \n             # Zawartość pierwszej zakładki),\n    tabPanel(\"Zakładka 2\", \n             # Zawartość drugiej zakładki)\n  )\n)\n\n\n\n\nHTML i CSS:\n\nShiny umożliwia wbudowanie kodu HTML i CSS do dostosowywania wyglądu.\nFunkcje takie jak HTML() pozwalają na wstawienie kodu HTML bezpośrednio do interfejsu użytkownika.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Tytuł Aplikacji\"),\n  HTML(\"&lt;h2&gt;Własny tytuł HTML&lt;/h2&gt;\")\n)\n\n\n\n\nDashboard Layout:\n\nBiblioteka shinydashboard dostarcza narzędzi do tworzenia układów przypominających klasyczne dashboardy.\nObejmuje funkcje takie jak dashboardPage(), dashboardHeader(), dashboardSidebar().\n\n\nKodlibrary(shinydashboard)\n\nui &lt;- dashboardPage(\n  dashboardHeader(title = \"Dashboard Title\"),\n  dashboardSidebar(\n    # Elementy boczne, np. suwaki, przyciski\n  ),\n  dashboardBody(\n    # Główna zawartość, np. wykresy, tabele\n  )\n)"
  },
  {
    "objectID": "wyk4.html#instalacja-edytora-shiny",
    "href": "wyk4.html#instalacja-edytora-shiny",
    "title": "Wykład 4",
    "section": "Instalacja edytora Shiny",
    "text": "Instalacja edytora Shiny\nPolecam instalować najnowszą wersję (dystrybucję) pakietu shinyuieditor ze strony Github autora.\n\nKodif (!requireNamespace(\"remotes\", quietly = TRUE))\n    install.packages(\"remotes\")\n\n# Install using the remotes package\nremotes::install_github(\"rstudio/shinyuieditor\")"
  },
  {
    "objectID": "wyk4.html#użycie-edytora-shiny",
    "href": "wyk4.html#użycie-edytora-shiny",
    "title": "Wykład 4",
    "section": "Użycie edytora Shiny",
    "text": "Użycie edytora Shiny\nAby użyć po raz pierwszy edytora interfejsu Shiny należy użyć następującej komendy:\n\nKodshinyuieditor::launch_editor(app_loc = \"shiny-app/\")\n\n\nJeśli w katalogu roboczym znajduje się aplikacja umieszczona w katalogu roboczym shiny-app, to edytor pozwoli na edycję istniejącej już aplikacji1. Warunek odpalenia shinyuieditor dla istniejącej aplikacji jest to, że wskazany katalog zawiera tylko plik app.R. Jeśli wskazany katalog nie zawiera niczego, edytor odpala się z możliwością wyboru wyglądu.\n\nKodshinyuieditor::launch_editor(app_loc = \"test_shinyuieditor/\")\n\n\n\n\nWygląd po wybraniu wyglądu aplikacji\n\nDodawanie elementów do aplikacji\nPo wyborze wyglądu głównego można przystąpić do edycji elementów wyglądu. Warto zacząć od tutorialu edytora klikając w prawym górnym rogu przycisk “Tour App”. Następnie można przystąpić do edycji wyglądu wg własnego uznania (patrzy przykład poniżej)\n\nAby dodać nowy element interfejsu użytkownika do aplikacji, należy przeciągnąć żądany element z panelu “Elements”. Miejsca, w których można umieścić element, zostaną podświetlone (jeśli nie ma dostępnych miejsc, spróbuj dodać nowy wiersz lub kolumnę do aplikacji, aby utworzyć miejsce). Po przeciągnięciu elementu na dostępny obszar, zwolnij go, aby dodać go do aplikacji.\nPrzemieszczanie elementów aplikacji\nKliknij i przeciągnij element ui, który chcesz przenieść. Podobnie jak w przypadku dodawania elementu, dostępne pozycje do przeniesienia elementu zostaną podświetlone. Przeciągnij element do żądanej nowej pozycji i upuść, aby go przenieść.\n\nWybór elementów aplikacji\nWybierz element, klikając wewnątrz niego. Po wybraniu elementu zostanie on oznaczony niebieskim konturem, a panel “Properties” zostanie zaktualizowany o szczegóły dotyczące elementu. Alternatywnie można wybrać element nadrzędny aktualnie wybranego elementu, klikając nazwę elementu nadrzędnego w wizualizacji ścieżki elementu w górnej części panelu “Properties”.\n\nUsuwanie elementów aplikacji\nWybierz element, po wybraniu elementu kliknij przycisk “Delete Element” w dolnej części panelu “Properties”. Niektóre elementy, takie jak grid_card(), będą również wyświetlać przyciski usuwania bezpośrednio na samym elemencie, gdy nie ma w nim żadnych elementów podrzędnych. Możesz również usunąć element za pomocą klawisza delete/backspace.\n\nAktualizacja ustwień elementów aplikacji\nWybierz element, po jego wybraniu zaktualizuj ustawienia za pomocą panelu “Properties”. Gdy dane wejściowe zostaną zaktualizowane, zmiany zostaną automatycznie zapisane i odzwierciedlone w skrypcie aplikacji i oknie podglądu na żywo.\n\nWyświetl rozmiary elementów aplikacji\nNajechanie myszą na lewy koniec wiersza lub górę kolumny powoduje wyświetlenie widżetu rozmiaru.\n\nDodawanie wierszy i kolumn do aplikacji\nOtwórz widżet rozmiaru wiersza lub kolumny sąsiadujący z miejscem, w którym chcesz dodać nowy wiersz lub kolumnę. Na obu końcach widżetu znajdują się przyciski plus (+), których kliknięcie spowoduje dodanie wiersza lub kolumny po odpowiednich stronach istniejącego wiersza lub kolumny.\n\nUsuwanie wierszy i kolumn aplikacji\nOtwórz widżet rozmiaru wiersza lub kolumny, który chcesz usunąć. Następnie kliknij czerwoną ikonę kosza, aby usunąć ten wiersz z układu. Jeśli ikona kosza jest wyszarzona, wiersz lub kolumna nie mogą zostać usunięte z powodu nazwanych obszarów siatki, które w całości się w nich znajdują. Najechanie myszką na zaszarzony przycisk spowoduje wskazanie tych obszarów siatki, dzięki czemu będzie można je usunąć lub przenieść w inne miejsce.\n\nZmiana rozmiarów wierszy i kolumn aplikacji\n\nLub też inaczej, otwórz widżet zmiany rozmiaru wiersza/kolumny Użyj kontrolek wprowadzania jednostek css w tym widżecie, aby zaktualizować rozmiar wiersza lub kolumny.\n\nWycofanie zmian w aplikacji\nUżyj przycisku cofnij dostępnego w prawym górnym rogu aplikacji, aby przywrócić interfejs użytkownika aplikacji do stanu sprzed ostatniej wprowadzonej zmiany. Jeśli chcesz przywrócić właśnie cofniętą zmianę, kliknij przycisk ponów po prawej stronie. Zarówno cofnięcie, jak i ponowienie można również wykonać za pomocą skrótów klawiaturowych, odpowiednio cmd/ctrl + z i cmd/ctrl + shift + z.\n\nZatrzymanie edytora aplikacji\nDopóki argument stop_on_browser_close jest ustawiony na domyślną wartość TRUE, wówczas wszystko, co należy zrobić, aby zatrzymać edytor, to zamknąć kartę/okno przeglądarki, w której edytor jest aktualnie otwarty. Innym sposobem zakończenia jest przerwanie serwera edytora poprzez naciśnięcie Control/Command + c w konsoli R używanej do uruchomienia edytora."
  },
  {
    "objectID": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "href": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "title": "Wykład 4",
    "section": "Zmiany w edytorze a zmiany w kodzie",
    "text": "Zmiany w edytorze a zmiany w kodzie\nNależy pamiętać, że każda zmiana w edytorze skutkuje zmianami w kodzie definiującym aplikację. W drugą stronę działa to analogicznie. Każda zmiana w kodzie znajduje swoje odwzorowanie w edytorze i preview."
  },
  {
    "objectID": "wyk4.html#podsumowanie-funkcjonalności-edytora-aplikacji",
    "href": "wyk4.html#podsumowanie-funkcjonalności-edytora-aplikacji",
    "title": "Wykład 4",
    "section": "Podsumowanie funkcjonalności edytora aplikacji",
    "text": "Podsumowanie funkcjonalności edytora aplikacji\nshinyuieditor, jako narzędzie do projektowania interfejsu użytkownika dla aplikacji Shiny w R, ma swoje zalety i wady. Oto niektóre z nich:\nZalety:\n\nŁatwość Użycia - umożliwia użytkownikom, w tym osobom nieprogramującym, łatwe tworzenie i modyfikowanie interfejsów użytkownika poprzez graficzny interfejs, co obniża próg wejścia do tworzenia aplikacji Shiny.\nSzybki prototyping - pomaga w szybkim prototypowaniu aplikacji przez wizualne eksperymentowanie z różnymi układami i elementami UI, co jest szczególnie przydatne w fazie projektowania.\nInteraktywność bez bezpośredniego kodowania - ułatwia dodawanie interaktywnych elementów do aplikacji bez konieczności bezpośredniego pisania kodu, co może przyspieszyć rozwój projektu.\nEdukacyjne korzyści - może służyć jako narzędzie edukacyjne dla osób uczących się tworzenia aplikacji Shiny, pozwalając na lepsze zrozumienie, jak różne komponenty UI współpracują ze sobą.\nWady:\n\nOgraniczenia dostosowywania - graficzne interfejsy użytkownika mogą ograniczać możliwości dostosowania w porównaniu do bezpośredniego kodowania. Zaawansowane funkcje i niestandardowe zachowania mogą wymagać ręcznej edycji kodu.\nZależność od konkretnej implementacji - narzędzie takie jak shinyuieditor może nie być stale aktualizowane lub wspierane, co oznacza, że może nie być kompatybilne z najnowszymi wersjami Shiny lub R.\nKrzywa uczenia się dla zaawansowanych funkcji - mimo że narzędzie to obniża próg wejścia, zaawansowane funkcje Shiny mogą nadal wymagać solidnej wiedzy o R i Shiny, co oznacza, że użytkownicy będą musieli inwestować czas w naukę poza używaniem samego edytora.\n\nPodsumowując, shinyuieditor może być bardzo pomocny dla osób rozpoczynających pracę z Shiny oraz dla szybkiego prototypowania interfejsów użytkownika, ale dla zaawansowanych i wyspecjalizowanych potrzeb projektowych, bezpośrednie programowanie w R może oferować większą elastyczność i kontrolę."
  },
  {
    "objectID": "wyk4.html#footnotes",
    "href": "wyk4.html#footnotes",
    "title": "Wykład 4",
    "section": "Przypisy",
    "text": "Przypisy\n\nNależy jednak, że musi to być aplikacja przygotowana wg schematu generowanego przez shinyuieditor , bo inaczej nie będzie ona działać. Przykładowo użycie launch_editor do stockVis nie chciało działać.↩︎"
  }
]