[
  {
    "objectID": "WdraÅ¼anie modeli uczenia maszynowego.html",
    "href": "WdraÅ¼anie modeli uczenia maszynowego.html",
    "title": "WstÄ™p",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych."
  },
  {
    "objectID": "WdraÅ¼anie modeli uczenia maszynowego.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "href": "WdraÅ¼anie modeli uczenia maszynowego.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "title": "WstÄ™p",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych."
  },
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "PrzypominajÄ…c sytuacjÄ™ w jakiej siÄ™ znajdujemyâ€¦ utworzyliÅ›my repozytorium o nazwie DariuszMajerek/Github_tests. DokonaliÅ›my w nim kilku zmian commitowanych za kaÅ¼dym razem. PodglÄ…d tych zmian moÅ¼emy dokonaÄ‡ przez przeglÄ…d commitÃ³w.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeÅ¼enie\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nZagroÅ¼enie\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nWaÅ¼ne\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "Zmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeÅ¼enie\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nZagroÅ¼enie\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nWaÅ¼ne\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request."
  },
  {
    "objectID": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "href": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "WykÅ‚ad 2",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nEwentualne zmiany nie popsujÄ… niczego w tym repo, bo jest ono przygotowane do tego typu testÃ³w.â†©ï¸\nDotÄ…d mamy wszystko zrobioneâ†©ï¸"
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "WykÅ‚ad 1",
    "section": "",
    "text": "PoniewaÅ¼ proces budowy i udoskonalania modelu moÅ¼e trwaÄ‡ dÅ‚ugo i byÄ‡ prowadzony przez kilka osÃ³b, to kontrolowanie wersji modelu wydaje siÄ™ byÄ‡ konieczne.\nPonadto konieczne w tym procesie jest kontrolowanie zarÃ³wno aktualnej wersji modelu, jak i wszystkich przylegÅ‚oÅ›ci z nim zwiÄ…zanych. Idealnym narzÄ™dziem do zautomatyzowania czynnoÅ›ci polegajÄ…cych na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program dziaÅ‚ajÄ…cy w terminalu ale istniejÄ… rÃ³wnieÅ¼ jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednoczeÅ›nie poÅ‚Ä…czony z hubem (czyli kontenerem) pozwalajÄ…cym na przechowywanie i udostÄ™pnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usÅ‚uga serwerowa, ktÃ³ra pozwala na zapisywanie i udostÄ™pnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\nW niniejszym wykÅ‚adzie zostanÄ… przedstawione rozwiÄ…zania z wykorzystaniem Gita i GitHuba.\nPrzykÅ‚adowe repozytorium projektu tidymodels na stronie GitHub wyglÄ…da nastÄ™pujÄ…co.\nGit w poÅ‚Ä…czeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, ktÃ³ry tworzymy, a jednoczeÅ›nie na udostÄ™pnianie go oraz umoÅ¼liwienie wspÃ³Å‚pracy nad kodem przez wielu uÅ¼ytkownikÃ³w - wspÃ³Å‚twÃ³rcÃ³w (ang. contributors) ale nie tylko. UdostÄ™pnianie moÅ¼e byÄ‡ zarÃ³wno publiczne, jak i prywatne.\nFunkcjonalnoÅ›ci GitHub, to:\nÅÄ…czÄ…c Git z Githubem, programiÅ›ci zyskujÄ… mocne narzÄ™dzie do kontroli wersji, wspÃ³Å‚pracy, Å›ledzenia problemÃ³w i automatyzacji procesÃ³w, co przyczynia siÄ™ do skutecznego zarzÄ…dzania projektami oprogramowania1."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "WykÅ‚ad 1",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nNie wszystkie z powyÅ¼szych tematÃ³w uda nam siÄ™ omÃ³wiÄ‡ na wykÅ‚adzie ale wiÄ™kszoÅ›Ä‡ zostanie zademonstrowana.â†©ï¸\nskrÃ³t od repozytoriumâ†©ï¸\nwprawdzie na tym etapie dodaliÅ›my plik README.md ale poniewaÅ¼ jest to pierwszy commit to tak go nazwaliÅ›my.â†©ï¸"
  }
]