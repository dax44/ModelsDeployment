[
  {
    "objectID": "Wdrażanie modeli uczenia maszynowego.html",
    "href": "Wdrażanie modeli uczenia maszynowego.html",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych."
  },
  {
    "objectID": "Wdrażanie modeli uczenia maszynowego.html#przebieg-prac-nad-wdrożeniem-modelu",
    "href": "Wdrażanie modeli uczenia maszynowego.html#przebieg-prac-nad-wdrożeniem-modelu",
    "title": "Wstęp",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych."
  },
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "Wykład 2",
    "section": "",
    "text": "Przypominając sytuację w jakiej się znajdujemy… utworzyliśmy repozytorium o nazwie DariuszMajerek/Github_tests. Dokonaliśmy w nim kilku zmian commitowanych za każdym razem. Podgląd tych zmian możemy dokonać przez przegląd commitów.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "Wykład 2",
    "section": "",
    "text": "Zmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeżenie\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nZagrożenie\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "Wykład 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nWażne\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request."
  },
  {
    "objectID": "wyk2.html#działanie-na-gałęziach",
    "href": "wyk2.html#działanie-na-gałęziach",
    "title": "Wykład 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "Wykład 2",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nEwentualne zmiany nie popsują niczego w tym repo, bo jest ono przygotowane do tego typu testów.↩︎\nDotąd mamy wszystko zrobione↩︎"
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "Wykład 1",
    "section": "",
    "text": "Ponieważ proces budowy i udoskonalania modelu może trwać długo i być prowadzony przez kilka osób, to kontrolowanie wersji modelu wydaje się być konieczne.\nPonadto konieczne w tym procesie jest kontrolowanie zarówno aktualnej wersji modelu, jak i wszystkich przyległości z nim związanych. Idealnym narzędziem do zautomatyzowania czynności polegających na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program działający w terminalu ale istnieją również jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednocześnie połączony z hubem (czyli kontenerem) pozwalającym na przechowywanie i udostępnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usługa serwerowa, która pozwala na zapisywanie i udostępnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\nW niniejszym wykładzie zostaną przedstawione rozwiązania z wykorzystaniem Gita i GitHuba.\nPrzykładowe repozytorium projektu tidymodels na stronie GitHub wygląda następująco.\nGit w połączeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, który tworzymy, a jednocześnie na udostępnianie go oraz umożliwienie współpracy nad kodem przez wielu użytkowników - współtwórców (ang. contributors) ale nie tylko. Udostępnianie może być zarówno publiczne, jak i prywatne.\nFunkcjonalności GitHub, to:\nŁącząc Git z Githubem, programiści zyskują mocne narzędzie do kontroli wersji, współpracy, śledzenia problemów i automatyzacji procesów, co przyczynia się do skutecznego zarządzania projektami oprogramowania1."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "Wykład 1",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nNie wszystkie z powyższych tematów uda nam się omówić na wykładzie ale większość zostanie zademonstrowana.↩︎\nskrót od repozytorium↩︎\nwprawdzie na tym etapie dodaliśmy plik README.md ale ponieważ jest to pierwszy commit to tak go nazwaliśmy.↩︎"
  }
]