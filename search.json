[
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "Wykład 2",
    "section": "",
    "text": "Przypominając sytuację w jakiej się znajdujemy… utworzyliśmy repozytorium o nazwie DariuszMajerek/Github_tests. Dokonaliśmy w nim kilku zmian commitowanych za każdym razem. Podgląd tych zmian możemy dokonać przez przegląd commitów.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nWarning\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nCaution\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nImportant\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "Wykład 2",
    "section": "",
    "text": "Zmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać fork takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo octocat/Spoon-Knife1. Można tego dokonać na stronie repo kliknąć przycisk fork\n\nZostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.\n\nWybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.\n\nKopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:\n\nprzejść do katalogu, w którym chcemy zapisać kopię repo\nskopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)\nwykonać polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza właśnie skopiowany adres repo.\n\n# najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)\npwd\n\n# przejdź do katalogu wyżej (tam chcę skopiować repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nWarning\n\n\n\nZnów czujne oko wychwyci, że podając adres repo zmieniłem go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.\n\n\nPo skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku style.css. W części dotyczącej stylu paragrafu zmienimy dwie wartości:\n\noryginalne wartości\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartości po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdźmy czy zmiany zostały zarejestrowane\ngit status\n\n# możemy ponadto podejrzeć zmiany za pomocą\ngit diff\n\nTeraz zmiany trzeba zatwierdzić i commitować.\ngit add .\ngit commit -m \"style changes\"\nNastępnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy główną gałąź do repo zdalnego\ngit push origin main\n\nTeraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.\n\n\n\n\n\n\nCaution\n\n\n\nZa każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "Wykład 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.\ngit log\n\nWidać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.\nCofanie stanu repo można wykonać na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziałanie obu tych funkcji różni się nieco i obie je omówimy.\n\n\nPolecenie git reset służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem git reset ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.\n\n\n\n\n\n\nImportant\n\n\n\nMożesz użyć wielu opcji wraz z git reset, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianę odniesienia HEAD (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą --soft w następujący sposób:\n\ngit reset --soft HEAD~n aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.\n\n\n\nPrzykład użycia git reset –soft HEAD\n\n\nFlaga --mixed jest domyślnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUżywamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed git push.\n\n\n\nPrzykład użycia git reset –mixed HEAD\n\n\nFlaga --hard powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja --hard odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.\n\n\n\nPrzykład użycia git reset –hard HEAD\n\n\n\n\n\nSchemat działania git reset\n\n\n\n\n\nPolecenie git revert służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do git reset, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, git revert tworzy nowy commit, który odwraca zmiany w poprzednim commicie.\nPokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykład użycia git revert\n\n\nPo użyciu git revert nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.\nRóżnice między git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowując historię.\ngit reset przemieszcza wskaźnik HEAD, usuwając zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.\n\n\n\n\nSchemat działania git revert\n\n\nTeraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonać następujące czynności w katalogu Spoon-Knife.\nJeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia git reset w trybie --hard. Jednak pamiętaj, że git reset --hard jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.\nOto kroki, które możesz podjąć:\n\nSprawdź dostępne gałęzie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdź do gałęzi, w której chcesz cofnąć zmiany:\n\n# to nie jest konieczne bo już jesteśmy w tej gałęzi\n# ale nie zawsze tak będzie\ngit checkout main\n\nZidentyfikuj commit, do którego chcesz się cofnąć:\n\ngit log\nOdnajdź hasz commitu, do którego chcesz się cofnąć.\n\nUżyj git reset --hard do cofnięcia zmian:\n\ngit reset --hard hasz-commitu\nZastąp hasz-commitu odpowiednim hasłem commitu, do którego chcesz się cofnąć.\n\nPrzesuń zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: Użycie --force jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając --force, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.\n\n\n\nPrzejście do stanu z wcześniejszego commita\n\n\nW ten sposób wróciliśmy do oryginalnego stanu pobranego repo octocat/Spoon-Knife. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez pull request."
  },
  {
    "objectID": "wyk2.html#działanie-na-gałęziach",
    "href": "wyk2.html#działanie-na-gałęziach",
    "title": "Wykład 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w której gałęzi jesteśmy\ngit branch\n\n# teraz tworzymy nową gałąź w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynności można wykonać jedną komendą\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, których dokonaliśmy w gałęzi głównej.\n# po zmianach sprawdzamy status repo w gałęzi my_branch\ngit status\n\n# widać że zmiany nastąpiły więc je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gałęzi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian\n\n\nJak można zauważyć na powyższym obrazku system sugeruje dokonanie pull request, czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli merge) gałęzi głównej z gałęzią my_branch.\nAby dokonać pull request nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.\n\nUtwórz nową gałąź w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gałęzi\nWykonaj pracę na tej gałęzi i zatwierdzaj zmiany.\nPush nowej gałęzi na repozytorium zdalne:\ngit push origin nazwa-nowej-gałęzi\nTo przesyła nową gałąź na repozytorium zdalne2.\nOtwórz przeglądarkę i przejdź do repozytorium na GitHubie.\nPrzejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.\nUtwórz Pull Request:\n\nNa stronie gałęzi wybierz przycisk “New pull request”.\nWybierz gałąź docelową, zazwyczaj jest to master lub inna główna gałąź.\n\nUzupełnij informacje dotyczące Pull Request:\n\nUzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.\nSprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.\n\nUtwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.\nDokonaj przeglądu i zatwierdź:\n\nInni członkowie zespołu mogą dokonać przeglądu zmian.\nPo zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposób przyniesiesz zmiany z gałęzi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "Wykład 2",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nEwentualne zmiany nie popsują niczego w tym repo, bo jest ono przygotowane do tego typu testów.↩︎\nDotąd mamy wszystko zrobione↩︎"
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "Wykład 1",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych.\n\n\n\n\n\n\n\nKonieczne w tym procesie jest kontrolowanie aktualnej wersji modelu i wszystkich przyległości z nim związanych. Idealnym narzędziem do zautomatyzowania czynności polegających na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program działający w terminalu ale istnieją również jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednocześnie połączony z hubem (czyli kontenerem) pozwalającym na przechowywanie i udostępnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usługa serwerowa, która pozwala na zapisywanie i udostępnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\n\n\n\n\n\n\n\nW niniejszym wykładzie zostaną przedstawione rozwiązania z wykorzystaniem Gita i GitHuba.\nPrzykładowe repozytorium projektu tidymodels na stronie GitHub wygląda następująco.\n\n\n\nStrona projektu tidymodels na GitHubie\n\n\nGit w połączeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, który tworzymy, a jednocześnie na udostępnianie go oraz umożliwienie współpracy nad kodem przez wielu użytkowników - współtwórców (ang. contributors) ale nie tylko. Udostępnianie może być zarówno publiczne, jak i prywatne.\nFunkcjonalności GitHub, to:\n\nKontrola wersji kodu.\nKopiowanie kodu na dwa sposoby:\n\nClone:\n\nKlonowanie repozytorium oznacza skopiowanie zdalnego repozytorium na lokalny komputer.\nGdy klonujesz repozytorium, uzyskujesz identyczną kopię zawartości, historii i gałęzi tego repozytorium na swoim lokalnym systemie.\nMożesz pracować nad projektem lokalnie i wysyłać swoje zmiany z powrotem do zdalnego repozytorium.\n\nPrzykład klonowania repozytorium:\n\ngit clone https://github.com/nazwa_uzytkownika/nazwa_repozytorium.git\n\nFork:\n\nForking (rozszerzanie) repozytorium oznacza utworzenie kopii zdalnego repozytorium w obrębie twojego konta na GitHubie.\nKiedy forkujesz repozytorium, masz własną kopię, którą możesz dowolnie modyfikować, nie wpływając na oryginalne repozytorium.\nForkowanie jest często używane w projekcie open source, gdzie chcesz dodać swoje zmiany, ale nie masz bezpośredniego dostępu do repozytorium.\n\nPrzykład forka repozytorium:\n\nNa stronie repozytorium w witrynie GitHub klikasz przycisk “Fork” w prawym górnym rogu. To utworzy kopię tego repozytorium w twoim własnym koncie.\n\nForking pozwala ci pracować niezależnie nad projektem, a następnie możesz zgłosić pull request (prośbę o zaakceptowanie zmian) do oryginalnego repozytorium, aby właściciel mógł uwzględnić twoje zmiany.\n\nZarządzanie Branchami:\n\nGitHub oferuje narzędzia do łatwego zarządzania gałęziami (branches). Możesz tworzyć, usuwać i łączyć gałęzie za pomocą interfejsu graficznego.\n\nKomentarze i Dyskusje:\n\nMożliwość dodawania komentarzy do kodu źródłowego, pull requestów i problemów ułatwia komunikację w zespole.\n\nIssues:\n\nGitHub umożliwia śledzenie problemów i zadań (issues). Możesz tworzyć, przypisywać, zamykać i dyskutować na temat problemów, co ułatwia śledzenie postępów w projekcie.\n\nIntegracje i Webhooks:\n\nGitHub oferuje integracje z różnymi narzędziami i usługami, co umożliwia automatyzację różnych procesów w projekcie. Webhooki pozwalają na powiadamianie zewnętrznych usług o zdarzeniach na GitHubie.\n\nPull Request Reviews:\n\nMożliwość recenzowania kodu źródłowego w ramach pull requestów. Recenzenci mogą komentować zmiany, proponować poprawki i potwierdzać gotowość do zaakceptowania zmian.\n\nGitHub Actions:\n\nGitHub Actions to funkcja pozwalająca na automatyzację procesów budowania, testowania i wdrażania kodu źródłowego za pomocą skryptów.\n\nBezpieczeństwo:\n\nGitHub oferuje funkcje zabezpieczające, takie jak uwierzytelnianie dwuskładnikowe, zarządzanie dostępem i audyt.\n\n\nŁącząc Git z Githubem, programiści zyskują mocne narzędzie do kontroli wersji, współpracy, śledzenia problemów i automatyzacji procesów, co przyczynia się do skutecznego zarządzania projektami oprogramowania1.\n\n\n\n\nAby stworzyć jakiekolwiek repozytorium, trzeba mieć miejsce, w którym to zrobimy. A zatem utworzymy nowe konto na GitHub.\n\nPrzejdź na stronę https://github.com/\n\n\n\nStrona domowa GitHub\n\n\nNastępnie wpisz w miejsce na email swój adres poczty.\nW kolejnym kroku wypełnij pola na stronie\n\nPo wypełnieniu wszystkich pól zostaniesz poproszony o rozwiązanie testu na sprawdzenie czy jesteś człowiekiem 🙉.\n\nWpisz kod, który otrzymasz na podany przez Ciebie email.\n\nW kolejnym oknie wybierz interesujące Cię funkcjonalności (możesz też nie wybierać żadnej).\n\nNa kolejnej stronie można wybrać darmowe konto regularnego użytkownika ale jest też możliwość założenia konta studenckiego (wówczas trzeba przy logowaniu podać email uczelniany po czym nastąpi weryfikacja). Konto studenckie daje nieco więcej możliwości ale konto darmowe wystarczy do naszych zadań.\n\nW kolejnym kroku powinieneś już zostać przeniesiony do strony głównej Twojego konta na Githubie 👏.\n\n\nChoć wydaje się, że to koniec, to niestety tak nie jest 🤯. W roku 2022 GitHub wprowadził dodatkowe zabezpieczenia i każde połączenie z GitHubem musi być uwierzytelnione (wcześniej też tak było ale mimo to nieco prościej można było to zrobić). Instrukcję jak uwierzytelnić GitHub wraz z instalacją i dodaniem klucza publicznego SSH w Windows można znaleźć pod adresem Instalacja Gita z SSH. Instrukcję dodawania klucza SSH dla różnych platform można znaleźć pod adresem https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account.\nMożemy teraz przystąpić do tworzenia repozytorium 😲 . Załóżmy, że będzie to repozytorium przeznaczone do testów (stąd nazwa Github_tests).\n\n\n\nNazwa ta pewnie jest używana wielokrotnie w całym Githubie (patrz 👉) ale my tworzymy repozytorium w ramach naszego konta dlatego faktycznie nazwa repozytorium będzie następująca DariuszMajerek/Github_tests - czyli jest połączeniem nazwy użytkownika i repozytorium.\n\n\n\n\n\nPuste repozytorium wygląda następująco.\n\n\n\n\n\n\n\nImportant\n\n\n\nNajważniejsze z tej strony jest aby skopiować adres repozytorium w formie HTTPS https://github.com/DariuszMajerek/Github_tests.git lub SSH git@github.com:DariuszMajerek/Github_tests.git.\n\n\n\n\n\n\nPóki co istniej tylko repozytorium zdalne (na Githubie, z resztą puste) ale nie istnieje jego odpowiednik na dysku lokalnym. W tym celu należy utworzyć katalog o tej samej nazwie co nazwa repozytorium (bez nazwy użytkownika) a następnie przejść do tego katalogu.\n\n\n\nTworzenie katalogu repo\n\n\n\n\n\n\n\n\nCaution\n\n\n\nPowyższy ekran może nieco inaczej wyglądać w innych systemach operacyjnych.\n\n\nW katalogu repo2 inicjujemy repo lokalne poprzez\ngit init\n\n# nastepnie sprawdzamy status repo\ngit status\n\nZainicjowanie lokalnego repo pozwala wymieniać dane pomiędzy repo lokalnym i zdalnym (w obie strony). Możemy o tym myśleć w ten sposób, że są trzy stany naszego repo:\n\nlokalne - na dysku (ang. working dir);\nzdalne - na serwerze np. Github (ang. HEAD);\ntymczasowe - instancja naszego repo w wersji tymczasowej istniejąca na dysku (ang. index), która powinna zostać przesłana (wypchnięta - push) na serwer. Ta czynność jest opisana w tę stronę, bo najczęściej to zmiany na dysku lokalnym, gdzie tworzymy model, wypychamy na serwer.\n\n\n\n\nTrzy stany repo\n\n\nInicjacja jedynie tworzy katalog .git z plikami konfiguracyjnymi repo. Nic poza tym katalogiem nie zawiera. Teraz przystąpimy do dodania pierwszego pliku do repo. Dobrym zwyczajem jest dodanie pliku README.md, w którym znajdą się podstawowe informacje dotyczące repo. Plik ten powinien być napisany w języku markdown aby GitHub mógł bo przetworzyć i wyświetlić w sformatowany sposób.\n# plik README.md można utworzyć na kilka sposóbów, m.in w R\n# w poniższym przykładzie pokazuję jak to można zrobić w terminalu\n# poniższy kod stworzy nowy plik README.md i doda jedynie tytuł rozdziału \necho \"# Github_tests\" &gt;&gt; README.md\nJak widać na załączonym obrazie powstał plik README.md i został wypełniony treścią.\n\nPonieważ nastąpiły pierwsze zmiany w repo (dodaliśmy plik README.md), to możemy te zmiany wysłać na serwer, na którym obecnie zmiany te nie są jeszcze uwzględnione.\n# dodajemy plik README.md do commita, czyli nowej wersji repo\n# commitami oznaczamy nowe wersje repo\ngit add README.md\n\n# jeśli chcemy dodać więcej plików i katalogów jednocześnie (a tak się dzieje najczęściej)\n# bo chcemy commitować stan po zmianach w repo to wywołujemy\ngit add .\nPo tej czynności możemy sprawdzić status repo za pomocą\ngit status\nWynik tych działań jest następujący\n\n\n\nRepo po zmianach\n\n\nJak widać plik README.md został dodany do tymczasowego stanu repo ale nie został on jeszcze przesłany na serwer. Widać też, że żaden commit nie został utworzony. Przez commit rozumiemy jakby snapshot obecnego stanu repo. Póki go nie wypchniemy na serwer zmiany te są zapisane jedynie lokalnie. Przejdźmy do pierwszego commitu naszego repo. Każdy commit powinien być opatrzony komentarzem, który informuje nas co zmieniliśmy w repo3. Flaga -m oznacza chęć dodania komentarza.\ngit commit -m \"pierwszy commit\"\nPo wykonaniu commita i sprawdzeniu stanu\n\nChoć stworzyliśmy commita, więc zapisaliśmy stan repo po zmianach, to zmiany te nie zostały zaktualizowane na serwerze GitHub. Aby tego dokonać musimy podać adres repo zdalnego oraz wypchnąć lokalne zmiany na serwer.\n# podłączenie zdalnego repo pod nazwą origin\ngit remote add origin \"git@github.com:DariuszMajerek/Github_tests.git\"\n\n\n\nPozostało nam wypchnąć pliki na serwer.\n# ponieważ wypychamy główną gałąź nazwaną main to komenda jest następująca\ngit push -u origin main\nUstawienie flagi -u w poleceniu git push ustawia tzw upstream. W przyszłości jeśli chcemy wypchnąć stan repo lokalnego wystarczy komenda git push bez origin i main o ile chcemy wysłać wszystko do tej samej gałęzi.\nW momencie wywołania tej komendy będziemy prawdopodobnie poproszeni o hasło do konta GitHub. Jeśli się wszystko powiedzie, to ekran powinien wyglądać następująco.\n\n\n\nREADME.md dodane do repo zdalnego\n\n\nI faktycznie w repo zdalnym się to znajduje\n\n\n\nUwaga: w kolejnej próbie (bo pierwsza się nie udała) dodałem commit z inną nazwą “first commit”\n\n\nPo dodaniu commita i push do gałęzi głównej main stan repo lokalnego (na dysku komputera) i zdalnego są identyczne.\n\nJeśli chcemy pobrać obecny stan repo na dysk lokalny, wówczas używamy komendy git pull remote_name branch_name, gdzie remote_name oznacza adres zdalnego repo, a branch_name nazwę gałęzi jaką chcemy pobrać (w tym momencie nasze repo posiada tylko jedną gałąź ale w przyszłości może mieć ich więcej).\n\n\n\n\n\n\nImportant\n\n\n\nBardzo ważną zasadą jest to aby repo zdalne i lokalne były identyczne. Dbać o to będzie sam git. Natomiast jeśli zaczynamy pracować nad rozwojem repo, dobrą praktyką jest najpierw pobranie obecnego stanu repo zdalnego przez komendę git pull.\n\n\nMoże się również zdarzyć, że współpracownicy, którzy pracują równolegle nad naszym projektem mogą dokonać zmiany zdalnego repo i wówczas pobranie obecnego stanu repo zdalnego jest niemal zawsze konieczne.\nPonieważ zmian w repo zdalnym można dokonywać za pomocą przeglądarki i strony GitHub, to dokonamy rozwinięcia README.md. Zmiany dokonywane na serwerze (poprzez stronę internetową) wymagają również commitowania zmian, tak abyśmy mogli kontrolować wersję naszego repo. W pliku README.md dodałem jedno zdanie o treści “To repozytarium będzie służyć do ćwiczeń związanych z usługami kontroli wersji.” i commitowałem to z komentarzem “Update README.md”.\n\nTo jest stan najbardziej aktualny naszego repo. Dlatego pobierzemy go na dysk aby repo lokalne i zdalne się zgadzały.\n# pobieramy aktualny stan repo zdalnego\n# ponieważ mamy tylko jedną gałąź a origin jest ustawione na właściwe repo\n# ponadto ustawiliśmy wcześniej flagę przy push -u to nie musimy dodawać innych parametrów\ngit pull\n\n\n\nEfekt działania git pull\n\n\nCzujne oko pewnie już zauważyło, że w pliku README.md wpisując zdanie popełniłem błąd (literówkę) w słowie repozytorium. Ponieważ plik mamy pobrany do lokalnego repo, to możemy go poprawić (lokalnie np. w RStudio) i wypchnąć na serwer. Po zmianach lokalnego repo stan jest następujący\n\nJak widać część zmian nie została commitowana. Zmiany dokonane lokalnie najpierw trzeba dodać do tzw Stage, a następnie je commitować.\ngit add . # dodajemy zmiany do Stage\ngit status # po to by zobaczyć stan Stage\ngit commit -m \"Fix typo in README.md\"\ngit stage\n\n# podobnie przy wypychaniu jeśli chcemy wypchnąć do gałęzi głównej\n# to nie musimy dodawać parametrów przy git push\ngit push\n\n\n\nStan po wypchnięciu danych na serwer\n\n\nZmiany na serwerze zostały zapisane.\n\n\n\n\n\n\n\nNote\n\n\n\nPolecenie git pull jest połączeniem git fetch, które pobiera ostatnie zatwierdzenia w lokalnym repozytorium i git merge, które połączy gałąź ze zdalnej do lokalnej gałęzi."
  },
  {
    "objectID": "wyk1.html#przebieg-prac-nad-wdrożeniem-modelu",
    "href": "wyk1.html#przebieg-prac-nad-wdrożeniem-modelu",
    "title": "Wykład 1",
    "section": "",
    "text": "Budowa modeli i ich późniejsze wdrażanie odbywa się w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejściu do rozwiązania problemu badawczego. Najczęściej w toku kolejnych korekt powstaje ostateczny projekt, który może zostać zaimplementowany na serwerze klienckim, czy urządzeniu docelowym. Nierzadko również (szczególnie w przypadku rozbudowanych modeli) pracę nad nim prowadzi kilka osób. Wydana wersja modelu może również charakteryzować się pewnymi błędami czy niedogodnościami, sugerowanymi przez użytkowników. To powoduje, że tzw ‘ostateczna’ wersja musi być również poprawiana. Przebieg przygotowania modelu i jego wdrożenia może wyglądać następująco:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, który chcesz rozwiązać za pomocą modelu.\nOkreśl cele, jakie chcesz osiągnąć.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieć charakterystyki danych.\nWykrywanie brakującymi danych, anomalii czy outlierów.\n\nPrzygotowanie danych:\n\nPodziału danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeśli jest to konieczne.\n\nWybór modelu:\n\nWybór odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrów modelu w celu optymalizacji wyników.\n\nTrening modelu:\n\nUczenie modelu korzystając z zestawu treningowego.\n\nWalidacja modelu:\n\nUżycie zestawu walidacyjnego do oceny skuteczności modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajność (regularyzacja, zmiana architektury, optymalizacja hiperparametrów, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdrażanie modelu:\n\nPrzygotowanie modelu do wdrożenia, uwzględniając aspekty wydajnościowe i skalowalność.\nPrzygotowanie aplikacji (API) pozwalającej na umieszczenie modelu na serwerze lub urządzeniu docelowym.\n\n\nW zależności od sytuacji, model może być również monitorowany i aktualizowany. Niezbędna może być również dokumentacja techniczna ułatwiająca zrozumienie i utrzymanie modelu przez odbiorców końcowych.\n\n\n\n\n\n\n\nKonieczne w tym procesie jest kontrolowanie aktualnej wersji modelu i wszystkich przyległości z nim związanych. Idealnym narzędziem do zautomatyzowania czynności polegających na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program działający w terminalu ale istnieją również jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednocześnie połączony z hubem (czyli kontenerem) pozwalającym na przechowywanie i udostępnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usługa serwerowa, która pozwala na zapisywanie i udostępnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\n\n\n\n\n\n\n\nW niniejszym wykładzie zostaną przedstawione rozwiązania z wykorzystaniem Gita i GitHuba.\nPrzykładowe repozytorium projektu tidymodels na stronie GitHub wygląda następująco.\n\n\n\nStrona projektu tidymodels na GitHubie\n\n\nGit w połączeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, który tworzymy, a jednocześnie na udostępnianie go oraz umożliwienie współpracy nad kodem przez wielu użytkowników - współtwórców (ang. contributors) ale nie tylko. Udostępnianie może być zarówno publiczne, jak i prywatne.\nFunkcjonalności GitHub, to:\n\nKontrola wersji kodu.\nKopiowanie kodu na dwa sposoby:\n\nClone:\n\nKlonowanie repozytorium oznacza skopiowanie zdalnego repozytorium na lokalny komputer.\nGdy klonujesz repozytorium, uzyskujesz identyczną kopię zawartości, historii i gałęzi tego repozytorium na swoim lokalnym systemie.\nMożesz pracować nad projektem lokalnie i wysyłać swoje zmiany z powrotem do zdalnego repozytorium.\n\nPrzykład klonowania repozytorium:\n\ngit clone https://github.com/nazwa_uzytkownika/nazwa_repozytorium.git\n\nFork:\n\nForking (rozszerzanie) repozytorium oznacza utworzenie kopii zdalnego repozytorium w obrębie twojego konta na GitHubie.\nKiedy forkujesz repozytorium, masz własną kopię, którą możesz dowolnie modyfikować, nie wpływając na oryginalne repozytorium.\nForkowanie jest często używane w projekcie open source, gdzie chcesz dodać swoje zmiany, ale nie masz bezpośredniego dostępu do repozytorium.\n\nPrzykład forka repozytorium:\n\nNa stronie repozytorium w witrynie GitHub klikasz przycisk “Fork” w prawym górnym rogu. To utworzy kopię tego repozytorium w twoim własnym koncie.\n\nForking pozwala ci pracować niezależnie nad projektem, a następnie możesz zgłosić pull request (prośbę o zaakceptowanie zmian) do oryginalnego repozytorium, aby właściciel mógł uwzględnić twoje zmiany.\n\nZarządzanie Branchami:\n\nGitHub oferuje narzędzia do łatwego zarządzania gałęziami (branches). Możesz tworzyć, usuwać i łączyć gałęzie za pomocą interfejsu graficznego.\n\nKomentarze i Dyskusje:\n\nMożliwość dodawania komentarzy do kodu źródłowego, pull requestów i problemów ułatwia komunikację w zespole.\n\nIssues:\n\nGitHub umożliwia śledzenie problemów i zadań (issues). Możesz tworzyć, przypisywać, zamykać i dyskutować na temat problemów, co ułatwia śledzenie postępów w projekcie.\n\nIntegracje i Webhooks:\n\nGitHub oferuje integracje z różnymi narzędziami i usługami, co umożliwia automatyzację różnych procesów w projekcie. Webhooki pozwalają na powiadamianie zewnętrznych usług o zdarzeniach na GitHubie.\n\nPull Request Reviews:\n\nMożliwość recenzowania kodu źródłowego w ramach pull requestów. Recenzenci mogą komentować zmiany, proponować poprawki i potwierdzać gotowość do zaakceptowania zmian.\n\nGitHub Actions:\n\nGitHub Actions to funkcja pozwalająca na automatyzację procesów budowania, testowania i wdrażania kodu źródłowego za pomocą skryptów.\n\nBezpieczeństwo:\n\nGitHub oferuje funkcje zabezpieczające, takie jak uwierzytelnianie dwuskładnikowe, zarządzanie dostępem i audyt.\n\n\nŁącząc Git z Githubem, programiści zyskują mocne narzędzie do kontroli wersji, współpracy, śledzenia problemów i automatyzacji procesów, co przyczynia się do skutecznego zarządzania projektami oprogramowania1.\n\n\n\n\nAby stworzyć jakiekolwiek repozytorium, trzeba mieć miejsce, w którym to zrobimy. A zatem utworzymy nowe konto na GitHub.\n\nPrzejdź na stronę https://github.com/\n\n\n\nStrona domowa GitHub\n\n\nNastępnie wpisz w miejsce na email swój adres poczty.\nW kolejnym kroku wypełnij pola na stronie\n\nPo wypełnieniu wszystkich pól zostaniesz poproszony o rozwiązanie testu na sprawdzenie czy jesteś człowiekiem 🙉.\n\nWpisz kod, który otrzymasz na podany przez Ciebie email.\n\nW kolejnym oknie wybierz interesujące Cię funkcjonalności (możesz też nie wybierać żadnej).\n\nNa kolejnej stronie można wybrać darmowe konto regularnego użytkownika ale jest też możliwość założenia konta studenckiego (wówczas trzeba przy logowaniu podać email uczelniany po czym nastąpi weryfikacja). Konto studenckie daje nieco więcej możliwości ale konto darmowe wystarczy do naszych zadań.\n\nW kolejnym kroku powinieneś już zostać przeniesiony do strony głównej Twojego konta na Githubie 👏.\n\n\nChoć wydaje się, że to koniec, to niestety tak nie jest 🤯. W roku 2022 GitHub wprowadził dodatkowe zabezpieczenia i każde połączenie z GitHubem musi być uwierzytelnione (wcześniej też tak było ale mimo to nieco prościej można było to zrobić). Instrukcję jak uwierzytelnić GitHub wraz z instalacją i dodaniem klucza publicznego SSH w Windows można znaleźć pod adresem Instalacja Gita z SSH. Instrukcję dodawania klucza SSH dla różnych platform można znaleźć pod adresem https://docs.github.com/en/authentication/connecting-to-github-with-ssh/adding-a-new-ssh-key-to-your-github-account.\nMożemy teraz przystąpić do tworzenia repozytorium 😲 . Załóżmy, że będzie to repozytorium przeznaczone do testów (stąd nazwa Github_tests).\n\n\n\nNazwa ta pewnie jest używana wielokrotnie w całym Githubie (patrz 👉) ale my tworzymy repozytorium w ramach naszego konta dlatego faktycznie nazwa repozytorium będzie następująca DariuszMajerek/Github_tests - czyli jest połączeniem nazwy użytkownika i repozytorium.\n\n\n\n\n\nPuste repozytorium wygląda następująco.\n\n\n\n\n\n\n\nImportant\n\n\n\nNajważniejsze z tej strony jest aby skopiować adres repozytorium w formie HTTPS https://github.com/DariuszMajerek/Github_tests.git lub SSH git@github.com:DariuszMajerek/Github_tests.git.\n\n\n\n\n\n\nPóki co istniej tylko repozytorium zdalne (na Githubie, z resztą puste) ale nie istnieje jego odpowiednik na dysku lokalnym. W tym celu należy utworzyć katalog o tej samej nazwie co nazwa repozytorium (bez nazwy użytkownika) a następnie przejść do tego katalogu.\n\n\n\nTworzenie katalogu repo\n\n\n\n\n\n\n\n\nCaution\n\n\n\nPowyższy ekran może nieco inaczej wyglądać w innych systemach operacyjnych.\n\n\nW katalogu repo2 inicjujemy repo lokalne poprzez\ngit init\n\n# nastepnie sprawdzamy status repo\ngit status\n\nZainicjowanie lokalnego repo pozwala wymieniać dane pomiędzy repo lokalnym i zdalnym (w obie strony). Możemy o tym myśleć w ten sposób, że są trzy stany naszego repo:\n\nlokalne - na dysku (ang. working dir);\nzdalne - na serwerze np. Github (ang. HEAD);\ntymczasowe - instancja naszego repo w wersji tymczasowej istniejąca na dysku (ang. index), która powinna zostać przesłana (wypchnięta - push) na serwer. Ta czynność jest opisana w tę stronę, bo najczęściej to zmiany na dysku lokalnym, gdzie tworzymy model, wypychamy na serwer.\n\n\n\n\nTrzy stany repo\n\n\nInicjacja jedynie tworzy katalog .git z plikami konfiguracyjnymi repo. Nic poza tym katalogiem nie zawiera. Teraz przystąpimy do dodania pierwszego pliku do repo. Dobrym zwyczajem jest dodanie pliku README.md, w którym znajdą się podstawowe informacje dotyczące repo. Plik ten powinien być napisany w języku markdown aby GitHub mógł bo przetworzyć i wyświetlić w sformatowany sposób.\n# plik README.md można utworzyć na kilka sposóbów, m.in w R\n# w poniższym przykładzie pokazuję jak to można zrobić w terminalu\n# poniższy kod stworzy nowy plik README.md i doda jedynie tytuł rozdziału \necho \"# Github_tests\" &gt;&gt; README.md\nJak widać na załączonym obrazie powstał plik README.md i został wypełniony treścią.\n\nPonieważ nastąpiły pierwsze zmiany w repo (dodaliśmy plik README.md), to możemy te zmiany wysłać na serwer, na którym obecnie zmiany te nie są jeszcze uwzględnione.\n# dodajemy plik README.md do commita, czyli nowej wersji repo\n# commitami oznaczamy nowe wersje repo\ngit add README.md\n\n# jeśli chcemy dodać więcej plików i katalogów jednocześnie (a tak się dzieje najczęściej)\n# bo chcemy commitować stan po zmianach w repo to wywołujemy\ngit add .\nPo tej czynności możemy sprawdzić status repo za pomocą\ngit status\nWynik tych działań jest następujący\n\n\n\nRepo po zmianach\n\n\nJak widać plik README.md został dodany do tymczasowego stanu repo ale nie został on jeszcze przesłany na serwer. Widać też, że żaden commit nie został utworzony. Przez commit rozumiemy jakby snapshot obecnego stanu repo. Póki go nie wypchniemy na serwer zmiany te są zapisane jedynie lokalnie. Przejdźmy do pierwszego commitu naszego repo. Każdy commit powinien być opatrzony komentarzem, który informuje nas co zmieniliśmy w repo3. Flaga -m oznacza chęć dodania komentarza.\ngit commit -m \"pierwszy commit\"\nPo wykonaniu commita i sprawdzeniu stanu\n\nChoć stworzyliśmy commita, więc zapisaliśmy stan repo po zmianach, to zmiany te nie zostały zaktualizowane na serwerze GitHub. Aby tego dokonać musimy podać adres repo zdalnego oraz wypchnąć lokalne zmiany na serwer.\n# podłączenie zdalnego repo pod nazwą origin\ngit remote add origin \"git@github.com:DariuszMajerek/Github_tests.git\"\n\n\n\nPozostało nam wypchnąć pliki na serwer.\n# ponieważ wypychamy główną gałąź nazwaną main to komenda jest następująca\ngit push -u origin main\nUstawienie flagi -u w poleceniu git push ustawia tzw upstream. W przyszłości jeśli chcemy wypchnąć stan repo lokalnego wystarczy komenda git push bez origin i main o ile chcemy wysłać wszystko do tej samej gałęzi.\nW momencie wywołania tej komendy będziemy prawdopodobnie poproszeni o hasło do konta GitHub. Jeśli się wszystko powiedzie, to ekran powinien wyglądać następująco.\n\n\n\nREADME.md dodane do repo zdalnego\n\n\nI faktycznie w repo zdalnym się to znajduje\n\n\n\nUwaga: w kolejnej próbie (bo pierwsza się nie udała) dodałem commit z inną nazwą “first commit”\n\n\nPo dodaniu commita i push do gałęzi głównej main stan repo lokalnego (na dysku komputera) i zdalnego są identyczne.\n\nJeśli chcemy pobrać obecny stan repo na dysk lokalny, wówczas używamy komendy git pull remote_name branch_name, gdzie remote_name oznacza adres zdalnego repo, a branch_name nazwę gałęzi jaką chcemy pobrać (w tym momencie nasze repo posiada tylko jedną gałąź ale w przyszłości może mieć ich więcej).\n\n\n\n\n\n\nImportant\n\n\n\nBardzo ważną zasadą jest to aby repo zdalne i lokalne były identyczne. Dbać o to będzie sam git. Natomiast jeśli zaczynamy pracować nad rozwojem repo, dobrą praktyką jest najpierw pobranie obecnego stanu repo zdalnego przez komendę git pull.\n\n\nMoże się również zdarzyć, że współpracownicy, którzy pracują równolegle nad naszym projektem mogą dokonać zmiany zdalnego repo i wówczas pobranie obecnego stanu repo zdalnego jest niemal zawsze konieczne.\nPonieważ zmian w repo zdalnym można dokonywać za pomocą przeglądarki i strony GitHub, to dokonamy rozwinięcia README.md. Zmiany dokonywane na serwerze (poprzez stronę internetową) wymagają również commitowania zmian, tak abyśmy mogli kontrolować wersję naszego repo. W pliku README.md dodałem jedno zdanie o treści “To repozytarium będzie służyć do ćwiczeń związanych z usługami kontroli wersji.” i commitowałem to z komentarzem “Update README.md”.\n\nTo jest stan najbardziej aktualny naszego repo. Dlatego pobierzemy go na dysk aby repo lokalne i zdalne się zgadzały.\n# pobieramy aktualny stan repo zdalnego\n# ponieważ mamy tylko jedną gałąź a origin jest ustawione na właściwe repo\n# ponadto ustawiliśmy wcześniej flagę przy push -u to nie musimy dodawać innych parametrów\ngit pull\n\n\n\nEfekt działania git pull\n\n\nCzujne oko pewnie już zauważyło, że w pliku README.md wpisując zdanie popełniłem błąd (literówkę) w słowie repozytorium. Ponieważ plik mamy pobrany do lokalnego repo, to możemy go poprawić (lokalnie np. w RStudio) i wypchnąć na serwer. Po zmianach lokalnego repo stan jest następujący\n\nJak widać część zmian nie została commitowana. Zmiany dokonane lokalnie najpierw trzeba dodać do tzw Stage, a następnie je commitować.\ngit add . # dodajemy zmiany do Stage\ngit status # po to by zobaczyć stan Stage\ngit commit -m \"Fix typo in README.md\"\ngit stage\n\n# podobnie przy wypychaniu jeśli chcemy wypchnąć do gałęzi głównej\n# to nie musimy dodawać parametrów przy git push\ngit push\n\n\n\nStan po wypchnięciu danych na serwer\n\n\nZmiany na serwerze zostały zapisane.\n\n\n\n\n\n\n\nNote\n\n\n\nPolecenie git pull jest połączeniem git fetch, które pobiera ostatnie zatwierdzenia w lokalnym repozytorium i git merge, które połączy gałąź ze zdalnej do lokalnej gałęzi."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "Wykład 1",
    "section": "Footnotes",
    "text": "Footnotes\n\n\nNie wszystkie z powyższych tematów uda nam się omówić na wykładzie ale większość zostanie zademonstrowana.↩︎\nskrót od repozytorium↩︎\nwprawdzie na tym etapie dodaliśmy plik README.md ale ponieważ jest to pierwszy commit to tak go nazwaliśmy.↩︎"
  }
]