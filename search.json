[
  {
    "objectID": "WdraÅ¼anie modeli uczenia maszynowego.html",
    "href": "WdraÅ¼anie modeli uczenia maszynowego.html",
    "title": "WstÄ™p",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych."
  },
  {
    "objectID": "WdraÅ¼anie modeli uczenia maszynowego.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "href": "WdraÅ¼anie modeli uczenia maszynowego.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "title": "WstÄ™p",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych."
  },
  {
    "objectID": "wyk3.html",
    "href": "wyk3.html",
    "title": "WykÅ‚ad 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w jÄ™zyku R i Python (od niedawna, jak jednak bÄ™dÄ™ siÄ™ skupiaÅ‚ na R). Jest to obszar, w ktÃ³rym inÅ¼ynierowie danych i analitycy mogÄ… tworzyÄ‡ interaktywne aplikacje internetowe, wykorzystujÄ…c caÅ‚Ä… swojÄ… wiedzÄ™ i analizy zgromadzonÄ… w jÄ™zyku R. DziÄ™ki Shiny, uÅ¼ytkownicy mogÄ… Å‚atwo przeksztaÅ‚caÄ‡ swoje skrypty i modele w interaktywne aplikacje internetowe, bez koniecznoÅ›ci posiadania wczeÅ›niejszego doÅ›wiadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera siÄ™ na paradygmacie â€œreactive programmingâ€, co oznacza, Å¼e aplikacje tworzone przy jego uÅ¼yciu sÄ… dynamiczne i reagujÄ… na zmiany danych w czasie rzeczywistym. Oznacza to, Å¼e uÅ¼ytkownicy mogÄ… manipulowaÄ‡ danymi i obserwowaÄ‡, jak te zmiany wpÅ‚ywajÄ… na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementÃ³w Shiny jest jego prostota uÅ¼ycia. Za pomocÄ… kilku linii kodu w jÄ™zyku R, moÅ¼na stworzyÄ‡ interaktywny interfejs, ktÃ³ry pozwala uÅ¼ytkownikowi na Å‚atwe eksplorowanie danych. Warto rÃ³wnieÅ¼ podkreÅ›liÄ‡, Å¼e Shiny integruje siÄ™ z istniejÄ…cymi narzÄ™dziami analizy danych w R, takimi jak ggplot2 czy dplyr, co uÅ‚atwia korzystanie z istniejÄ…cych umiejÄ™tnoÅ›ci programistycznych.\nShiny oferuje rÃ³Å¼norodne elementy interfejsu uÅ¼ytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umoÅ¼liwiajÄ…c tworzenie rozbudowanych interfejsÃ³w. Ponadto, framework ten obsÅ‚uguje rÃ³wnieÅ¼ funkcje uwierzytelniania i autoryzacji, co pozwala kontrolowaÄ‡ dostÄ™p do aplikacji w zaleÅ¼noÅ›ci od potrzeb.\nDziÄ™ki Shiny, analiza danych staje siÄ™ bardziej dostÄ™pna i przyjazna dla uÅ¼ytkownika koÅ„cowego, umoÅ¼liwiajÄ…c interaktywnÄ… eksploracjÄ™ wynikÃ³w analizy danych bez koniecznoÅ›ci gÅ‚Ä™bokiego zrozumienia kodu R. To narzÄ™dzie jest szczegÃ³lnie przydatne dla osÃ³b pracujÄ…cych w dziedzinie analizy danych, statystyki, czy nauk spoÅ‚ecznych, ktÃ³re chcÄ… szybko i efektywnie udostÄ™pniÄ‡ swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#czym-jest-shiny",
    "href": "wyk3.html#czym-jest-shiny",
    "title": "WykÅ‚ad 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w jÄ™zyku R i Python (od niedawna, jak jednak bÄ™dÄ™ siÄ™ skupiaÅ‚ na R). Jest to obszar, w ktÃ³rym inÅ¼ynierowie danych i analitycy mogÄ… tworzyÄ‡ interaktywne aplikacje internetowe, wykorzystujÄ…c caÅ‚Ä… swojÄ… wiedzÄ™ i analizy zgromadzonÄ… w jÄ™zyku R. DziÄ™ki Shiny, uÅ¼ytkownicy mogÄ… Å‚atwo przeksztaÅ‚caÄ‡ swoje skrypty i modele w interaktywne aplikacje internetowe, bez koniecznoÅ›ci posiadania wczeÅ›niejszego doÅ›wiadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera siÄ™ na paradygmacie â€œreactive programmingâ€, co oznacza, Å¼e aplikacje tworzone przy jego uÅ¼yciu sÄ… dynamiczne i reagujÄ… na zmiany danych w czasie rzeczywistym. Oznacza to, Å¼e uÅ¼ytkownicy mogÄ… manipulowaÄ‡ danymi i obserwowaÄ‡, jak te zmiany wpÅ‚ywajÄ… na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementÃ³w Shiny jest jego prostota uÅ¼ycia. Za pomocÄ… kilku linii kodu w jÄ™zyku R, moÅ¼na stworzyÄ‡ interaktywny interfejs, ktÃ³ry pozwala uÅ¼ytkownikowi na Å‚atwe eksplorowanie danych. Warto rÃ³wnieÅ¼ podkreÅ›liÄ‡, Å¼e Shiny integruje siÄ™ z istniejÄ…cymi narzÄ™dziami analizy danych w R, takimi jak ggplot2 czy dplyr, co uÅ‚atwia korzystanie z istniejÄ…cych umiejÄ™tnoÅ›ci programistycznych.\nShiny oferuje rÃ³Å¼norodne elementy interfejsu uÅ¼ytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umoÅ¼liwiajÄ…c tworzenie rozbudowanych interfejsÃ³w. Ponadto, framework ten obsÅ‚uguje rÃ³wnieÅ¼ funkcje uwierzytelniania i autoryzacji, co pozwala kontrolowaÄ‡ dostÄ™p do aplikacji w zaleÅ¼noÅ›ci od potrzeb.\nDziÄ™ki Shiny, analiza danych staje siÄ™ bardziej dostÄ™pna i przyjazna dla uÅ¼ytkownika koÅ„cowego, umoÅ¼liwiajÄ…c interaktywnÄ… eksploracjÄ™ wynikÃ³w analizy danych bez koniecznoÅ›ci gÅ‚Ä™bokiego zrozumienia kodu R. To narzÄ™dzie jest szczegÃ³lnie przydatne dla osÃ³b pracujÄ…cych w dziedzinie analizy danych, statystyki, czy nauk spoÅ‚ecznych, ktÃ³re chcÄ… szybko i efektywnie udostÄ™pniÄ‡ swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#czÄ™Å›ci-skÅ‚adowe-aplikacji-shiny",
    "href": "wyk3.html#czÄ™Å›ci-skÅ‚adowe-aplikacji-shiny",
    "title": "WykÅ‚ad 3",
    "section": "CzÄ™Å›ci skÅ‚adowe aplikacji Shiny",
    "text": "CzÄ™Å›ci skÅ‚adowe aplikacji Shiny\nDo poprawnego dziaÅ‚ania aplikacji Shiny konieczne jest zainstalowanie pakietu shiny.\nW kaÅ¼dej aplikacji Shiny moÅ¼na wyrÃ³Å¼niÄ‡ trzy podstawowe czÄ™Å›ci:\n\n\nUI (Interfejs UÅ¼ytkownika):\n\n\nElementy Interfejsu - definiujÄ… strukturÄ™ interfejsu uÅ¼ytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele, wykresy itp.\n\nUkÅ‚ad Strony - okreÅ›la rozmieszczenie i stylizacjÄ™ elementÃ³w na stronie.\n\nDefinicja UI - jest to miejsce, w ktÃ³rym programista okreÅ›la, jak majÄ… wyglÄ…daÄ‡ interaktywne elementy widoczne dla uÅ¼ytkownika.\n\n\n\nPrzykÅ‚ad definicji UI w Shiny moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Moja Aplikacja Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"slider\", \"Wybierz wartoÅ›Ä‡:\", min = 1, max = 100, value = 50)\n    ),\n    mainPanel(\n      plotOutput(\"wykres\")\n    )\n  )\n)\n\n\n\n\nServer (Serwer):\n\n\nFunkcje Obliczeniowe - zawierajÄ… kod R odpowiedzialny za przetwarzanie danych, generowanie wynikÃ³w oraz reakcjÄ™ na interakcje uÅ¼ytkownika.\n\nReaktywnoÅ›Ä‡ - serwer Shiny korzysta z obiektÃ³w reaktywnych do Å›ledzenia zmian w danych i automatycznego aktualizowania wynikÃ³w w interfejsie uÅ¼ytkownika.\n\n\n\nPrzykÅ‚ad definicji serwera w Shiny moÅ¼e wyglÄ…daÄ‡ tak:\n\nKodserver &lt;- function(input, output) {\n  output$wykres &lt;- renderPlot({\n    dane &lt;- seq(1, input$slider)\n    plot(dane, main = \"Wykres dynamiczny\")\n  })\n}\n\n\n\n\nSesja Shiny:\n\n\nKomunikacja UI-Server - kaÅ¼da sesja Shiny umoÅ¼liwia komunikacjÄ™ miÄ™dzy interfejsem uÅ¼ytkownika a serwerem, przesyÅ‚anie danych i instrukcji miÄ™dzy dwiema warstwami aplikacji.\n\nÅ»ywotnoÅ›Ä‡ Aplikacji - sesja utrzymuje stan aplikacji, umoÅ¼liwiajÄ…c Å›ledzenie i reakcjÄ™ na zmiany dokonywane przez uÅ¼ytkownika.\n\n\n\nPrzykÅ‚ad uruchamiania aplikacji Shiny zdefiniowanej powyÅ¼ej:\n\nKodshinyApp(ui, server)\n\n\nDo zapoznania siÄ™ z moÅ¼liwoÅ›ciami aplikacji Shiny zachÄ™cam do uruchomienia nastÄ™pujÄ…cych przykÅ‚adÃ³w aplikacji.\n\nKodrunExample(\"01_hello\")      # a histogram\nrunExample(\"02_text\")       # tables and data frames\nrunExample(\"03_reactivity\") # a reactive expression\nrunExample(\"04_mpg\")        # global variables\nrunExample(\"05_sliders\")    # slider bars\nrunExample(\"06_tabsets\")    # tabbed panels\nrunExample(\"07_widgets\")    # help text and submit buttons\nrunExample(\"08_html\")       # Shiny app built from HTML\nrunExample(\"09_upload\")     # file upload wizard\nrunExample(\"10_download\")   # file download wizard\nrunExample(\"11_timer\")      # an automated timer\n\n\n\n\nPrzykÅ‚ad wywoÅ‚ania przykÅ‚adu â€˜01_helloâ€™\n\nReaktywnoÅ›Ä‡ w Shiny\nReaktywnoÅ›Ä‡ jest kluczowym konceptem w Shiny, ktÃ³ry pozwala interakcji miÄ™dzy komponentami interfejsu uÅ¼ytkownika a kodem R. W Shiny, gdy uÅ¼ytkownik wykonuje interakcjÄ™ (na przykÅ‚ad klikajÄ…c przycisk, wpisujÄ…c tekst, wybierajÄ…c wartoÅ›Ä‡ z rozwijanej listy), aplikacja automatycznie reaguje na tÄ™ interakcjÄ™. To oznacza, Å¼e wynik generowany przez aplikacjÄ™ jest zmienny i dynamicznie dostosowuje siÄ™ do akcji uÅ¼ytkownika, bez koniecznoÅ›ci odÅ›wieÅ¼ania strony.\nReaktywnoÅ›Ä‡ w Shiny opiera siÄ™ na tzw. â€œreactive expressionsâ€ oraz â€œreactive conductorsâ€. â€œReactive expressionsâ€ sÄ… funkcjami, ktÃ³re automatycznie aktualizujÄ… wynik w zaleÅ¼noÅ›ci od zmian w ich zmiennych wejÅ›ciowych. Z kolei â€œreactive conductorsâ€ (takÅ¼e nazywane â€œobsÅ‚uÅ¼onÄ… reakcjÄ…â€) pozwalajÄ… na definiowanie reakcji na zmiany wartoÅ›ci w interfejsie uÅ¼ytkownika.\nPrzykÅ‚ady reaktywnoÅ›ci w Shiny obejmujÄ… dynamiczne odÅ›wieÅ¼anie wykresÃ³w w zaleÅ¼noÅ›ci od wartoÅ›ci wybranych przez uÅ¼ytkownika, automatyczne dostosowanie zakresu danych w oparciu o interakcje uÅ¼ytkownika (np. przesuniÄ™cia suwaka), zmiany zaleÅ¼ne od wprowadzonych danych (np. obliczenia oparte na wartoÅ›ciach wprowadzonych do pÃ³l tekstowych), i wiele innych. ReaktywnoÅ›Ä‡ umoÅ¼liwia tworzenie interfejsÃ³w, ktÃ³re sÄ… interaktywne i dostosowujÄ… siÄ™ do dziaÅ‚aÅ„ uÅ¼ytkownika w czasie rzeczywistym.\n\n\nWyraÅ¼enia reaktywne (reactive()):\n\nReaktywne wyraÅ¼enia to fragmenty kodu, ktÃ³re automatycznie obliczajÄ… i Å›ledzÄ… swoje zaleÅ¼noÅ›ci.\nPrzykÅ‚ad: Reaktywne wyraÅ¼enie, ktÃ³re oblicza sumÄ™ dwÃ³ch wartoÅ›ci wprowadzanych przez uÅ¼ytkownika.\n\n\nKodsuma_reaktywna &lt;- reactive({\n  input$wartosc1 + input$wartosc2\n})\n\n\n\n\nObiekty reaktywne (reactiveValues()):\n\nObiekty reaktywne to struktury danych, ktÃ³re automatycznie Å›ledzÄ… swoje zaleÅ¼noÅ›ci i sÄ… uÅ¼ywane do przechowywania zmiennych, ktÃ³re mogÄ… ulegaÄ‡ zmianom.\nPrzykÅ‚ad: Obiekt reaktywny, ktÃ³ry przechowuje aktualnÄ… wartoÅ›Ä‡ licznika.\n\n\nKodlicznik &lt;- reactiveValues(wartosc = 0)\n\n# Inkrementacja licznika\nobserve({\n  licznik$wartosc &lt;- licznik$wartosc + 1\n})\n\n\n\n\nObserwatory (observe()):\n\nObserwatory to fragmenty kodu, ktÃ³re sÄ… wykonywane w odpowiedzi na zmiany w danych, ale nie zwracajÄ… Å¼adnej wartoÅ›ci.\nPrzykÅ‚ad: Obserwator, ktÃ³ry wypisuje na konsoli aktualnÄ… wartoÅ›Ä‡ suwaka.\n\n\nKodobserve({\n  cat(\"Aktualna wartoÅ›Ä‡ suwaka:\", input$suwak, \"\\n\")\n})\n\n\n\n\nReaktywne Funkcje (render*()):\n\nFunkcje render*() sÄ… uÅ¼ywane w serwerze do generowania wynikÃ³w, ktÃ³re sÄ… automatycznie aktualizowane w interfejsie w zaleÅ¼noÅ›ci od zmian w danych wejÅ›ciowych.\nPrzykÅ‚ad: Renderowanie wykresu w zaleÅ¼noÅ›ci od wartoÅ›ci suwaka.\n\n\nKodoutput$wykres &lt;- renderPlot({\n  dane &lt;- seq(1, input$suwak)\n  plot(dane, main = \"Wykres dynamiczny\")\n})\n\n\n\n\nPrzykÅ‚ad 1\nRozwaÅ¼my prosty przykÅ‚ad zastosowania reaktywnoÅ›ci w Shiny, gdzie uÅ¼ytkownik wprowadza dwie liczby za pomocÄ… pÃ³l tekstowych, a aplikacja reaguje na te zmiany, automatycznie obliczajÄ…c i wyÅ›wietlajÄ…c ich sumÄ™. W tym przykÅ‚adzie wykorzystamy reaktywne wyraÅ¼enia.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Sumator\"),\n  textInput(\"liczba1\", \"WprowadÅº pierwszÄ… liczbÄ™:\", value = \"\"),\n  textInput(\"liczba2\", \"WprowadÅº drugÄ… liczbÄ™:\", value = \"\"),\n  textOutput(\"wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Reaktywne wyraÅ¼enie obliczajÄ…ce sumÄ™ dwÃ³ch liczb\n  suma_reaktywna &lt;- reactive({\n    # Konwertujemy wprowadzone wartoÅ›ci na liczby\n    liczba1 &lt;- as.numeric(input$liczba1)\n    liczba2 &lt;- as.numeric(input$liczba2)\n    \n    # Sprawdzamy, czy wprowadzone wartoÅ›ci sÄ… liczbami\n    if (is.na(liczba1) || is.na(liczba2)) {\n      return(NULL)  # Zwracamy NULL, jeÅ›li dane sÄ… nieprawidÅ‚owe\n    }\n    \n    # Obliczamy sumÄ™\n    suma &lt;- liczba1 + liczba2\n    return(suma)\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$wynik &lt;- renderText({\n    suma &lt;- suma_reaktywna()\n    \n    # Sprawdzamy, czy wynik jest dostÄ™pny\n    if (!is.null(suma)) {\n      return(paste(\"Suma: \", suma))\n    } else {\n      return(\"WprowadÅº poprawne liczby.\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, kiedy uÅ¼ytkownik wprowadza liczby do pÃ³l tekstowych, reaktywne wyraÅ¼enie suma_reaktywna automatycznie oblicza sumÄ™ tych liczb. NastÄ™pnie, przy uÅ¼yciu funkcji renderujÄ…cej renderText, wynik jest wyÅ›wietlany w interfejsie. DziÄ™ki temu podejÅ›ciu, interfejs jest reaktywny na zmiany wprowadzane przez uÅ¼ytkownika, dostosowujÄ…c siÄ™ automatycznie do nowych danych i prezentujÄ…c aktualny wynik.\n\nPrzykÅ‚ad 2\nRozwaÅ¼my teraz przykÅ‚ad zastosowania obiektu reaktywnego w Shiny. W tej sytuacji, uÅ¼ytkownik bÄ™dzie mÃ³gÅ‚ kliknÄ…Ä‡ przycisk, co spowoduje inkrementacjÄ™ wartoÅ›ci licznika. Wykorzystamy do tego celu obiekt reaktywny.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik KlikniÄ™Ä‡\"),\n  actionButton(\"przycisk\", \"Kliknij mnie\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Inicjalizacja obiektu reaktywnego dla licznika\n  licznik &lt;- reactiveValues(licznik_wartosc = 0)\n\n  # Obserwator reagujÄ…cy na klikniÄ™cie przycisku\n  observeEvent(input$przycisk, {\n    # Inkrementacja wartoÅ›ci licznika po klikniÄ™ciu przycisku\n    licznik$licznik_wartosc &lt;- licznik$licznik_wartosc + 1\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$licznik_wynik &lt;- renderText({\n    paste(\"Liczba klikniÄ™Ä‡: \", licznik$licznik_wartosc)\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, obiekt reaktywny licznik jest uÅ¼ywany do przechowywania wartoÅ›ci licznika. Za kaÅ¼dym razem, gdy uÅ¼ytkownik kliknie przycisk, obserwator reaguje na to klikniÄ™cie, inkrementujÄ…c wartoÅ›Ä‡ licznika w obiekcie reaktywnym. NastÄ™pnie, przy uÅ¼yciu funkcji renderujÄ…cej renderText, aktualna wartoÅ›Ä‡ licznika jest wyÅ›wietlana w interfejsie. DziÄ™ki temu, interfejs jest reaktywny na akcje uÅ¼ytkownika, a wartoÅ›Ä‡ licznika automatycznie siÄ™ aktualizuje.\n\nPrzykÅ‚ad 3\nPrzykÅ‚ad zastosowania obserwatora w Shiny moÅ¼na przedstawiÄ‡ na prostym przypadku, gdzie uÅ¼ytkownik wpisuje tekst do pola tekstowego, a aplikacja reaguje na kaÅ¼dÄ… zmianÄ™ i wyÅ›wietla liczbÄ™ znakÃ³w wprowadzonych przez uÅ¼ytkownika. W tym przypadku uÅ¼yjemy funkcji obserwujÄ…cej (observe) do reakcji na zmiany w tekÅ›cie wprowadzonym przez uÅ¼ytkownika.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik ZnakÃ³w\"),\n  textInput(\"tekst_input\", \"WprowadÅº tekst:\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Obserwator reagujÄ…cy na zmiany w tekÅ›cie wprowadzonym przez uÅ¼ytkownika\n  observe({\n    # Pobranie tekstu z pola tekstowego\n    wprowadzony_tekst &lt;- input$tekst_input\n    \n    # Obliczenie liczby znakÃ³w w tekÅ›cie\n    liczba_znakow &lt;- nchar(wprowadzony_tekst)\n    \n    # Aktualizacja wyniku w interfejsie\n    output$licznik_wynik &lt;- renderText({\n      paste(\"Liczba znakÃ³w: \", liczba_znakow)\n    })\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, funkcja observe Å›ledzi zmiany w polu tekstowym (textInput) o nazwie â€œtekst_inputâ€. Za kaÅ¼dym razem, gdy uÅ¼ytkownik wprowadza lub zmienia tekst, obserwator automatycznie aktualizuje wynik w interfejsie, wyÅ›wietlajÄ…c liczbÄ™ znakÃ³w wprowadzonych przez uÅ¼ytkownika. DziÄ™ki obserwatorowi, aplikacja jest reaktywna na zmiany w polu tekstowym bez koniecznoÅ›ci odÅ›wieÅ¼ania strony.\n\nPrzykÅ‚ad 4\nPrzykÅ‚ad wykorzystania renderPlot w Shiny moÅ¼e obejmowaÄ‡ generowanie dynamicznego wykresu w zaleÅ¼noÅ›ci od interakcji uÅ¼ytkownika. PoniÅ¼ej przedstawiam prosty scenariusz, w ktÃ³rym uÅ¼ytkownik moÅ¼e wybieraÄ‡ rodzaj wykresu (liniowy lub punktowy) oraz regulowaÄ‡ parametry, a aplikacja reaguje, generujÄ…c i wyÅ›wietlajÄ…c odpowiedni wykres.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny Wykres\"),\n  selectInput(\"typ_wykresu\", \"Wybierz typ wykresu:\",\n              choices = c(\"Linia\", \"Punkty\")),\n  sliderInput(\"ilosc_punktow\", \"Liczba punktÃ³w:\", min = 10, max = 100, value = 50),\n  plotOutput(\"wykres\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Renderowanie wykresu w zaleÅ¼noÅ›ci od wyboru uÅ¼ytkownika\n  output$wykres &lt;- renderPlot({\n    typ_wykresu &lt;- input$typ_wykresu\n    ilosc_punktow &lt;- input$ilosc_punktow\n    \n    # Generowanie wykresu w zaleÅ¼noÅ›ci od wyboru uÅ¼ytkownika\n    if (typ_wykresu == \"Linia\") {\n      plot(1:ilosc_punktow, type = \"l\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    } else {\n      plot(1:ilosc_punktow, type = \"p\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, uÅ¼ytkownik ma moÅ¼liwoÅ›Ä‡ wyboru rodzaju wykresu (liniowy lub punktowy) za pomocÄ… rozwijanej listy (selectInput). Ponadto, suwak (sliderInput) pozwala regulowaÄ‡ liczbÄ™ punktÃ³w na wykresie. Funkcja renderPlot reaguje na zmiany w tych parametrach, generujÄ…c odpowiedni wykres w zaleÅ¼noÅ›ci od wyboru uÅ¼ytkownika. Wykres jest nastÄ™pnie renderowany w sekcji interfejsu o nazwie â€œwykresâ€.\n\nKolejnoÅ›Ä‡ wykonywanych czynnoÅ›ci w obiektach reaktywnych.\nW grafie reaktywnym w Shiny, kolejnoÅ›Ä‡ wykonywania czynnoÅ›ci jest okreÅ›lana przez zaleÅ¼noÅ›ci miÄ™dzy reaktywnymi elementami. W ogÃ³lnym przypadku, Shiny stosuje podejÅ›cie zwanego â€œreactive programmingâ€, gdzie reaktywne elementy skÅ‚adajÄ… siÄ™ z obiektÃ³w reaktywnych, obserwatorÃ³w i funkcji renderujÄ…cych.\nKolejnoÅ›Ä‡ wykonywania czynnoÅ›ci w grafie reaktywnym moÅ¼e byÄ‡ ogÃ³lnie opisana nastÄ™pujÄ…co:\n\n\nInicjalizacja:\n\nAplikacja Shiny zaczyna od inicjalizacji interfejsu uÅ¼ytkownika (UI) oraz serwera.\nObiekty reaktywne sÄ… tworzone i inicjalizowane zgodnie z ich definicjami.\n\n\n\nObserwatory:\n\nObserwatory reagujÄ… na zmiany w danych i wykonujÄ… odpowiednie akcje.\nObserwatory sÄ… wywoÅ‚ywane w odpowiedzi na zdarzenia, takie jak klikniÄ™cia przyciskÃ³w, zmiany wartoÅ›ci pÃ³l tekstowych itp.\n\n\n\nReaktywne WyraÅ¼enia:\n\nReaktywne wyraÅ¼enia sÄ… obliczane w odpowiedzi na zmiany danych wejÅ›ciowych, na ktÃ³rych zaleÅ¼Ä….\nReaktywne wyraÅ¼enia to fragmenty kodu, ktÃ³re zwracajÄ… wartoÅ›Ä‡ i Å›ledzÄ… swoje zaleÅ¼noÅ›ci.\n\n\n\nFunkcje RenderujÄ…ce:\n\nFunkcje renderujÄ…ce sÄ… wywoÅ‚ywane w celu aktualizacji wynikÃ³w w interfejsie uÅ¼ytkownika na podstawie wartoÅ›ci zwrÃ³conych przez reaktywne wyraÅ¼enia.\nSÄ… one odpowiedzialne za generowanie treÅ›ci do wyÅ›wietlenia, np. w obszarze tekstowym, wykresie czy tabeli.\n\n\n\nAktualizacja UI:\n\nZaktualizowane wyniki sÄ… renderowane w interfejsie uÅ¼ytkownika.\n\n\n\nWaÅ¼ne jest zrozumienie, Å¼e Shiny automatycznie dba o zarzÄ…dzanie zaleÅ¼noÅ›ciami miÄ™dzy reaktywnymi elementami, co oznacza, Å¼e jeÅ›li jedna wartoÅ›Ä‡ zmieni siÄ™, to wszystkie elementy zaleÅ¼ne od niej zostanÄ… automatycznie zaktualizowane. DziÄ™ki temu podejÅ›ciu, Shiny zapewnia spÃ³jnoÅ›Ä‡ danych i dynamiczne dostosowywanie interfejsu uÅ¼ytkownika w zaleÅ¼noÅ›ci od akcji uÅ¼ytkownika lub zmian w danych.\nWyglÄ…d aplikacji Shiny\nShiny oferuje wiele moÅ¼liwoÅ›ci do tworzenia interaktywnych i estetycznych layoutÃ³w dla aplikacji. MoÅ¼na korzystaÄ‡ z rÃ³Å¼nych funkcji i elementÃ³w interfejsu uÅ¼ytkownika, aby dostosowaÄ‡ wyglÄ…d i ukÅ‚ad strony. PoniÅ¼ej przedstawiam kilka kluczowych moÅ¼liwoÅ›ci i technik budowy layoutÃ³w w Shiny:\n\n\nFluid Grid Layout:\n\n\nfluidPage() to podstawowa funkcja sÅ‚uÅ¼Ä…ca do tworzenia responsywnego ukÅ‚adu strony.\nObejmuje rÃ³Å¼ne sekcje takie jak titlePanel, sidebarLayout, mainPanel itp., ktÃ³re pomagajÄ… w organizacji i strukturyzacji interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Elementy boczne, np. suwaki, przyciski\n    ),\n    mainPanel(\n      # GÅ‚Ã³wna zawartoÅ›Ä‡, np. wykresy, tabele\n    )\n  )\n)\n\n\n\n\nColumn Layout:\n\nMoÅ¼na uÅ¼ywaÄ‡ column() do podziaÅ‚u obszaru gÅ‚Ã³wnego na kolumny, co pozwala na bardziej elastyczny ukÅ‚ad strony.\nTo przydatne, gdy chcemy umieÅ›ciÄ‡ rÃ³Å¼ne elementy obok siebie.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  column(\n    width = 4,\n    # Pierwsza kolumna\n  ),\n  column(\n    width = 8,\n    # Druga kolumna\n  )\n)\n\n\n\n\nTabset Panel:\n\n\ntabsetPanel() umoÅ¼liwia organizacjÄ™ interfejsu za pomocÄ… zakÅ‚adek.\nKaÅ¼da zakÅ‚adka moÅ¼e mieÄ‡ wÅ‚asny zestaw elementÃ³w interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  tabsetPanel(\n    tabPanel(\"ZakÅ‚adka 1\", \n             # ZawartoÅ›Ä‡ pierwszej zakÅ‚adki),\n    tabPanel(\"ZakÅ‚adka 2\", \n             # ZawartoÅ›Ä‡ drugiej zakÅ‚adki)\n  )\n)\n\n\n\n\nHTML i CSS:\n\nShiny umoÅ¼liwia wbudowanie kodu HTML i CSS do dostosowywania wyglÄ…du.\nFunkcje takie jak HTML() pozwalajÄ… na wstawienie kodu HTML bezpoÅ›rednio do interfejsu uÅ¼ytkownika.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  HTML(\"&lt;h2&gt;WÅ‚asny tytuÅ‚ HTML&lt;/h2&gt;\")\n)\n\n\n\n\nDashboard Layout:\n\nBiblioteka shinydashboard dostarcza narzÄ™dzi do tworzenia ukÅ‚adÃ³w przypominajÄ…cych klasyczne dashboardy.\nObejmuje funkcje takie jak dashboardPage(), dashboardHeader(), dashboardSidebar().\n\n\nKodlibrary(shinydashboard)\n\nui &lt;- dashboardPage(\n  dashboardHeader(title = \"Dashboard Title\"),\n  dashboardSidebar(\n    # Elementy boczne, np. suwaki, przyciski\n  ),\n  dashboardBody(\n    # GÅ‚Ã³wna zawartoÅ›Ä‡, np. wykresy, tabele\n  )\n)"
  },
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "PrzypominajÄ…c sytuacjÄ™ w jakiej siÄ™ znajdujemyâ€¦ utworzyliÅ›my repozytorium o nazwie DariuszMajerek/Github_tests. DokonaliÅ›my w nim kilku zmian commitowanych za kaÅ¼dym razem. PodglÄ…d tych zmian moÅ¼emy dokonaÄ‡ przez przeglÄ…d commitÃ³w.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeÅ¼enie\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nZagroÅ¼enie\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nWaÅ¼ne\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "Zmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeÅ¼enie\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nZagroÅ¼enie\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nWaÅ¼ne\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request."
  },
  {
    "objectID": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "href": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "WykÅ‚ad 2",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nEwentualne zmiany nie popsujÄ… niczego w tym repo, bo jest ono przygotowane do tego typu testÃ³w.â†©ï¸\nDotÄ…d mamy wszystko zrobioneâ†©ï¸"
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "WykÅ‚ad 1",
    "section": "",
    "text": "PoniewaÅ¼ proces budowy i udoskonalania modelu moÅ¼e trwaÄ‡ dÅ‚ugo i byÄ‡ prowadzony przez kilka osÃ³b, to kontrolowanie wersji modelu wydaje siÄ™ byÄ‡ konieczne.\nPonadto konieczne w tym procesie jest kontrolowanie zarÃ³wno aktualnej wersji modelu, jak i wszystkich przylegÅ‚oÅ›ci z nim zwiÄ…zanych. Idealnym narzÄ™dziem do zautomatyzowania czynnoÅ›ci polegajÄ…cych na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program dziaÅ‚ajÄ…cy w terminalu ale istniejÄ… rÃ³wnieÅ¼ jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednoczeÅ›nie poÅ‚Ä…czony z hubem (czyli kontenerem) pozwalajÄ…cym na przechowywanie i udostÄ™pnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usÅ‚uga serwerowa, ktÃ³ra pozwala na zapisywanie i udostÄ™pnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\nW niniejszym wykÅ‚adzie zostanÄ… przedstawione rozwiÄ…zania z wykorzystaniem Gita i GitHuba.\nPrzykÅ‚adowe repozytorium projektu tidymodels na stronie GitHub wyglÄ…da nastÄ™pujÄ…co.\nGit w poÅ‚Ä…czeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, ktÃ³ry tworzymy, a jednoczeÅ›nie na udostÄ™pnianie go oraz umoÅ¼liwienie wspÃ³Å‚pracy nad kodem przez wielu uÅ¼ytkownikÃ³w - wspÃ³Å‚twÃ³rcÃ³w (ang. contributors) ale nie tylko. UdostÄ™pnianie moÅ¼e byÄ‡ zarÃ³wno publiczne, jak i prywatne.\nFunkcjonalnoÅ›ci GitHub, to:\nÅÄ…czÄ…c Git z Githubem, programiÅ›ci zyskujÄ… mocne narzÄ™dzie do kontroli wersji, wspÃ³Å‚pracy, Å›ledzenia problemÃ³w i automatyzacji procesÃ³w, co przyczynia siÄ™ do skutecznego zarzÄ…dzania projektami oprogramowania1."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "WykÅ‚ad 1",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nNie wszystkie z powyÅ¼szych tematÃ³w uda nam siÄ™ omÃ³wiÄ‡ na wykÅ‚adzie ale wiÄ™kszoÅ›Ä‡ zostanie zademonstrowana.â†©ï¸\nskrÃ³t od repozytoriumâ†©ï¸\nwprawdzie na tym etapie dodaliÅ›my plik README.md ale poniewaÅ¼ jest to pierwszy commit to tak go nazwaliÅ›my.â†©ï¸"
  }
]