[
  {
    "objectID": "WdraÅ¼anie modeli uczenia maszynowego.html",
    "href": "WdraÅ¼anie modeli uczenia maszynowego.html",
    "title": "WstÄ™p",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych."
  },
  {
    "objectID": "WdraÅ¼anie modeli uczenia maszynowego.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "href": "WdraÅ¼anie modeli uczenia maszynowego.html#przebieg-prac-nad-wdroÅ¼eniem-modelu",
    "title": "WstÄ™p",
    "section": "",
    "text": "Budowa modeli i ich pÃ³Åºniejsze wdraÅ¼anie odbywa siÄ™ w wielu etapach. Rzadko kiedy model powstaje w pierwszym podejÅ›ciu do rozwiÄ…zania problemu badawczego. NajczÄ™Å›ciej w toku kolejnych korekt powstaje ostateczny projekt, ktÃ³ry moÅ¼e zostaÄ‡ zaimplementowany na serwerze klienckim, czy urzÄ…dzeniu docelowym. Nierzadko rÃ³wnieÅ¼ (szczegÃ³lnie w przypadku rozbudowanych modeli) pracÄ™ nad nim prowadzi kilka osÃ³b. Wydana wersja modelu moÅ¼e rÃ³wnieÅ¼ charakteryzowaÄ‡ siÄ™ pewnymi bÅ‚Ä™dami czy niedogodnoÅ›ciami, sugerowanymi przez uÅ¼ytkownikÃ³w. To powoduje, Å¼e tzw â€˜ostatecznaâ€™ wersja musi byÄ‡ rÃ³wnieÅ¼ poprawiana. Przebieg przygotowania modelu i jego wdroÅ¼enia moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nDefiniowanie problemu badawczego:\n\nZidentyfikuj problem, ktÃ³ry chcesz rozwiÄ…zaÄ‡ za pomocÄ… modelu.\nOkreÅ›l cele, jakie chcesz osiÄ…gnÄ…Ä‡.\n\nZbieranie danych:\n\nZebranie odpowiednich danych.\n\nAnaliza danych:\n\nEksploracyjna analiza danych (EDA), aby zrozumieÄ‡ charakterystyki danych.\nWykrywanie brakujÄ…cymi danych, anomalii czy outlierÃ³w.\n\nPrzygotowanie danych:\n\nPodziaÅ‚u danych na zestawy treningowe, walidacyjne i testowe.\nNormalizacja/standaryzacja danych, jeÅ›li jest to konieczne.\n\nWybÃ³r modelu:\n\nWybÃ³r odpowiedniego rodzaju modelu.\nDostosowanie hiperparametrÃ³w modelu w celu optymalizacji wynikÃ³w.\n\nTrening modelu:\n\nUczenie modelu korzystajÄ…c z zestawu treningowego.\n\nWalidacja modelu:\n\nUÅ¼ycie zestawu walidacyjnego do oceny skutecznoÅ›ci modelu.\n\nOptymalizacja modelu:\n\nDostosowanie model w celu poprawy jego wydajnoÅ›Ä‡ (regularyzacja, zmiana architektury, optymalizacja hiperparametrÃ³w, itp)\n\nTestowanie modelu:\n\nOcena dopasowania modelu na zbiorze testowym.\n\nWdraÅ¼anie modelu:\n\nPrzygotowanie modelu do wdroÅ¼enia, uwzglÄ™dniajÄ…c aspekty wydajnoÅ›ciowe i skalowalnoÅ›Ä‡.\nPrzygotowanie aplikacji (API) pozwalajÄ…cej na umieszczenie modelu na serwerze lub urzÄ…dzeniu docelowym.\n\n\nW zaleÅ¼noÅ›ci od sytuacji, model moÅ¼e byÄ‡ rÃ³wnieÅ¼ monitorowany i aktualizowany. NiezbÄ™dna moÅ¼e byÄ‡ rÃ³wnieÅ¼ dokumentacja techniczna uÅ‚atwiajÄ…ca zrozumienie i utrzymanie modelu przez odbiorcÃ³w koÅ„cowych."
  },
  {
    "objectID": "wyk1.html",
    "href": "wyk1.html",
    "title": "WykÅ‚ad 1",
    "section": "",
    "text": "PoniewaÅ¼ proces budowy i udoskonalania modelu moÅ¼e trwaÄ‡ dÅ‚ugo i byÄ‡ prowadzony przez kilka osÃ³b, to kontrolowanie wersji modelu wydaje siÄ™ byÄ‡ konieczne.\nPonadto konieczne w tym procesie jest kontrolowanie zarÃ³wno aktualnej wersji modelu, jak i wszystkich przylegÅ‚oÅ›ci z nim zwiÄ…zanych. Idealnym narzÄ™dziem do zautomatyzowania czynnoÅ›ci polegajÄ…cych na kontroli wersji jest program git.\nJest to darmowy program do pobrania ze strony domowej na dowolny system operacyjny. Jest to program dziaÅ‚ajÄ…cy w terminalu ale istniejÄ… rÃ³wnieÅ¼ jego wersje z przyjaznym GUI (najbardziej znany to GitHub Desktop), przy czym ten program jest jednoczeÅ›nie poÅ‚Ä…czony z hubem (czyli kontenerem) pozwalajÄ…cym na przechowywanie i udostÄ™pnianie kodu w internecie, znanym jako GitHub. Nie jest to jedyna usÅ‚uga serwerowa, ktÃ³ra pozwala na zapisywanie i udostÄ™pnianie kodu z wykorzystaniem gita. Inne znane alternatywy to GitLab i Bitbucket.\nW niniejszym wykÅ‚adzie zostanÄ… przedstawione rozwiÄ…zania z wykorzystaniem Gita i GitHuba.\nPrzykÅ‚adowe repozytorium projektu tidymodels na stronie GitHub wyglÄ…da nastÄ™pujÄ…co.\nGit w poÅ‚Ä…czeniu z GitHubem pozwala na przechowywanie wszystkich wersji kodu, ktÃ³ry tworzymy, a jednoczeÅ›nie na udostÄ™pnianie go oraz umoÅ¼liwienie wspÃ³Å‚pracy nad kodem przez wielu uÅ¼ytkownikÃ³w - wspÃ³Å‚twÃ³rcÃ³w (ang. contributors) ale nie tylko. UdostÄ™pnianie moÅ¼e byÄ‡ zarÃ³wno publiczne, jak i prywatne.\nFunkcjonalnoÅ›ci GitHub, to:\nÅÄ…czÄ…c Git z Githubem, programiÅ›ci zyskujÄ… mocne narzÄ™dzie do kontroli wersji, wspÃ³Å‚pracy, Å›ledzenia problemÃ³w i automatyzacji procesÃ³w, co przyczynia siÄ™ do skutecznego zarzÄ…dzania projektami oprogramowania1."
  },
  {
    "objectID": "wyk1.html#footnotes",
    "href": "wyk1.html#footnotes",
    "title": "WykÅ‚ad 1",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nNie wszystkie z powyÅ¼szych tematÃ³w uda nam siÄ™ omÃ³wiÄ‡ na wykÅ‚adzie ale wiÄ™kszoÅ›Ä‡ zostanie zademonstrowana.â†©ï¸\nskrÃ³t od repozytoriumâ†©ï¸\nwprawdzie na tym etapie dodaliÅ›my plik README.md ale poniewaÅ¼ jest to pierwszy commit to tak go nazwaliÅ›my.â†©ï¸"
  },
  {
    "objectID": "wyk2.html",
    "href": "wyk2.html",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "PrzypominajÄ…c sytuacjÄ™ w jakiej siÄ™ znajdujemyâ€¦ utworzyliÅ›my repozytorium o nazwie DariuszMajerek/Github_tests. DokonaliÅ›my w nim kilku zmian commitowanych za kaÅ¼dym razem. PodglÄ…d tych zmian moÅ¼emy dokonaÄ‡ przez przeglÄ…d commitÃ³w.\ngit log\n\n\n\nLogi z commit\n\n\n\n\nZmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeÅ¼enie\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nZagroÅ¼enie\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu.\n\n\n\n\n\nW tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nWaÅ¼ne\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request.\n\n\n\n\n# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#fork-repo",
    "href": "wyk2.html#fork-repo",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "Zmian moÅ¼emy dokonywaÄ‡ rÃ³wnieÅ¼ w repo, ktÃ³rych autorem jest ktoÅ› inny. Najpierw naleÅ¼y wykonaÄ‡ fork takiego repo, a nastÄ™pnie dokonaÄ‡ zmian. Dokonamy najpierw forka przykÅ‚adowego repo octocat/Spoon-Knife1. MoÅ¼na tego dokonaÄ‡ na stronie repo kliknÄ…Ä‡ przycisk fork\n\nZostaniesz wÃ³wczas zapytany czy chcesz skopiowaÄ‡ jedynie gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº repo i pod jakÄ… nazwÄ… chcesz go skopiowaÄ‡.\n\nWybranie opcji domyÅ›lnych jest zalecane, jeÅ›li chcemy dokonaÄ‡ pÃ³Åºniej tzw pull request (o tym za chwilÄ™). Po skopiowaniu fork cudzego repo na moim koncie GitHub wyglÄ…da nastÄ™pujÄ…co. Pod nazwÄ… repo widnieje nazwa repo skÄ…d zostaÅ‚o ono skopiowane.\n\nKopiowanie czyjegoÅ› repo robimy kiedy chcemy zmodyfikowaÄ‡ kod istniejÄ…cy bez ingerencji w oryginalny kod (oryginalny stan repo) a nastÄ™pnie go (poprawionego) wypchnÄ…Ä‡. PÃ³ki co fork czyjegoÅ› repo znajduje siÄ™ jedynie w naszym repo zdalnym. Aby pobraÄ‡ go do repo lokalnego, trzeba wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci:\n\nprzejÅ›Ä‡ do katalogu, w ktÃ³rym chcemy zapisaÄ‡ kopiÄ™ repo\nskopiowaÄ‡ adres dostÄ™pu do kopiowanego repo (HTTPS lub SSH)\nwykonaÄ‡ polecenie git clone &lt;forked_repo_url&gt;, gdzie &lt;forked_repo_url&gt; oznacza wÅ‚aÅ›nie skopiowany adres repo.\n\n# najpierw sprawdÅº miejsce w ktÃ³rym siÄ™ znajdujesz (katalog roboczy)\npwd\n\n# przejdÅº do katalogu wyÅ¼ej (tam chcÄ™ skopiowaÄ‡ repo)\ncd ..\n\n# sklonuj forka repo\ngit clone git@github.com:DariuszMajerek/Spoon-Knife.git\n\n\n\n\n\n\n\nOstrzeÅ¼enie\n\n\n\nZnÃ³w czujne oko wychwyci, Å¼e podajÄ…c adres repo zmieniÅ‚em go z git@github.com:DariuszMajerek/Spoon-Knife.git na git@github.com-work:DariuszMajerek/Spoon-Knife.git, to dlatego, Å¼e na komputerze, na ktÃ³rym to robiÄ™ mam poÅ‚Ä…czone dwa konta GitHub i aby je rozrÃ³Å¼niaÄ‡ stosujÄ™ takÄ… podmianÄ™.\n\n\nPo skopiowaniu repo na dysk lokalny, moÅ¼emy przystÄ…piÄ‡ do dokonywania modyfikacji w repo. Na potrzeby przykÅ‚adu zmienimy wartoÅ›ci w pliku style.css. W czÄ™Å›ci dotyczÄ…cej stylu paragrafu zmienimy dwie wartoÅ›ci:\n\noryginalne wartoÅ›ci\n\np {\n  display: block;\n  width: 400px;\n  margin: 50px auto;\n  font: 30px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n\nwartoÅ›ci po zmianach\n\np {\n  display: block;\n  width: 500px;\n  margin: 50px auto;\n  font: 20px Monaco,\"Courier New\",\"DejaVu Sans Mono\",\"Bitstream Vera Sans Mono\",monospace;\n}\n# sprawdÅºmy czy zmiany zostaÅ‚y zarejestrowane\ngit status\n\n# moÅ¼emy ponadto podejrzeÄ‡ zmiany za pomocÄ…\ngit diff\n\nTeraz zmiany trzeba zatwierdziÄ‡ i commitowaÄ‡.\ngit add .\ngit commit -m \"style changes\"\nNastÄ™pnie wypychamy zmiany do zdalnego repo. Najpierw moÅ¼emy sprawdziÄ‡ czy adres zdalnego repo jest ustalony.\n# sprawdzamy czy adres zdalenego repo istnieje\ngit remote -v\n\n# skoro tak to wypychamy gÅ‚Ã³wnÄ… gaÅ‚Ä…Åº do repo zdalnego\ngit push origin main\n\nTeraz zarÃ³wno repo lokalne, jak i zdalne majÄ… tÄ… samÄ… zawartoÅ›Ä‡ i tÄ… samÄ… wersjÄ™. CzÄ™Å›ciej jednak w tego typu wspÃ³Å‚pracy nad kodem umieszczonym w repo bÄ™dziemy tworzyli wÅ‚asnÄ… gaÅ‚Ä…Åº w forkowanym repo.\n\n\n\n\n\n\nZagroÅ¼enie\n\n\n\nZa kaÅ¼dym razem, gdy pracujesz nad wspÃ³lnym projektem, ty i inni programiÅ›ci wspÃ³Å‚tworzÄ…cy repozytorium bÄ™dziecie mieli rÃ³Å¼ne pomysÅ‚y na nowe funkcje lub poprawki jednoczeÅ›nie. NiektÃ³re z tych nowych funkcji nie zajmÄ… duÅ¼o czasu na wdroÅ¼enie, ale niektÃ³re z nich bÄ™dÄ… trwaÅ‚y. Z tego powodu waÅ¼ne jest rozgaÅ‚Ä™zienie repozytorium, aby mÃ³c zarzÄ…dzaÄ‡ przepÅ‚ywem pracy, izolowaÄ‡ swÃ³j kod i kontrolowaÄ‡, ktÃ³re funkcje wracajÄ… do gÅ‚Ã³wnej gaÅ‚Ä™zi repozytorium projektu."
  },
  {
    "objectID": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "href": "wyk2.html#kontrola-wersji---cofanie-zmian",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "W tym celu najpierw nauczymy siÄ™ cofaÄ‡ zmiany dokonane zarÃ³wno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logÃ³w repo.\ngit log\n\nWidaÄ‡, Å¼e oprÃ³cz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi sÄ… zawsze wyÅ›wietlane w kolejnoÅ›ci od najaktualniejszego (na gÃ³rze) do najstarszego (na dole). MoÅ¼emy siÄ™ cofnÄ…Ä‡ do stanu zachowanego dowolnym commitem ğŸ’ª.\nCofanie stanu repo moÅ¼na wykonaÄ‡ na dwa sposoby:\n\npoprzez git reset\noraz git revert\n\nDziaÅ‚anie obu tych funkcji rÃ³Å¼ni siÄ™ nieco i obie je omÃ³wimy.\n\n\nPolecenie git reset sÅ‚uÅ¼y do cofniÄ™cia zmian w katalogu roboczym i powrotu do okreÅ›lonego zatwierdzenia, jednoczeÅ›nie odrzucajÄ…c wszystkie zatwierdzenia wykonane po nim. Na przykÅ‚ad, wyobraÅº sobie, Å¼e wykonaÅ‚eÅ› dziesiÄ™Ä‡ commitÃ³w. UÅ¼ycie git reset na pierwszym zatwierdzeniu usunie wszystkie dziewiÄ™Ä‡ zatwierdzeÅ„, przenoszÄ…c ciÄ™ z powrotem do etapu pierwszego zatwierdzenia. Przed uÅ¼yciem git reset waÅ¼ne jest, aby wziÄ…Ä‡ pod uwagÄ™ rodzaj zmian, ktÃ³re planujesz wprowadziÄ‡; w przeciwnym razie stworzysz wiÄ™cej chaosu niÅ¼ poÅ¼ytku.\n\n\n\n\n\n\nWaÅ¼ne\n\n\n\nMoÅ¼esz uÅ¼yÄ‡ wielu opcji wraz z git reset, ale to sÄ… te gÅ‚Ã³wne. KaÅ¼da z nich jest uÅ¼ywana w zaleÅ¼noÅ›ci od konkretnej sytuacji: git reset --soft, git reset --mixed i git reset --hard.\n\n\nFlaga --soft ma na celu zmianÄ™ odniesienia HEAD (stanu gdzie znajduje siÄ™ ostatni commit na komputerze lokalnym) do okreÅ›lonego commita. Na przykÅ‚ad, jeÅ›li zdamy sobie sprawÄ™, Å¼e zapomnieliÅ›my dodaÄ‡ plik do commita, moÅ¼emy cofnÄ…Ä‡ siÄ™ za pomocÄ… --soft w nastÄ™pujÄ…cy sposÃ³b:\n\ngit reset --soft HEAD~n aby cofnÄ…Ä‡ siÄ™ do zatwierdzenia z okreÅ›lonym odniesieniem (n).\ngit reset --soft HEAD~1 cofa do ostatniego zatwierdzenia.\ngit reset --soft &lt;commit ID&gt; cofa HEAD do &lt;commit ID&gt;\n\ngdzie &lt;commit ID&gt; jest tagiem commita. Opcja --soft nie wymaga ponownego dodawania plikÃ³w, ktÃ³re zostaÅ‚y dodane w poprzednim commicie.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“soft HEAD\n\n\nFlaga --mixed jest domyÅ›lnym ustawieniem polecenia git reset. Uruchomienie tego polecenia ma dwa skutki:\n\nod-commituje wszystkie zmiany\nusuwa je ze Stage\n\nUÅ¼ywamy jej gdy np. w commitowanym stanie repo uznaliÅ›my, Å¼e nie warto go wypychaÄ‡, poniewaÅ¼ jeden z plikÃ³w, ktÃ³ry commitujemy ma jeszcze bÅ‚Ä™dy i naleÅ¼y go poprawiÄ‡ przed git push.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“mixed HEAD\n\n\nFlaga --hard powinna byÄ‡ uÅ¼ywana z rozmysÅ‚em, poniewaÅ¼ moÅ¼e wyrzÄ…dziÄ‡ sporo szkÃ³d. Opcja --hard odrzuca wszelkie zmiany dokonane w Å›ledzonych plikach w katalogu roboczym i resetuje je do stanu okreÅ›lonego commita.\n\n\n\nPrzykÅ‚ad uÅ¼ycia git reset â€“hard HEAD\n\n\n\n\n\nSchemat dziaÅ‚ania git reset\n\n\n\n\n\nPolecenie git revert sÅ‚uÅ¼y do utworzenia nowego commitu, ktÃ³ry cofa zmiany wprowadzone w okreÅ›lonym poprzednim commicie. W przeciwieÅ„stwie do git reset, ktÃ³re przemieszcza wskaÅºnik HEAD i gaÅ‚Ä™zi do innego commitu, git revert tworzy nowy commit, ktÃ³ry odwraca zmiany w poprzednim commicie.\nPokaÅ¼Ä™ to na przykÅ‚adzie, korzystajÄ…c z wczeÅ›niejszego scenariusza z trzema commitami i trzema plikami (plik1.txt, plik2.txt, plik3.txt).\n\n\n\nPrzykÅ‚ad uÅ¼ycia git revert\n\n\nPo uÅ¼yciu git revert nie ma Å¼adnych niezatwierdzonych zmian. Wprowadza nowy commit, ktÃ³ry cofa zmiany wprowadzone w poprzednim commicie. DziÄ™ki temu moÅ¼emy utrzymaÄ‡ spÃ³jnoÅ›Ä‡ historii i uniknÄ…Ä‡ problemÃ³w z innymi wspÃ³Å‚pracownikami, ktÃ³rzy juÅ¼ pobrali nasze zmiany.\nRÃ³Å¼nice miÄ™dzy git revert a git reset:\n\ngit revert wprowadza nowy commit, zachowujÄ…c historiÄ™.\ngit reset przemieszcza wskaÅºnik HEAD, usuwajÄ…c zmiany z historii.\ngit revert jest bezpieczniejsze do stosowania w publicznych repozytoriach, poniewaÅ¼ nie wymaga modyfikowania historii, co moÅ¼e utrudniÄ‡ wspÃ³Å‚pracÄ™ z innymi programistami.\n\n\n\n\nSchemat dziaÅ‚ania git revert\n\n\nTeraz moÅ¼emy wrÃ³ciÄ‡ do zadania usuniÄ™cia zmian (ostatniego commita) w repo DariuszMajerek/Spoon-Knife. Musimy wykonaÄ‡ nastÄ™pujÄ…ce czynnoÅ›ci w katalogu Spoon-Knife.\nJeÅ›li chcesz przejÅ›Ä‡ do wczeÅ›niejszej wersji zdalnego repozytorium w tej samej gaÅ‚Ä™zi i usunÄ…Ä‡ najnowsze commity, moÅ¼na skorzystaÄ‡ z polecenia git reset w trybie --hard. Jednak pamiÄ™taj, Å¼e git reset --hard jest operacjÄ… radykalnÄ… i trwale usuwa commity, wiÄ™c bÄ…dÅº pewien, Å¼e chcesz to zrobiÄ‡, poniewaÅ¼ stracisz historiÄ™ tych commitÃ³w.\nOto kroki, ktÃ³re moÅ¼esz podjÄ…Ä‡:\n\nSprawdÅº dostÄ™pne gaÅ‚Ä™zie zdalne:\n\ngit branch -r\n\nPobierz najnowsze zmiany z repozytorium zdalnego:\n\ngit fetch origin\n\nPrzejdÅº do gaÅ‚Ä™zi, w ktÃ³rej chcesz cofnÄ…Ä‡ zmiany:\n\n# to nie jest konieczne bo juÅ¼ jesteÅ›my w tej gaÅ‚Ä™zi\n# ale nie zawsze tak bÄ™dzie\ngit checkout main\n\nZidentyfikuj commit, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡:\n\ngit log\nOdnajdÅº hasz commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nUÅ¼yj git reset --hard do cofniÄ™cia zmian:\n\ngit reset --hard hasz-commitu\nZastÄ…p hasz-commitu odpowiednim hasÅ‚em commitu, do ktÃ³rego chcesz siÄ™ cofnÄ…Ä‡.\n\nPrzesuÅ„ zmiany na repozytorium zdalne:\n\ngit push origin main --force\nUwaga: UÅ¼ycie --force jest konieczne, poniewaÅ¼ zmieniasz historiÄ™ i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bÄ…dÅº bardzo ostroÅ¼ny, uÅ¼ywajÄ…c --force, poniewaÅ¼ moÅ¼e to wpÅ‚ynÄ…Ä‡ na innych wspÃ³Å‚pracownikÃ³w korzystajÄ…cych z tej gaÅ‚Ä™zi.\n\n\n\nPrzejÅ›cie do stanu z wczeÅ›niejszego commita\n\n\nW ten sposÃ³b wrÃ³ciliÅ›my do oryginalnego stanu pobranego repo octocat/Spoon-Knife. MoÅ¼emy teraz przystÄ…piÄ‡ do tworzenia wÅ‚asnej gaÅ‚Ä™zi w tym repo i dokonania w nim zmian. Na koÅ„cu bÄ™dziemy chcieli dokonaÄ‡ Å‚Ä…czenia gaÅ‚Ä™zi (naszej po poprawkach) z oryginalnÄ… poprzez pull request."
  },
  {
    "objectID": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "href": "wyk2.html#dziaÅ‚anie-na-gaÅ‚Ä™ziach",
    "title": "WykÅ‚ad 2",
    "section": "",
    "text": "# zaczynamy od sprawdzenia w ktÃ³rej gaÅ‚Ä™zi jesteÅ›my\ngit branch\n\n# teraz tworzymy nowÄ… gaÅ‚Ä…Åº w obecnej\ngit branch my_branch\n\n# teraz do niej przechodzimy\ngit checkout my_branch\n\n# dwie ostatnie czynnoÅ›ci moÅ¼na wykonaÄ‡ jednÄ… komendÄ…\ngit checkout -b my_branch\nTeraz dokonujemy tych samych zmian w pliku styles.css, ktÃ³rych dokonaliÅ›my w gaÅ‚Ä™zi gÅ‚Ã³wnej.\n# po zmianach sprawdzamy status repo w gaÅ‚Ä™zi my_branch\ngit status\n\n# widaÄ‡ Å¼e zmiany nastÄ…piÅ‚y wiÄ™c je dodajemy do Stage\ngit add styles.css\n\n# commitujemy zmiany\ngit commit -m \"style changes\"\n\n# wypychamy zmiany/commita do nowej gaÅ‚Ä™zi\ngit push origin my_branch\n\n\n\nPrzebieg pracy nad utworzeniem nowej gaÅ‚Ä™zi i dodaniem do niej zmian\n\n\nJak moÅ¼na zauwaÅ¼yÄ‡ na powyÅ¼szym obrazku system sugeruje dokonanie pull request, czyli proÅ›by (w tym przypadku skierowanej do octocat) o poÅ‚Ä…czenie (czyli merge) gaÅ‚Ä™zi gÅ‚Ã³wnej z gaÅ‚Ä™ziÄ… my_branch.\nAby dokonaÄ‡ pull request nowej gaÅ‚Ä™zi w systemie Git, zazwyczaj korzysta siÄ™ z platformy do zarzÄ…dzania kodem, takiej jak GitHub, GitLab lub Bitbucket. PoniÅ¼ej przedstawiam ogÃ³lny przewodnik krok po kroku, korzystajÄ…c z GitHuba jako przykÅ‚adu. Procedury na innych platformach sÄ… zbliÅ¼one, ale mogÄ… siÄ™ rÃ³Å¼niÄ‡ w szczegÃ³Å‚ach.\n\nUtwÃ³rz nowÄ… gaÅ‚Ä…Åº w lokalnym repozytorium:\ngit checkout -b nazwa-nowej-gaÅ‚Ä™zi\nWykonaj pracÄ™ na tej gaÅ‚Ä™zi i zatwierdzaj zmiany.\nPush nowej gaÅ‚Ä™zi na repozytorium zdalne:\ngit push origin nazwa-nowej-gaÅ‚Ä™zi\nTo przesyÅ‚a nowÄ… gaÅ‚Ä…Åº na repozytorium zdalne2.\nOtwÃ³rz przeglÄ…darkÄ™ i przejdÅº do repozytorium na GitHubie.\nPrzejdÅº do nowej gaÅ‚Ä™zi - w zakÅ‚adce â€œBranchâ€ na stronie repozytorium, wybierz nowÄ… gaÅ‚Ä…Åº.\nUtwÃ³rz Pull Request:\n\nNa stronie gaÅ‚Ä™zi wybierz przycisk â€œNew pull requestâ€.\nWybierz gaÅ‚Ä…Åº docelowÄ…, zazwyczaj jest to master lub inna gÅ‚Ã³wna gaÅ‚Ä…Åº.\n\nUzupeÅ‚nij informacje dotyczÄ…ce Pull Request:\n\nUzupeÅ‚nij tytuÅ‚ i opis dotyczÄ…cy zmiany, ktÃ³re wprowadziÅ‚eÅ›.\nSprawdÅº, czy Pull Request speÅ‚nia oczekiwania dotyczÄ…ce kodu i testÃ³w.\n\nUtwÃ³rz Pull Request - kliknij przycisk â€œCreate pull requestâ€, aby utworzyÄ‡ Pull Request.\nDokonaj przeglÄ…du i zatwierdÅº:\n\nInni czÅ‚onkowie zespoÅ‚u mogÄ… dokonaÄ‡ przeglÄ…du zmian.\nPo zakoÅ„czonym przeglÄ…dzie i zatwierdzeniu zmian, Pull Request moÅ¼e byÄ‡ scalony (merged).\n\nZaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:\ngit checkout master\ngit pull origin master\nW ten sposÃ³b przyniesiesz zmiany z gaÅ‚Ä™zi docelowej (np. master) do swojego lokalnego repozytorium."
  },
  {
    "objectID": "wyk2.html#footnotes",
    "href": "wyk2.html#footnotes",
    "title": "WykÅ‚ad 2",
    "section": "Przypisy",
    "text": "Przypisy\n\n\nEwentualne zmiany nie popsujÄ… niczego w tym repo, bo jest ono przygotowane do tego typu testÃ³w.â†©ï¸\nDotÄ…d mamy wszystko zrobioneâ†©ï¸"
  },
  {
    "objectID": "wyk3.html",
    "href": "wyk3.html",
    "title": "WykÅ‚ad 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w jÄ™zyku R i Python (od niedawna, jak jednak bÄ™dÄ™ siÄ™ skupiaÅ‚ na R). Jest to obszar, w ktÃ³rym inÅ¼ynierowie danych i analitycy mogÄ… tworzyÄ‡ interaktywne aplikacje internetowe, wykorzystujÄ…c caÅ‚Ä… swojÄ… wiedzÄ™ i analizy zgromadzonÄ… w jÄ™zyku R. DziÄ™ki Shiny, uÅ¼ytkownicy mogÄ… Å‚atwo przeksztaÅ‚caÄ‡ swoje skrypty i modele w interaktywne aplikacje internetowe, bez koniecznoÅ›ci posiadania wczeÅ›niejszego doÅ›wiadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera siÄ™ na paradygmacie â€œreactive programmingâ€, co oznacza, Å¼e aplikacje tworzone przy jego uÅ¼yciu sÄ… dynamiczne i reagujÄ… na zmiany danych w czasie rzeczywistym. Oznacza to, Å¼e uÅ¼ytkownicy mogÄ… manipulowaÄ‡ danymi i obserwowaÄ‡, jak te zmiany wpÅ‚ywajÄ… na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementÃ³w Shiny jest jego prostota uÅ¼ycia. Za pomocÄ… kilku linii kodu w jÄ™zyku R, moÅ¼na stworzyÄ‡ interaktywny interfejs, ktÃ³ry pozwala uÅ¼ytkownikowi na Å‚atwe eksplorowanie danych. Warto rÃ³wnieÅ¼ podkreÅ›liÄ‡, Å¼e Shiny integruje siÄ™ z istniejÄ…cymi narzÄ™dziami analizy danych w R, takimi jak ggplot2 czy dplyr, co uÅ‚atwia korzystanie z istniejÄ…cych umiejÄ™tnoÅ›ci programistycznych.\nShiny oferuje rÃ³Å¼norodne elementy interfejsu uÅ¼ytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umoÅ¼liwiajÄ…c tworzenie rozbudowanych interfejsÃ³w. Ponadto, framework ten obsÅ‚uguje rÃ³wnieÅ¼ funkcje uwierzytelniania i autoryzacji, co pozwala kontrolowaÄ‡ dostÄ™p do aplikacji w zaleÅ¼noÅ›ci od potrzeb.\nDziÄ™ki Shiny, analiza danych staje siÄ™ bardziej dostÄ™pna i przyjazna dla uÅ¼ytkownika koÅ„cowego, umoÅ¼liwiajÄ…c interaktywnÄ… eksploracjÄ™ wynikÃ³w analizy danych bez koniecznoÅ›ci gÅ‚Ä™bokiego zrozumienia kodu R. To narzÄ™dzie jest szczegÃ³lnie przydatne dla osÃ³b pracujÄ…cych w dziedzinie analizy danych, statystyki, czy nauk spoÅ‚ecznych, ktÃ³re chcÄ… szybko i efektywnie udostÄ™pniÄ‡ swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#czym-jest-shiny",
    "href": "wyk3.html#czym-jest-shiny",
    "title": "WykÅ‚ad 3",
    "section": "",
    "text": "Shiny to framework do tworzenia aplikacji internetowych w jÄ™zyku R i Python (od niedawna, jak jednak bÄ™dÄ™ siÄ™ skupiaÅ‚ na R). Jest to obszar, w ktÃ³rym inÅ¼ynierowie danych i analitycy mogÄ… tworzyÄ‡ interaktywne aplikacje internetowe, wykorzystujÄ…c caÅ‚Ä… swojÄ… wiedzÄ™ i analizy zgromadzonÄ… w jÄ™zyku R. DziÄ™ki Shiny, uÅ¼ytkownicy mogÄ… Å‚atwo przeksztaÅ‚caÄ‡ swoje skrypty i modele w interaktywne aplikacje internetowe, bez koniecznoÅ›ci posiadania wczeÅ›niejszego doÅ›wiadczenia w programowaniu aplikacji internetowych.\n\n\n\nFramework Shiny opiera siÄ™ na paradygmacie â€œreactive programmingâ€, co oznacza, Å¼e aplikacje tworzone przy jego uÅ¼yciu sÄ… dynamiczne i reagujÄ… na zmiany danych w czasie rzeczywistym. Oznacza to, Å¼e uÅ¼ytkownicy mogÄ… manipulowaÄ‡ danymi i obserwowaÄ‡, jak te zmiany wpÅ‚ywajÄ… na prezentowane wyniki w czasie rzeczywistym.\nJednym z kluczowych elementÃ³w Shiny jest jego prostota uÅ¼ycia. Za pomocÄ… kilku linii kodu w jÄ™zyku R, moÅ¼na stworzyÄ‡ interaktywny interfejs, ktÃ³ry pozwala uÅ¼ytkownikowi na Å‚atwe eksplorowanie danych. Warto rÃ³wnieÅ¼ podkreÅ›liÄ‡, Å¼e Shiny integruje siÄ™ z istniejÄ…cymi narzÄ™dziami analizy danych w R, takimi jak ggplot2 czy dplyr, co uÅ‚atwia korzystanie z istniejÄ…cych umiejÄ™tnoÅ›ci programistycznych.\nShiny oferuje rÃ³Å¼norodne elementy interfejsu uÅ¼ytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele i wiele innych, umoÅ¼liwiajÄ…c tworzenie rozbudowanych interfejsÃ³w. Ponadto, framework ten obsÅ‚uguje rÃ³wnieÅ¼ funkcje uwierzytelniania i autoryzacji, co pozwala kontrolowaÄ‡ dostÄ™p do aplikacji w zaleÅ¼noÅ›ci od potrzeb.\nDziÄ™ki Shiny, analiza danych staje siÄ™ bardziej dostÄ™pna i przyjazna dla uÅ¼ytkownika koÅ„cowego, umoÅ¼liwiajÄ…c interaktywnÄ… eksploracjÄ™ wynikÃ³w analizy danych bez koniecznoÅ›ci gÅ‚Ä™bokiego zrozumienia kodu R. To narzÄ™dzie jest szczegÃ³lnie przydatne dla osÃ³b pracujÄ…cych w dziedzinie analizy danych, statystyki, czy nauk spoÅ‚ecznych, ktÃ³re chcÄ… szybko i efektywnie udostÄ™pniÄ‡ swoje wyniki innym osobom poprzez intuicyjne interfejsy internetowe."
  },
  {
    "objectID": "wyk3.html#czÄ™Å›ci-skÅ‚adowe-aplikacji-shiny",
    "href": "wyk3.html#czÄ™Å›ci-skÅ‚adowe-aplikacji-shiny",
    "title": "WykÅ‚ad 3",
    "section": "CzÄ™Å›ci skÅ‚adowe aplikacji Shiny",
    "text": "CzÄ™Å›ci skÅ‚adowe aplikacji Shiny\nDo poprawnego dziaÅ‚ania aplikacji Shiny konieczne jest zainstalowanie pakietu shiny.\nW kaÅ¼dej aplikacji Shiny moÅ¼na wyrÃ³Å¼niÄ‡ trzy podstawowe czÄ™Å›ci:\n\n\nUI (Interfejs UÅ¼ytkownika):\n\n\nElementy Interfejsu - definiujÄ… strukturÄ™ interfejsu uÅ¼ytkownika, takie jak pola tekstowe, suwaki, przyciski, tabele, wykresy itp.\n\nUkÅ‚ad Strony - okreÅ›la rozmieszczenie i stylizacjÄ™ elementÃ³w na stronie.\n\nDefinicja UI - jest to miejsce, w ktÃ³rym programista okreÅ›la, jak majÄ… wyglÄ…daÄ‡ interaktywne elementy widoczne dla uÅ¼ytkownika.\n\n\n\nPrzykÅ‚ad definicji UI w Shiny moÅ¼e wyglÄ…daÄ‡ nastÄ™pujÄ…co:\n\nKodui &lt;- fluidPage(\n  titlePanel(\"Moja Aplikacja Shiny\"),\n  sidebarLayout(\n    sidebarPanel(\n      sliderInput(\"slider\", \"Wybierz wartoÅ›Ä‡:\", min = 1, max = 100, value = 50)\n    ),\n    mainPanel(\n      plotOutput(\"wykres\")\n    )\n  )\n)\n\n\n\n\nServer (Serwer):\n\n\nFunkcje Obliczeniowe - zawierajÄ… kod R odpowiedzialny za przetwarzanie danych, generowanie wynikÃ³w oraz reakcjÄ™ na interakcje uÅ¼ytkownika.\n\nReaktywnoÅ›Ä‡ - serwer Shiny korzysta z obiektÃ³w reaktywnych do Å›ledzenia zmian w danych i automatycznego aktualizowania wynikÃ³w w interfejsie uÅ¼ytkownika.\n\n\n\nPrzykÅ‚ad definicji serwera w Shiny moÅ¼e wyglÄ…daÄ‡ tak:\n\nKodserver &lt;- function(input, output) {\n  output$wykres &lt;- renderPlot({\n    dane &lt;- seq(1, input$slider)\n    plot(dane, main = \"Wykres dynamiczny\")\n  })\n}\n\n\n\n\nSesja Shiny:\n\n\nKomunikacja UI-Server - kaÅ¼da sesja Shiny umoÅ¼liwia komunikacjÄ™ miÄ™dzy interfejsem uÅ¼ytkownika a serwerem, przesyÅ‚anie danych i instrukcji miÄ™dzy dwiema warstwami aplikacji.\n\nÅ»ywotnoÅ›Ä‡ Aplikacji - sesja utrzymuje stan aplikacji, umoÅ¼liwiajÄ…c Å›ledzenie i reakcjÄ™ na zmiany dokonywane przez uÅ¼ytkownika.\n\n\n\nPrzykÅ‚ad uruchamiania aplikacji Shiny zdefiniowanej powyÅ¼ej:\n\nKodshinyApp(ui, server)\n\n\nDo zapoznania siÄ™ z moÅ¼liwoÅ›ciami aplikacji Shiny zachÄ™cam do uruchomienia nastÄ™pujÄ…cych przykÅ‚adÃ³w aplikacji.\n\nKodrunExample(\"01_hello\")      # a histogram\nrunExample(\"02_text\")       # tables and data frames\nrunExample(\"03_reactivity\") # a reactive expression\nrunExample(\"04_mpg\")        # global variables\nrunExample(\"05_sliders\")    # slider bars\nrunExample(\"06_tabsets\")    # tabbed panels\nrunExample(\"07_widgets\")    # help text and submit buttons\nrunExample(\"08_html\")       # Shiny app built from HTML\nrunExample(\"09_upload\")     # file upload wizard\nrunExample(\"10_download\")   # file download wizard\nrunExample(\"11_timer\")      # an automated timer\n\n\n\n\nPrzykÅ‚ad wywoÅ‚ania przykÅ‚adu â€˜01_helloâ€™\n\nReaktywnoÅ›Ä‡ w Shiny\nReaktywnoÅ›Ä‡ jest kluczowym konceptem w Shiny, ktÃ³ry pozwala interakcji miÄ™dzy komponentami interfejsu uÅ¼ytkownika a kodem R. W Shiny, gdy uÅ¼ytkownik wykonuje interakcjÄ™ (na przykÅ‚ad klikajÄ…c przycisk, wpisujÄ…c tekst, wybierajÄ…c wartoÅ›Ä‡ z rozwijanej listy), aplikacja automatycznie reaguje na tÄ™ interakcjÄ™. To oznacza, Å¼e wynik generowany przez aplikacjÄ™ jest zmienny i dynamicznie dostosowuje siÄ™ do akcji uÅ¼ytkownika, bez koniecznoÅ›ci odÅ›wieÅ¼ania strony.\nReaktywnoÅ›Ä‡ w Shiny opiera siÄ™ na tzw. â€œreactive expressionsâ€ oraz â€œreactive conductorsâ€. â€œReactive expressionsâ€ sÄ… funkcjami, ktÃ³re automatycznie aktualizujÄ… wynik w zaleÅ¼noÅ›ci od zmian w ich zmiennych wejÅ›ciowych. Z kolei â€œreactive conductorsâ€ pozwalajÄ… na definiowanie reakcji na zmiany wartoÅ›ci w interfejsie uÅ¼ytkownika.\nPrzykÅ‚ady reaktywnoÅ›ci w Shiny obejmujÄ… dynamiczne odÅ›wieÅ¼anie wykresÃ³w w zaleÅ¼noÅ›ci od wartoÅ›ci wybranych przez uÅ¼ytkownika, automatyczne dostosowanie zakresu danych w oparciu o interakcje uÅ¼ytkownika (np. przesuniÄ™cia suwaka), zmiany zaleÅ¼ne od wprowadzonych danych (np. obliczenia oparte na wartoÅ›ciach wprowadzonych do pÃ³l tekstowych), i wiele innych. ReaktywnoÅ›Ä‡ umoÅ¼liwia tworzenie interfejsÃ³w, ktÃ³re sÄ… interaktywne i dostosowujÄ… siÄ™ do dziaÅ‚aÅ„ uÅ¼ytkownika w czasie rzeczywistym.\n\n\nWyraÅ¼enia reaktywne (reactive()):\n\nReaktywne wyraÅ¼enia to fragmenty kodu, ktÃ³re automatycznie obliczajÄ… i Å›ledzÄ… swoje zaleÅ¼noÅ›ci.\nPrzykÅ‚ad: Reaktywne wyraÅ¼enie, ktÃ³re oblicza sumÄ™ dwÃ³ch wartoÅ›ci wprowadzanych przez uÅ¼ytkownika.\n\n\nKodsuma_reaktywna &lt;- reactive({\n  input$wartosc1 + input$wartosc2\n})\n\n\n\n\nObserwatory (observe()):\n\nObserwatory to fragmenty kodu, ktÃ³re sÄ… wykonywane w odpowiedzi na zmiany w danych. SÅ‚uÅ¼Ä… najczÄ™Å›ciej do dziaÅ‚aÅ„ typu side effect.\nPrzykÅ‚ad: Obserwator, ktÃ³ry wypisuje na konsoli aktualnÄ… wartoÅ›Ä‡ suwaka.\n\n\nKodobserve({\n  cat(\"Aktualna wartoÅ›Ä‡ suwaka:\", input$suwak, \"\\n\")\n})\n\n\n\n\nReaktywne Funkcje (render*()):\n\nFunkcje render*()sÄ… uÅ¼ywane w serwerze do generowania wynikÃ³w, ktÃ³re sÄ… automatycznie aktualizowane w interfejsie w zaleÅ¼noÅ›ci od zmian w danych wejÅ›ciowych.\nPrzykÅ‚ad: Renderowanie wykresu w zaleÅ¼noÅ›ci od wartoÅ›ci suwaka.\n\n\nKodoutput$wykres &lt;- renderPlot({\n  dane &lt;- seq(1, input$suwak)\n  plot(dane, main = \"Wykres dynamiczny\")\n})\n\n\n\n\nPrzykÅ‚ad 1\nRozwaÅ¼my prosty przykÅ‚ad zastosowania reaktywnoÅ›ci w Shiny, gdzie uÅ¼ytkownik wprowadza dwie liczby za pomocÄ… pÃ³l tekstowych, a aplikacja reaguje na te zmiany, automatycznie obliczajÄ…c i wyÅ›wietlajÄ…c ich sumÄ™. W tym przykÅ‚adzie wykorzystamy reaktywne wyraÅ¼enia.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Sumator\"),\n  textInput(\"liczba1\", \"WprowadÅº pierwszÄ… liczbÄ™:\", value = \"\"),\n  textInput(\"liczba2\", \"WprowadÅº drugÄ… liczbÄ™:\", value = \"\"),\n  textOutput(\"wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Reaktywne wyraÅ¼enie obliczajÄ…ce sumÄ™ dwÃ³ch liczb\n  suma_reaktywna &lt;- reactive({\n    # Konwertujemy wprowadzone wartoÅ›ci na liczby\n    liczba1 &lt;- as.numeric(input$liczba1)\n    liczba2 &lt;- as.numeric(input$liczba2)\n    \n    # Sprawdzamy, czy wprowadzone wartoÅ›ci sÄ… liczbami\n    if (is.na(liczba1) || is.na(liczba2)) {\n      return(NULL)  # Zwracamy NULL, jeÅ›li dane sÄ… nieprawidÅ‚owe\n    }\n    \n    # Obliczamy sumÄ™\n    suma &lt;- liczba1 + liczba2\n    return(suma)\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$wynik &lt;- renderText({\n    suma &lt;- suma_reaktywna()\n    \n    # Sprawdzamy, czy wynik jest dostÄ™pny\n    if (!is.null(suma)) {\n      return(paste(\"Suma: \", suma))\n    } else {\n      return(\"WprowadÅº poprawne liczby.\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, kiedy uÅ¼ytkownik wprowadza liczby do pÃ³l tekstowych, reaktywne wyraÅ¼enie suma_reaktywna automatycznie oblicza sumÄ™ tych liczb. NastÄ™pnie, przy uÅ¼yciu funkcji renderujÄ…cej renderText, wynik jest wyÅ›wietlany w interfejsie. DziÄ™ki temu podejÅ›ciu, interfejs jest reaktywny na zmiany wprowadzane przez uÅ¼ytkownika, dostosowujÄ…c siÄ™ automatycznie do nowych danych i prezentujÄ…c aktualny wynik.\n\nPrzykÅ‚ad 2\nRozwaÅ¼my teraz przykÅ‚ad zastosowania wyraÅ¼enia reaktywnego w Shiny. W tej sytuacji, uÅ¼ytkownik bÄ™dzie mÃ³gÅ‚ kliknÄ…Ä‡ przycisk, co spowoduje inkrementacjÄ™ wartoÅ›ci licznika. Wykorzystamy do tego celu obiekt reaktywny.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik KlikniÄ™Ä‡\"),\n  actionButton(\"przycisk\", \"Kliknij mnie\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Inicjalizacja obiektu reaktywnego dla licznika\n  licznik &lt;- reactiveValues(licznik_wartosc = 0)\n\n  # Obserwator reagujÄ…cy na klikniÄ™cie przycisku\n  observeEvent(input$przycisk, {\n    # Inkrementacja wartoÅ›ci licznika po klikniÄ™ciu przycisku\n    licznik$licznik_wartosc &lt;- licznik$licznik_wartosc + 1\n  })\n\n  # Renderowanie wyniku w interfejsie\n  output$licznik_wynik &lt;- renderText({\n    paste(\"Liczba klikniÄ™Ä‡: \", licznik$licznik_wartosc)\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, obiekt reaktywny licznik jest uÅ¼ywany do przechowywania wartoÅ›ci licznika. Za kaÅ¼dym razem, gdy uÅ¼ytkownik kliknie przycisk, obserwator reaguje na to klikniÄ™cie, inkrementujÄ…c wartoÅ›Ä‡ licznika w obiekcie reaktywnym. NastÄ™pnie, przy uÅ¼yciu funkcji renderujÄ…cej renderText, aktualna wartoÅ›Ä‡ licznika jest wyÅ›wietlana w interfejsie. DziÄ™ki temu, interfejs jest reaktywny na akcje uÅ¼ytkownika, a wartoÅ›Ä‡ licznika automatycznie siÄ™ aktualizuje.\n\nPrzykÅ‚ad 3\nPrzykÅ‚ad zastosowania obserwatora w Shiny moÅ¼na przedstawiÄ‡ na prostym przypadku, gdzie uÅ¼ytkownik wpisuje tekst do pola tekstowego, a aplikacja reaguje na kaÅ¼dÄ… zmianÄ™ i wyÅ›wietla liczbÄ™ znakÃ³w wprowadzonych przez uÅ¼ytkownika. W tym przypadku uÅ¼yjemy funkcji obserwujÄ…cej (observe) do reakcji na zmiany w tekÅ›cie wprowadzonym przez uÅ¼ytkownika.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Licznik ZnakÃ³w\"),\n  textInput(\"tekst_input\", \"WprowadÅº tekst:\"),\n  textOutput(\"licznik_wynik\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Obserwator reagujÄ…cy na zmiany w tekÅ›cie wprowadzonym przez uÅ¼ytkownika\n  observe({\n    # Pobranie tekstu z pola tekstowego\n    wprowadzony_tekst &lt;- input$tekst_input\n    \n    # Obliczenie liczby znakÃ³w w tekÅ›cie\n    liczba_znakow &lt;- nchar(wprowadzony_tekst)\n    \n    # Aktualizacja wyniku w interfejsie\n    output$licznik_wynik &lt;- renderText({\n      paste(\"Liczba znakÃ³w: \", liczba_znakow)\n    })\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, funkcja observe Å›ledzi zmiany w polu tekstowym (textInput) o nazwie â€œtekst_inputâ€. Za kaÅ¼dym razem, gdy uÅ¼ytkownik wprowadza lub zmienia tekst, obserwator automatycznie aktualizuje wynik w interfejsie, wyÅ›wietlajÄ…c liczbÄ™ znakÃ³w wprowadzonych przez uÅ¼ytkownika. DziÄ™ki obserwatorowi, aplikacja jest reaktywna na zmiany w polu tekstowym bez koniecznoÅ›ci odÅ›wieÅ¼ania strony.\n\nPrzykÅ‚ad 4\nPrzykÅ‚ad wykorzystania renderPlot w Shiny moÅ¼e obejmowaÄ‡ generowanie dynamicznego wykresu w zaleÅ¼noÅ›ci od interakcji uÅ¼ytkownika. PoniÅ¼ej przedstawiam prosty scenariusz, w ktÃ³rym uÅ¼ytkownik moÅ¼e wybieraÄ‡ rodzaj wykresu (liniowy lub punktowy) oraz regulowaÄ‡ parametry, a aplikacja reaguje, generujÄ…c i wyÅ›wietlajÄ…c odpowiedni wykres.\n\nKodlibrary(shiny)\n\n# Definicja interfejsu uÅ¼ytkownika (UI)\nui &lt;- fluidPage(\n  titlePanel(\"Dynamiczny Wykres\"),\n  selectInput(\"typ_wykresu\", \"Wybierz typ wykresu:\",\n              choices = c(\"Linia\", \"Punkty\")),\n  sliderInput(\"ilosc_punktow\", \"Liczba punktÃ³w:\", min = 10, max = 100, value = 50),\n  plotOutput(\"wykres\")\n)\n\n# Definicja serwera\nserver &lt;- function(input, output) {\n  # Renderowanie wykresu w zaleÅ¼noÅ›ci od wyboru uÅ¼ytkownika\n  output$wykres &lt;- renderPlot({\n    typ_wykresu &lt;- input$typ_wykresu\n    ilosc_punktow &lt;- input$ilosc_punktow\n    \n    # Generowanie wykresu w zaleÅ¼noÅ›ci od wyboru uÅ¼ytkownika\n    if (typ_wykresu == \"Linia\") {\n      plot(1:ilosc_punktow, type = \"l\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    } else {\n      plot(1:ilosc_punktow, type = \"p\", main = \"Dynamiczny Wykres\", xlab = \"X\", ylab = \"Y\")\n    }\n  })\n}\n\n# Uruchomienie aplikacji Shiny\nshinyApp(ui, server)\n\n\nW tym przykÅ‚adzie, uÅ¼ytkownik ma moÅ¼liwoÅ›Ä‡ wyboru rodzaju wykresu (liniowy lub punktowy) za pomocÄ… rozwijanej listy (selectInput). Ponadto, suwak (sliderInput) pozwala regulowaÄ‡ liczbÄ™ punktÃ³w na wykresie. Funkcja renderPlot reaguje na zmiany w tych parametrach, generujÄ…c odpowiedni wykres w zaleÅ¼noÅ›ci od wyboru uÅ¼ytkownika. Wykres jest nastÄ™pnie renderowany w sekcji interfejsu o nazwie â€œwykresâ€.\n\nKolejnoÅ›Ä‡ wykonywanych czynnoÅ›ci w obiektach reaktywnych.\nW grafie reaktywnym w Shiny, kolejnoÅ›Ä‡ wykonywania czynnoÅ›ci jest okreÅ›lana przez zaleÅ¼noÅ›ci miÄ™dzy reaktywnymi elementami. W ogÃ³lnym przypadku, Shiny stosuje podejÅ›cie zwane â€œreactive programmingâ€, gdzie reaktywne elementy skÅ‚adajÄ… siÄ™ z obiektÃ³w reaktywnych, obserwatorÃ³w i funkcji renderujÄ…cych.\nKolejnoÅ›Ä‡ wykonywania czynnoÅ›ci w grafie reaktywnym moÅ¼e byÄ‡ ogÃ³lnie opisana nastÄ™pujÄ…co:\n\n\nInicjalizacja:\n\nAplikacja Shiny zaczyna od inicjalizacji interfejsu uÅ¼ytkownika (UI) oraz serwera.\nObiekty reaktywne sÄ… tworzone i inicjalizowane zgodnie z ich definicjami.\n\n\n\nObserwatory:\n\nObserwatory reagujÄ… na zmiany w danych i wykonujÄ… odpowiednie akcje.\nObserwatory sÄ… wywoÅ‚ywane w odpowiedzi na zdarzenia, takie jak klikniÄ™cia przyciskÃ³w, zmiany wartoÅ›ci pÃ³l tekstowych itp.\n\n\n\nReaktywne WyraÅ¼enia:\n\nReaktywne wyraÅ¼enia sÄ… obliczane w odpowiedzi na zmiany danych wejÅ›ciowych, na ktÃ³rych zaleÅ¼Ä….\nReaktywne wyraÅ¼enia to fragmenty kodu, ktÃ³re zwracajÄ… wartoÅ›Ä‡ i Å›ledzÄ… swoje zaleÅ¼noÅ›ci.\n\n\n\nFunkcje RenderujÄ…ce:\n\nFunkcje renderujÄ…ce sÄ… wywoÅ‚ywane w celu aktualizacji wynikÃ³w w interfejsie uÅ¼ytkownika na podstawie wartoÅ›ci zwrÃ³conych przez reaktywne wyraÅ¼enia.\nSÄ… one odpowiedzialne za generowanie treÅ›ci do wyÅ›wietlenia, np. w obszarze tekstowym, wykresie czy tabeli.\n\n\n\nAktualizacja UI:\n\nZaktualizowane wyniki sÄ… renderowane w interfejsie uÅ¼ytkownika.\n\n\n\nWaÅ¼ne jest zrozumienie, Å¼e Shiny automatycznie dba o zarzÄ…dzanie zaleÅ¼noÅ›ciami miÄ™dzy reaktywnymi elementami, co oznacza, Å¼e jeÅ›li jedna wartoÅ›Ä‡ zmieni siÄ™, to wszystkie elementy zaleÅ¼ne od niej zostanÄ… automatycznie zaktualizowane. DziÄ™ki temu podejÅ›ciu, Shiny zapewnia spÃ³jnoÅ›Ä‡ danych i dynamiczne dostosowywanie interfejsu uÅ¼ytkownika w zaleÅ¼noÅ›ci od akcji uÅ¼ytkownika lub zmian w danych.\nDla lepszego zrozumienia kolejnoÅ›ci wykonywanych dziaÅ‚aÅ„ oraz â€œmagiiâ€ jakiej dostarczajÄ… obiekty reaktywne, przeanalizujmy nastÄ™pujÄ…cy przykÅ‚ad:\nPrzykÅ‚ad 5\nNiech rdzeniem naszej1 aplikacji bÄ™dzie nastÄ™pujÄ…cy kod:\n\nKodui &lt;- fluidPage(\n  numericInput(\"a\", \"a\", value = 10),\n  numericInput(\"b\", \"b\", value = 1),\n  numericInput(\"c\", \"c\", value = 1),\n  plotOutput(\"x\"),\n  tableOutput(\"y\"),\n  textOutput(\"z\")\n)\n\nserver &lt;- function(input, output, session) {\n  rng &lt;- reactive(input$a * 2)\n  smp &lt;- reactive(sample(rng(), input$b, replace = TRUE))\n  bc &lt;- reactive(input$b * input$c)\n  \n  output$x &lt;- renderPlot(hist(smp()))\n  output$y &lt;- renderTable(max(smp()))\n  output$z &lt;- renderText(bc())\n}\n\n\nW naszej aplikacji wystÄ™pujÄ… trzy wejÅ›cia (a, b, c) z ustawionymi wartoÅ›ciami domyÅ›lnymi, trzy wyraÅ¼enia reaktywne (rng, smp, bc) oraz trzema reaktywnymi wyjÅ›ciami (x,y,z). W momencie inicjalizacji aplikacji stan je moÅ¼na opisaÄ‡ poniÅ¼szym grafem (wszystkie wyraÅ¼enia reaktywne i wyjÅ›cia sÄ… w stanie okreÅ›lanym jako invalidated):\n\n\n\n\nW momencie egzekucji aplikacji Shiny uruchamiane jest jedno losowe wejÅ›cie2 (oznaczmy to Å¼Ã³Å‚tym kolorem).\n\n\n\n\nPoniewaÅ¼ wywoÅ‚anie to potrzebuje wartoÅ›ci wyraÅ¼eÅ„ reaktywnych, to tworzy siÄ™ poÅ‚Ä…czenie z wyraÅ¼eniami reaktywnymi, od ktÃ³rych zaleÅ¼y wyjÅ›cie i inicjalizowane sÄ… wyraÅ¼enia reaktywne. Powiedzmy, Å¼e pierwszym wykonujÄ…cym siÄ™ wyjÅ›ciem byÅ‚o output$x. Wtedy wymagane jest wywoÅ‚anie obiektu reaktywnego smp().\n\n\n\n\nWartoÅ›Ä‡ smp() zaleÅ¼y za to od input$b, ktÃ³rego wartoÅ›Ä‡ jest okreÅ›lona, poniewaÅ¼ jest to wartoÅ›Ä‡ wejÅ›ciowa z domyÅ›lnÄ… wartoÅ›ciÄ… 1.\n\n\n\n\nWartoÅ›Ä‡ smp() zaleÅ¼y rÃ³wnieÅ¼ od innego wyraÅ¼enia reaktywnego rng(), ktÃ³re jest znÃ³w powiÄ…zane z wejÅ›ciem input$a. Analogicznie do powyÅ¼szej sytuacji odpowiednie poÅ‚Ä…czenia i egzekucje zostanÄ… wywoÅ‚ane.\n\n\n\n\nW ten sposÃ³b wszystko co jest potrzebne do egzekucji wyjÅ›cia output$x zostaÅ‚o policzone i moÅ¼na przejÅ›Ä‡ do wywoÅ‚ania wyjÅ›cia.\n\n\n\n\nPrzechodzimy zatem do egzekucji kolejnego wyjÅ›cia output$y.\n\n\n\n\nPoniewaÅ¼ output$y zaleÅ¼y tylko do smp() a to zostaÅ‚o juÅ¼ policzone i jego stan zostaÅ‚ â€œskeszowanyâ€, to nie trzeba po raz kolejny wywoÅ‚ywaÄ‡ tych obliczeÅ„3. W podobny sposÃ³b wywoÅ‚ywane sÄ… wszystkie wyjÅ›cia. Po egzekucji wszystkich wyjÅ›Ä‡ graf przedstawia siÄ™ nastÄ™pujÄ…co4:\n\n\n\n\nJeÅ›li nastÄ…pi zmiana wartoÅ›ci wejÅ›ciowej, wÃ³wczas wejÅ›cie to jest najpierw oznaczane jako invalidated, a nastÄ™pnie stan invalidated jest nadawany wszystkim obiektom zaleÅ¼nym od tego wejÅ›cia, co powoduje, Å¼e graf wyglÄ…da nastÄ™pujÄ…co:\n\n\n\n\nPonadto usuwane sÄ… poÅ‚Ä…czenia do obiektÃ³w w stanie invalidated i jednoczeÅ›nie przypisywana jest nowa wartoÅ›Ä‡ input$a.\n\n\n\n\nW dalszej kolejnoÅ›ci znÃ³w jedno z wyjÅ›Ä‡ uniewaÅ¼nionych (ang. invalidated) jest poddane egzekucji, ktÃ³ra pociÄ…ga za sobÄ… egzekucje tych wejÅ›Ä‡ i wyraÅ¼eÅ„ reaktywnych, ktÃ³re sÄ… wymagane do obliczenia wartoÅ›ci lub wyÅ›wietlenia wyjÅ›cia.\n\n\n\n\nDalej proces przebiega podobnie. Warto zauwaÅ¼yÄ‡, Å¼e pewne wejÅ›cia i wyraÅ¼enia reaktywne nie musiaÅ‚y siÄ™ wywoÅ‚ywaÄ‡ ponownie.\nPrzeanalizujmy jeszcze jeden krÃ³tki przykÅ‚ad aby lepiej zrozumieÄ‡ reaktywnoÅ›Ä‡ w Shiny.\nPrzykÅ‚ad 6\nAplikacja jest zbudowana nastÄ™pujÄ…co:\n\nKodui &lt;- fluidPage(\n  selectInput(\"choice\", \"A or B?\", c(\"a\", \"b\")),\n  numericInput(\"a\", \"a\", 0),\n  numericInput(\"b\", \"b\", 10),\n  textOutput(\"out\")\n)\n\nserver &lt;- function(input, output, session) {\n  output$out &lt;- renderText({\n    if (input$choice == \"a\") {\n      input$a\n    } else {\n      input$b\n    }\n  }) \n}\n\n\nMogÅ‚oby siÄ™ wydawaÄ‡, Å¼e graf dla niej wyglÄ…da nastÄ™pujÄ…co:\n\n\n\n\nAle poniewaÅ¼ Shiny dynamicznie rekonstruuje wykres po uniewaÅ¼nieniu danych wyjÅ›ciowych, w rzeczywistoÅ›ci wyglÄ…da on jak jeden z poniÅ¼szych wykresÃ³w, w zaleÅ¼noÅ›ci od wartoÅ›ci input$choice. Zapewnia to, Å¼e Shiny wykonuje minimalnÄ… iloÅ›Ä‡ pracy, gdy dane wejÅ›ciowe sÄ… uniewaÅ¼niane. W tym przypadku, jeÅ›li input$choice jest ustawiony na b, to wartoÅ›Ä‡ input$a nie wpÅ‚ywa na output$out i nie ma potrzeby jej ponownego obliczania.\n\n\n\n\nGdybyÅ›my nieznacznie zmienili funkcjÄ™ serwera, to wartoÅ›Ä‡ wyjÅ›cia stale by zaleÅ¼aÅ‚a od dwÃ³ch wejÅ›Ä‡.\n\nKodoutput$out &lt;- renderText({\n  a &lt;- input$a\n  b &lt;- input$b\n\n  if (input$choice == \"a\") {\n    a\n  } else {\n    b\n  }\n}) \n\n\n\n\n\n\n\n\nWskazÃ³wka\n\n\n\nChcÄ…c poznaÄ‡ reguÅ‚y panujÄ…ce w zÅ‚oÅ¼onych aplikacjach i zaleÅ¼noÅ›ci pomiÄ™dzy obiektami, moÅ¼na uÅ¼yÄ‡ pakietu reactlog. UruchamiajÄ…c przed wywoÅ‚aniem aplikacji funkcjÄ™ reactlog::reactlog_enable() powodujemy odpalenie serwera rejestrujÄ…cego poÅ‚Ä…czenia. MoÅ¼na przeglÄ…daÄ‡ na Å¼ywo zmiany stanÃ³w poszczegÃ³lnych obiektÃ³w przez wywoÅ‚anie Ctrl+F3 (Windows) lub Cmd+F3 (MacOS i Linux). Po zakoÅ„czeniu dziaÅ‚ania aplikacji moÅ¼emy teÅ¼ przejrzeÄ‡ log stanÃ³w uÅ¼ywajÄ…c shiny::reactlogShow()."
  },
  {
    "objectID": "wyk3.html#footnotes",
    "href": "wyk3.html#footnotes",
    "title": "WykÅ‚ad 3",
    "section": "Przypisy",
    "text": "Przypisy\n\nbezuÅ¼ytecznejâ†©ï¸\nnajczÄ™Å›ciej wyjÅ›cia sÄ… niezaleÅ¼ne, ale w przypadku zagnieÅ¼dÅ¼eÅ„ kolejnoÅ›Ä‡ wykonywania aplikacji uwzglÄ™dnia tÄ… zaleÅ¼noÅ›Ä‡â†©ï¸\nto czÄ™Å›Ä‡ magii reaktywnoÅ›ciâ†©ï¸\nstan ten siÄ™ nie zmienia aÅ¼ do zmiany jakiejÅ› wielkoÅ›ci wejÅ›ciowejâ†©ï¸"
  },
  {
    "objectID": "wyk4.html",
    "href": "wyk4.html",
    "title": "WykÅ‚ad 4",
    "section": "",
    "text": "Shiny oferuje wiele moÅ¼liwoÅ›ci do tworzenia interaktywnych i estetycznych layoutÃ³w dla aplikacji. MoÅ¼na korzystaÄ‡ z rÃ³Å¼nych funkcji i elementÃ³w interfejsu uÅ¼ytkownika, aby dostosowaÄ‡ wyglÄ…d i ukÅ‚ad strony. PoniÅ¼ej przedstawiam kilka kluczowych moÅ¼liwoÅ›ci i technik budowy layoutÃ³w w Shiny:\n\n\nFluid Grid Layout:\n\n\nfluidPage() to podstawowa funkcja sÅ‚uÅ¼Ä…ca do tworzenia responsywnego ukÅ‚adu strony.\nObejmuje rÃ³Å¼ne sekcje takie jak titlePanel, sidebarLayout, mainPanel itp., ktÃ³re pomagajÄ… w organizacji i strukturyzacji interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  sidebarLayout(\n    sidebarPanel(\n      # Elementy boczne, np. suwaki, przyciski\n    ),\n    mainPanel(\n      # GÅ‚Ã³wna zawartoÅ›Ä‡, np. wykresy, tabele\n    )\n  )\n)\n\n\n\n\nColumn Layout:\n\nMoÅ¼na uÅ¼ywaÄ‡ column() do podziaÅ‚u obszaru gÅ‚Ã³wnego na kolumny, co pozwala na bardziej elastyczny ukÅ‚ad strony.\nTo przydatne, gdy chcemy umieÅ›ciÄ‡ rÃ³Å¼ne elementy obok siebie.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  column(\n    width = 4,\n    # Pierwsza kolumna\n  ),\n  column(\n    width = 8,\n    # Druga kolumna\n  )\n)\n\n\n\n\nTabset Panel:\n\n\ntabsetPanel() umoÅ¼liwia organizacjÄ™ interfejsu za pomocÄ… zakÅ‚adek.\nKaÅ¼da zakÅ‚adka moÅ¼e mieÄ‡ wÅ‚asny zestaw elementÃ³w interfejsu.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  tabsetPanel(\n    tabPanel(\"ZakÅ‚adka 1\", \n             # ZawartoÅ›Ä‡ pierwszej zakÅ‚adki),\n    tabPanel(\"ZakÅ‚adka 2\", \n             # ZawartoÅ›Ä‡ drugiej zakÅ‚adki)\n  )\n)\n\n\n\n\nHTML i CSS:\n\nShiny umoÅ¼liwia wbudowanie kodu HTML i CSS do dostosowywania wyglÄ…du.\nFunkcje takie jak HTML() pozwalajÄ… na wstawienie kodu HTML bezpoÅ›rednio do interfejsu uÅ¼ytkownika.\n\n\nKodui &lt;- fluidPage(\n  titlePanel(\"TytuÅ‚ Aplikacji\"),\n  HTML(\"&lt;h2&gt;WÅ‚asny tytuÅ‚ HTML&lt;/h2&gt;\")\n)\n\n\n\n\nDashboard Layout:\n\nBiblioteka shinydashboard dostarcza narzÄ™dzi do tworzenia ukÅ‚adÃ³w przypominajÄ…cych klasyczne dashboardy.\nObejmuje funkcje takie jak dashboardPage(), dashboardHeader(), dashboardSidebar().\n\n\nKodlibrary(shinydashboard)\n\nui &lt;- dashboardPage(\n  dashboardHeader(title = \"Dashboard Title\"),\n  dashboardSidebar(\n    # Elementy boczne, np. suwaki, przyciski\n  ),\n  dashboardBody(\n    # GÅ‚Ã³wna zawartoÅ›Ä‡, np. wykresy, tabele\n  )\n)"
  },
  {
    "objectID": "wyk4.html#instalacja-edytora-shiny",
    "href": "wyk4.html#instalacja-edytora-shiny",
    "title": "WykÅ‚ad 4",
    "section": "Instalacja edytora Shiny",
    "text": "Instalacja edytora Shiny\nPolecam instalowaÄ‡ najnowszÄ… wersjÄ™ (dystrybucjÄ™) pakietu shinyuieditor ze strony Github autora.\n\nKodif (!requireNamespace(\"remotes\", quietly = TRUE))\n    install.packages(\"remotes\")\n\n# Install using the remotes package\nremotes::install_github(\"rstudio/shinyuieditor\")"
  },
  {
    "objectID": "wyk4.html#uÅ¼ycie-edytora-shiny",
    "href": "wyk4.html#uÅ¼ycie-edytora-shiny",
    "title": "WykÅ‚ad 4",
    "section": "UÅ¼ycie edytora Shiny",
    "text": "UÅ¼ycie edytora Shiny\nAby uÅ¼yÄ‡ po raz pierwszy edytora interfejsu Shiny naleÅ¼y uÅ¼yÄ‡ nastÄ™pujÄ…cej komendy:\n\nKodshinyuieditor::launch_editor(app_loc = \"shiny-app/\")\n\n\nJeÅ›li w katalogu roboczym znajduje siÄ™ aplikacja umieszczona w katalogu roboczym shiny-app, to edytor pozwoli na edycjÄ™ istniejÄ…cej juÅ¼ aplikacji1. Warunek odpalenia shinyuieditor dla istniejÄ…cej aplikacji jest to, Å¼e wskazany katalog zawiera tylko plik app.R. JeÅ›li wskazany katalog nie zawiera niczego, edytor odpala siÄ™ z moÅ¼liwoÅ›ciÄ… wyboru wyglÄ…du.\n\nKodshinyuieditor::launch_editor(app_loc = \"test_shinyuieditor/\")\n\n\n\n\nWyglÄ…d po wybraniu wyglÄ…du aplikacji\n\nDodawanie elementÃ³w do aplikacji\nPo wyborze wyglÄ…du gÅ‚Ã³wnego moÅ¼na przystÄ…piÄ‡ do edycji elementÃ³w wyglÄ…du. Warto zaczÄ…Ä‡ od tutorialu edytora klikajÄ…c w prawym gÃ³rnym rogu przycisk â€œTour Appâ€. NastÄ™pnie moÅ¼na przystÄ…piÄ‡ do edycji wyglÄ…du wg wÅ‚asnego uznania (patrzy przykÅ‚ad poniÅ¼ej)\n\nAby dodaÄ‡ nowy element interfejsu uÅ¼ytkownika do aplikacji, naleÅ¼y przeciÄ…gnÄ…Ä‡ Å¼Ä…dany element z panelu â€œElementsâ€. Miejsca, w ktÃ³rych moÅ¼na umieÅ›ciÄ‡ element, zostanÄ… podÅ›wietlone (jeÅ›li nie ma dostÄ™pnych miejsc, sprÃ³buj dodaÄ‡ nowy wiersz lub kolumnÄ™ do aplikacji, aby utworzyÄ‡ miejsce). Po przeciÄ…gniÄ™ciu elementu na dostÄ™pny obszar, zwolnij go, aby dodaÄ‡ go do aplikacji.\nPrzemieszczanie elementÃ³w aplikacji\nKliknij i przeciÄ…gnij element ui, ktÃ³ry chcesz przenieÅ›Ä‡. Podobnie jak w przypadku dodawania elementu, dostÄ™pne pozycje do przeniesienia elementu zostanÄ… podÅ›wietlone. PrzeciÄ…gnij element do Å¼Ä…danej nowej pozycji i upuÅ›Ä‡, aby go przenieÅ›Ä‡.\n\nWybÃ³r elementÃ³w aplikacji\nWybierz element, klikajÄ…c wewnÄ…trz niego. Po wybraniu elementu zostanie on oznaczony niebieskim konturem, a panel â€œPropertiesâ€ zostanie zaktualizowany o szczegÃ³Å‚y dotyczÄ…ce elementu. Alternatywnie moÅ¼na wybraÄ‡ element nadrzÄ™dny aktualnie wybranego elementu, klikajÄ…c nazwÄ™ elementu nadrzÄ™dnego w wizualizacji Å›cieÅ¼ki elementu w gÃ³rnej czÄ™Å›ci panelu â€œPropertiesâ€.\n\nUsuwanie elementÃ³w aplikacji\nWybierz element, po wybraniu elementu kliknij przycisk â€œDelete Elementâ€ w dolnej czÄ™Å›ci panelu â€œPropertiesâ€. NiektÃ³re elementy, takie jak grid_card(), bÄ™dÄ… rÃ³wnieÅ¼ wyÅ›wietlaÄ‡ przyciski usuwania bezpoÅ›rednio na samym elemencie, gdy nie ma w nim Å¼adnych elementÃ³w podrzÄ™dnych. MoÅ¼esz rÃ³wnieÅ¼ usunÄ…Ä‡ element za pomocÄ… klawisza delete/backspace.\n\nAktualizacja ustwieÅ„ elementÃ³w aplikacji\nWybierz element, po jego wybraniu zaktualizuj ustawienia za pomocÄ… panelu â€œPropertiesâ€. Gdy dane wejÅ›ciowe zostanÄ… zaktualizowane, zmiany zostanÄ… automatycznie zapisane i odzwierciedlone w skrypcie aplikacji i oknie podglÄ…du na Å¼ywo.\n\nWyÅ›wietl rozmiary elementÃ³w aplikacji\nNajechanie myszÄ… na lewy koniec wiersza lub gÃ³rÄ™ kolumny powoduje wyÅ›wietlenie widÅ¼etu rozmiaru.\n\nDodawanie wierszy i kolumn do aplikacji\nOtwÃ³rz widÅ¼et rozmiaru wiersza lub kolumny sÄ…siadujÄ…cy z miejscem, w ktÃ³rym chcesz dodaÄ‡ nowy wiersz lub kolumnÄ™. Na obu koÅ„cach widÅ¼etu znajdujÄ… siÄ™ przyciski plus (+), ktÃ³rych klikniÄ™cie spowoduje dodanie wiersza lub kolumny po odpowiednich stronach istniejÄ…cego wiersza lub kolumny.\n\nUsuwanie wierszy i kolumn aplikacji\nOtwÃ³rz widÅ¼et rozmiaru wiersza lub kolumny, ktÃ³ry chcesz usunÄ…Ä‡. NastÄ™pnie kliknij czerwonÄ… ikonÄ™ kosza, aby usunÄ…Ä‡ ten wiersz z ukÅ‚adu. JeÅ›li ikona kosza jest wyszarzona, wiersz lub kolumna nie mogÄ… zostaÄ‡ usuniÄ™te z powodu nazwanych obszarÃ³w siatki, ktÃ³re w caÅ‚oÅ›ci siÄ™ w nich znajdujÄ…. Najechanie myszkÄ… na zaszarzony przycisk spowoduje wskazanie tych obszarÃ³w siatki, dziÄ™ki czemu bÄ™dzie moÅ¼na je usunÄ…Ä‡ lub przenieÅ›Ä‡ w inne miejsce.\n\nZmiana rozmiarÃ³w wierszy i kolumn aplikacji\n\nLub teÅ¼ inaczej, otwÃ³rz widÅ¼et zmiany rozmiaru wiersza/kolumny UÅ¼yj kontrolek wprowadzania jednostek css w tym widÅ¼ecie, aby zaktualizowaÄ‡ rozmiar wiersza lub kolumny.\n\nWycofanie zmian w aplikacji\nUÅ¼yj przycisku cofnij dostÄ™pnego w prawym gÃ³rnym rogu aplikacji, aby przywrÃ³ciÄ‡ interfejs uÅ¼ytkownika aplikacji do stanu sprzed ostatniej wprowadzonej zmiany. JeÅ›li chcesz przywrÃ³ciÄ‡ wÅ‚aÅ›nie cofniÄ™tÄ… zmianÄ™, kliknij przycisk ponÃ³w po prawej stronie. ZarÃ³wno cofniÄ™cie, jak i ponowienie moÅ¼na rÃ³wnieÅ¼ wykonaÄ‡ za pomocÄ… skrÃ³tÃ³w klawiaturowych, odpowiednio cmd/ctrl + z i cmd/ctrl + shift + z.\n\nZatrzymanie edytora aplikacji\nDopÃ³ki argument stop_on_browser_close jest ustawiony na domyÅ›lnÄ… wartoÅ›Ä‡ TRUE, wÃ³wczas wszystko, co naleÅ¼y zrobiÄ‡, aby zatrzymaÄ‡ edytor, to zamknÄ…Ä‡ kartÄ™/okno przeglÄ…darki, w ktÃ³rej edytor jest aktualnie otwarty. Innym sposobem zakoÅ„czenia jest przerwanie serwera edytora poprzez naciÅ›niÄ™cie Control/Command + c w konsoli R uÅ¼ywanej do uruchomienia edytora."
  },
  {
    "objectID": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "href": "wyk4.html#zmiany-w-edytorze-a-zmiany-w-kodzie",
    "title": "WykÅ‚ad 4",
    "section": "Zmiany w edytorze a zmiany w kodzie",
    "text": "Zmiany w edytorze a zmiany w kodzie\nNaleÅ¼y pamiÄ™taÄ‡, Å¼e kaÅ¼da zmiana w edytorze skutkuje zmianami w kodzie definiujÄ…cym aplikacjÄ™. W drugÄ… stronÄ™ dziaÅ‚a to analogicznie. KaÅ¼da zmiana w kodzie znajduje swoje odwzorowanie w edytorze i preview."
  },
  {
    "objectID": "wyk4.html#podsumowanie-funkcjonalnoÅ›ci-edytora-aplikacji",
    "href": "wyk4.html#podsumowanie-funkcjonalnoÅ›ci-edytora-aplikacji",
    "title": "WykÅ‚ad 4",
    "section": "Podsumowanie funkcjonalnoÅ›ci edytora aplikacji",
    "text": "Podsumowanie funkcjonalnoÅ›ci edytora aplikacji\nshinyuieditor, jako narzÄ™dzie do projektowania interfejsu uÅ¼ytkownika dla aplikacji Shiny w R, ma swoje zalety i wady. Oto niektÃ³re z nich:\nZalety:\n\nÅatwoÅ›Ä‡ UÅ¼ycia - umoÅ¼liwia uÅ¼ytkownikom, w tym osobom nieprogramujÄ…cym, Å‚atwe tworzenie i modyfikowanie interfejsÃ³w uÅ¼ytkownika poprzez graficzny interfejs, co obniÅ¼a prÃ³g wejÅ›cia do tworzenia aplikacji Shiny.\nSzybki prototyping - pomaga w szybkim prototypowaniu aplikacji przez wizualne eksperymentowanie z rÃ³Å¼nymi ukÅ‚adami i elementami UI, co jest szczegÃ³lnie przydatne w fazie projektowania.\nInteraktywnoÅ›Ä‡ bez bezpoÅ›redniego kodowania - uÅ‚atwia dodawanie interaktywnych elementÃ³w do aplikacji bez koniecznoÅ›ci bezpoÅ›redniego pisania kodu, co moÅ¼e przyspieszyÄ‡ rozwÃ³j projektu.\nEdukacyjne korzyÅ›ci - moÅ¼e sÅ‚uÅ¼yÄ‡ jako narzÄ™dzie edukacyjne dla osÃ³b uczÄ…cych siÄ™ tworzenia aplikacji Shiny, pozwalajÄ…c na lepsze zrozumienie, jak rÃ³Å¼ne komponenty UI wspÃ³Å‚pracujÄ… ze sobÄ….\nWady:\n\nOgraniczenia dostosowywania - graficzne interfejsy uÅ¼ytkownika mogÄ… ograniczaÄ‡ moÅ¼liwoÅ›ci dostosowania w porÃ³wnaniu do bezpoÅ›redniego kodowania. Zaawansowane funkcje i niestandardowe zachowania mogÄ… wymagaÄ‡ rÄ™cznej edycji kodu.\nZaleÅ¼noÅ›Ä‡ od konkretnej implementacji - narzÄ™dzie takie jak shinyuieditor moÅ¼e nie byÄ‡ stale aktualizowane lub wspierane, co oznacza, Å¼e moÅ¼e nie byÄ‡ kompatybilne z najnowszymi wersjami Shiny lub R.\nKrzywa uczenia siÄ™ dla zaawansowanych funkcji - mimo Å¼e narzÄ™dzie to obniÅ¼a prÃ³g wejÅ›cia, zaawansowane funkcje Shiny mogÄ… nadal wymagaÄ‡ solidnej wiedzy o R i Shiny, co oznacza, Å¼e uÅ¼ytkownicy bÄ™dÄ… musieli inwestowaÄ‡ czas w naukÄ™ poza uÅ¼ywaniem samego edytora.\n\nPodsumowujÄ…c, shinyuieditor moÅ¼e byÄ‡ bardzo pomocny dla osÃ³b rozpoczynajÄ…cych pracÄ™ z Shiny oraz dla szybkiego prototypowania interfejsÃ³w uÅ¼ytkownika, ale dla zaawansowanych i wyspecjalizowanych potrzeb projektowych, bezpoÅ›rednie programowanie w R moÅ¼e oferowaÄ‡ wiÄ™kszÄ… elastycznoÅ›Ä‡ i kontrolÄ™."
  },
  {
    "objectID": "wyk4.html#footnotes",
    "href": "wyk4.html#footnotes",
    "title": "WykÅ‚ad 4",
    "section": "Przypisy",
    "text": "Przypisy\n\nNaleÅ¼y jednak, Å¼e musi to byÄ‡ aplikacja przygotowana wg schematu generowanego przez shinyuieditor , bo inaczej nie bÄ™dzie ona dziaÅ‚aÄ‡. PrzykÅ‚adowo uÅ¼ycie launch_editor do stockVis nie chciaÅ‚o dziaÅ‚aÄ‡.â†©ï¸"
  }
]