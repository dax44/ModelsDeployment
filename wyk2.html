<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="pl" xml:lang="pl"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.549">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Dariusz Majerek">

<title>Wdrażanie modeli uczenia maszynowego - Wykład 2</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-text-highlighting-styles">
<link href="site_libs/quarto-html/quarto-syntax-highlighting-dark.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="site_libs/bootstrap/bootstrap-dark.min.css" rel="prefetch" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script src="site_libs/quarto-contrib/videojs/video.min.js"></script>
<link href="site_libs/quarto-contrib/videojs/video-js.css" rel="stylesheet">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "Brak wyników",
    "search-matching-documents-text": "dopasowane dokumenty",
    "search-copy-link-title": "Kopiuj link do wyszukiwania",
    "search-hide-matches-text": "Ukryj dodatkowe dopasowania",
    "search-more-match-text": "więcej dopasowań w tym dokumencie",
    "search-more-matches-text": "więcej dopasowań w tym dokumencie",
    "search-clear-button-title": "Wyczyść",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Anuluj",
    "search-submit-button-title": "Zatwierdź",
    "search-label": "Szukaj"
  }
}</script>


</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="./index.html">
    <span class="navbar-title">Wdrażanie modeli uczenia maszynowego</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Szukaj"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Przełącz nawigację" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="./Wdrażanie modeli uczenia maszynowego.html"> 
<span class="menu-text">Wstęp</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./wyk1.html"> 
<span class="menu-text">Wykład 1</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link active" href="./wyk2.html" aria-current="page"> 
<span class="menu-text">Wykład 2</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./wyk3.html"> 
<span class="menu-text">Wykład 3</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="./wyk4.html"> 
<span class="menu-text">Wykład 4</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
          <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Przełącz tryb ciemny"><i class="bi"></i></a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Wykład 2</h1>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Autor</div>
    <div class="quarto-title-meta-contents">
             <p>Dariusz Majerek </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<section id="kontynuacja-pracy-z-git-i-github" class="level1">
<h1>Kontynuacja pracy z Git i GitHub</h1>
<p>Przypominając sytuację w jakiej się znajdujemy… utworzyliśmy repozytorium o nazwie <code>DariuszMajerek/Github_tests</code>. Dokonaliśmy w nim kilku zmian commitowanych za każdym razem. Podgląd tych zmian możemy dokonać przez przegląd commitów.</p>
<pre class="{bash}"><code>git log</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 12.58.33.png" class="img-fluid figure-img"></p>
<figcaption>Logi z commit</figcaption>
</figure>
</div>
<section id="fork-repo" class="level2">
<h2 class="anchored" data-anchor-id="fork-repo">Fork repo</h2>
<p>Zmian możemy dokonywać również w repo, których autorem jest ktoś inny. Najpierw należy wykonać <code>fork</code> takiego repo, a następnie dokonać zmian. Dokonamy najpierw forka przykładowego repo <code>octocat/Spoon-Knife</code><a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a>. Można tego dokonać na stronie repo kliknąć przycisk <code>fork</code></p>
<p><img src="images/Zrzut ekranu 2024-01-6 o 13.08.25.png" class="img-fluid"></p>
<p>Zostaniesz wówczas zapytany czy chcesz skopiować jedynie główną gałąź repo i pod jaką nazwą chcesz go skopiować.</p>
<p><img src="images/Zrzut ekranu 2024-01-6 o 13.13.16.png" class="img-fluid"></p>
<p>Wybranie opcji domyślnych jest zalecane, jeśli chcemy dokonać później tzw pull request (o tym za chwilę). Po skopiowaniu fork cudzego repo na moim koncie GitHub wygląda następująco. Pod nazwą repo widnieje nazwa repo skąd zostało ono skopiowane.</p>
<p><img src="images/Zrzut ekranu 2024-01-6 o 13.13.38.png" class="img-fluid"></p>
<p>Kopiowanie czyjegoś repo robimy kiedy chcemy zmodyfikować kod istniejący bez ingerencji w oryginalny kod (oryginalny stan repo) a następnie go (poprawionego) wypchnąć. Póki co fork czyjegoś repo znajduje się jedynie w naszym repo zdalnym. Aby pobrać go do repo lokalnego, trzeba wykonać następujące czynności:</p>
<ol type="1">
<li>przejść do katalogu, w którym chcemy zapisać kopię repo</li>
<li>skopiować adres dostępu do kopiowanego repo (HTTPS lub SSH)</li>
<li>wykonać polecenie <code>git clone &lt;forked_repo_url&gt;</code>, gdzie <code>&lt;forked_repo_url&gt;</code> oznacza właśnie skopiowany adres repo.</li>
</ol>
<pre class="{bash}"><code># najpierw sprawdź miejsce w którym się znajdujesz (katalog roboczy)
pwd

# przejdź do katalogu wyżej (tam chcę skopiować repo)
cd ..

# sklonuj forka repo
git clone git@github.com:DariuszMajerek/Spoon-Knife.git</code></pre>
<p><img src="images/Zrzut ekranu 2024-01-6 o 13.31.34.png" class="img-fluid"></p>
<div class="callout callout-style-default callout-warning callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Ostrzeżenie
</div>
</div>
<div class="callout-body-container callout-body">
<p>Znów czujne oko wychwyci, że podając adres repo zmieniłem go z <code>git@github.com:DariuszMajerek/Spoon-Knife.git</code> na <code>git@github.com-work:DariuszMajerek/Spoon-Knife.git</code>, to dlatego, że na komputerze, na którym to robię mam połączone dwa konta GitHub i aby je rozróżniać stosuję taką podmianę.</p>
</div>
</div>
<p>Po skopiowaniu repo na dysk lokalny, możemy przystąpić do dokonywania modyfikacji w repo. Na potrzeby przykładu zmienimy wartości w pliku <code>style.css</code>. W części dotyczącej stylu paragrafu zmienimy dwie wartości:</p>
<ul>
<li>oryginalne wartości</li>
</ul>
<pre><code>p {
  display: block;
  width: 400px;
  margin: 50px auto;
  font: 30px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;
}</code></pre>
<ul>
<li>wartości po zmianach</li>
</ul>
<pre><code>p {
  display: block;
  width: 500px;
  margin: 50px auto;
  font: 20px Monaco,"Courier New","DejaVu Sans Mono","Bitstream Vera Sans Mono",monospace;
}</code></pre>
<pre class="{bash}"><code># sprawdźmy czy zmiany zostały zarejestrowane
git status

# możemy ponadto podejrzeć zmiany za pomocą
git diff</code></pre>
<p><img src="images/Zrzut ekranu 2024-01-6 o 13.50.02.png" class="img-fluid"></p>
<p>Teraz zmiany trzeba zatwierdzić i commitować.</p>
<pre class="{bash}"><code>git add .
git commit -m "style changes"</code></pre>
<p>Następnie wypychamy zmiany do zdalnego repo. Najpierw możemy sprawdzić czy adres zdalnego repo jest ustalony.</p>
<pre class="{bash}"><code># sprawdzamy czy adres zdalenego repo istnieje
git remote -v

# skoro tak to wypychamy główną gałąź do repo zdalnego
git push origin main</code></pre>
<p><img src="images/Zrzut ekranu 2024-01-6 o 13.56.39.png" class="img-fluid"></p>
<p>Teraz zarówno repo lokalne, jak i zdalne mają tą samą zawartość i tą samą wersję. Częściej jednak w tego typu współpracy nad kodem umieszczonym w repo będziemy tworzyli własną gałąź w forkowanym repo.</p>
<div class="callout callout-style-default callout-caution callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Zagrożenie
</div>
</div>
<div class="callout-body-container callout-body">
<p>Za każdym razem, gdy pracujesz nad wspólnym projektem, ty i inni programiści współtworzący repozytorium będziecie mieli różne pomysły na nowe funkcje lub poprawki jednocześnie. Niektóre z tych nowych funkcji nie zajmą dużo czasu na wdrożenie, ale niektóre z nich będą trwały. Z tego powodu ważne jest rozgałęzienie repozytorium, aby móc zarządzać przepływem pracy, izolować swój kod i kontrolować, które funkcje wracają do głównej gałęzi repozytorium projektu.</p>
</div>
</div>
</section>
<section id="kontrola-wersji---cofanie-zmian" class="level2">
<h2 class="anchored" data-anchor-id="kontrola-wersji---cofanie-zmian">Kontrola wersji - cofanie zmian</h2>
<p>W tym celu najpierw nauczymy się cofać zmiany dokonane zarówno w repo lokalnym i zdalnym. Zacznijmy od sprawdzenia logów repo.</p>
<pre class="{bash}"><code>git log</code></pre>
<p><img src="images/Zrzut ekranu 2024-01-6 o 14.21.52.png" class="img-fluid"></p>
<p>Widać, że oprócz trzech zmian repo dokonanych przez autora (octocat) jest zmiana stylu dokona przeze mnie. Logi są zawsze wyświetlane w kolejności od najaktualniejszego (na górze) do najstarszego (na dole). Możemy się cofnąć do stanu zachowanego dowolnym commitem 💪.</p>
<p>Cofanie stanu repo można wykonać na dwa sposoby:</p>
<ul>
<li>poprzez <code>git reset</code></li>
<li>oraz <code>git revert</code></li>
</ul>
<p>Działanie obu tych funkcji różni się nieco i obie je omówimy.</p>
<section id="reset" class="level3">
<h3 class="anchored" data-anchor-id="reset">Reset</h3>
<p>Polecenie <code>git reset</code> służy do cofnięcia zmian w katalogu roboczym i powrotu do określonego zatwierdzenia, jednocześnie odrzucając wszystkie zatwierdzenia wykonane po nim. Na przykład, wyobraź sobie, że wykonałeś dziesięć commitów. Użycie <code>git reset</code> na pierwszym zatwierdzeniu usunie wszystkie dziewięć zatwierdzeń, przenosząc cię z powrotem do etapu pierwszego zatwierdzenia. Przed użyciem <code>git reset</code> ważne jest, aby wziąć pod uwagę rodzaj zmian, które planujesz wprowadzić; w przeciwnym razie stworzysz więcej chaosu niż pożytku.</p>
<div class="callout callout-style-default callout-important callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-title-container flex-fill">
Ważne
</div>
</div>
<div class="callout-body-container callout-body">
<p>Możesz użyć wielu opcji wraz z <code>git reset</code>, ale to są te główne. Każda z nich jest używana w zależności od konkretnej sytuacji: <code>git reset --soft</code>, <code>git reset --mixed</code> i <code>git reset --hard</code>.</p>
</div>
</div>
<p>Flaga <code>--soft</code> ma na celu zmianę odniesienia <code>HEAD</code> (stanu gdzie znajduje się ostatni commit na komputerze lokalnym) do określonego commita. Na przykład, jeśli zdamy sobie sprawę, że zapomnieliśmy dodać plik do commita, możemy cofnąć się za pomocą <code>--soft</code> w następujący sposób:</p>
<ul>
<li><code>git reset --soft HEAD~n</code> aby cofnąć się do zatwierdzenia z określonym odniesieniem (n).</li>
<li><code>git reset --soft HEAD~1</code> cofa do ostatniego zatwierdzenia.</li>
<li><code>git reset --soft &lt;commit ID&gt;</code> cofa <code>HEAD</code> do <code>&lt;commit ID&gt;</code></li>
</ul>
<p>gdzie <code>&lt;commit ID&gt;</code> jest tagiem commita. Opcja <code>--soft</code> nie wymaga ponownego dodawania plików, które zostały dodane w poprzednim commicie.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 16.44.54.png" class="img-fluid figure-img"></p>
<figcaption>Przykład użycia git reset –soft HEAD</figcaption>
</figure>
</div>
<p>Flaga <code>--mixed</code> jest domyślnym ustawieniem polecenia <code>git reset</code>. Uruchomienie tego polecenia ma dwa skutki:</p>
<ol type="1">
<li>od-commituje wszystkie zmiany</li>
<li>usuwa je ze <em>Stage</em></li>
</ol>
<p>Używamy jej gdy np. w commitowanym stanie repo uznaliśmy, że nie warto go wypychać, ponieważ jeden z plików, który commitujemy ma jeszcze błędy i należy go poprawić przed <code>git push</code>.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 16.47.04.png" class="img-fluid figure-img"></p>
<figcaption>Przykład użycia git reset –mixed HEAD</figcaption>
</figure>
</div>
<p>Flaga <code>--hard</code> powinna być używana z rozmysłem, ponieważ może wyrządzić sporo szkód. Opcja <code>--hard</code> odrzuca wszelkie zmiany dokonane w śledzonych plikach w katalogu roboczym i resetuje je do stanu określonego commita.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 16.48.54.png" class="img-fluid figure-img"></p>
<figcaption>Przykład użycia git reset –hard HEAD</figcaption>
</figure>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/git_reset.webp" class="img-fluid figure-img"></p>
<figcaption>Schemat działania git reset</figcaption>
</figure>
</div>
</section>
<section id="revert" class="level3">
<h3 class="anchored" data-anchor-id="revert">Revert</h3>
<p>Polecenie <code>git revert</code> służy do utworzenia nowego commitu, który cofa zmiany wprowadzone w określonym poprzednim commicie. W przeciwieństwie do <code>git reset</code>, które przemieszcza wskaźnik HEAD i gałęzi do innego commitu, <code>git revert</code> tworzy nowy commit, który odwraca zmiany w poprzednim commicie.</p>
<p>Pokażę to na przykładzie, korzystając z wcześniejszego scenariusza z trzema commitami i trzema plikami (<code>plik1.txt</code>, <code>plik2.txt</code>, <code>plik3.txt</code>).</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 17.09.51.png" class="img-fluid figure-img"></p>
<figcaption>Przykład użycia git revert</figcaption>
</figure>
</div>
<p>Po użyciu <code>git revert</code> nie ma żadnych niezatwierdzonych zmian. Wprowadza nowy commit, który cofa zmiany wprowadzone w poprzednim commicie. Dzięki temu możemy utrzymać spójność historii i uniknąć problemów z innymi współpracownikami, którzy już pobrali nasze zmiany.</p>
<p>Różnice między <code>git revert</code> a <code>git reset</code>:</p>
<ul>
<li><code>git revert</code> wprowadza nowy commit, zachowując historię.</li>
<li><code>git reset</code> przemieszcza wskaźnik HEAD, usuwając zmiany z historii.</li>
<li><code>git revert</code> jest bezpieczniejsze do stosowania w publicznych repozytoriach, ponieważ nie wymaga modyfikowania historii, co może utrudnić współpracę z innymi programistami.</li>
</ul>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 17.12.34.png" class="img-fluid figure-img"></p>
<figcaption>Schemat działania git revert</figcaption>
</figure>
</div>
<p>Teraz możemy wrócić do zadania usunięcia zmian (ostatniego commita) w repo <code>DariuszMajerek/Spoon-Knife</code>. Musimy wykonać następujące czynności w katalogu Spoon-Knife.</p>
<p>Jeśli chcesz przejść do wcześniejszej wersji zdalnego repozytorium w tej samej gałęzi i usunąć najnowsze commity, można skorzystać z polecenia <code>git reset</code> w trybie <code>--hard</code>. Jednak pamiętaj, że <code>git reset --hard</code> jest operacją radykalną i trwale usuwa commity, więc bądź pewien, że chcesz to zrobić, ponieważ stracisz historię tych commitów.</p>
<p>Oto kroki, które możesz podjąć:</p>
<ol type="1">
<li>Sprawdź dostępne gałęzie zdalne:</li>
</ol>
<div class="sourceCode" id="cb9"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> branch <span class="at">-r</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="2" type="1">
<li>Pobierz najnowsze zmiany z repozytorium zdalnego:</li>
</ol>
<div class="sourceCode" id="cb10"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> fetch origin</span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="3" type="1">
<li>Przejdź do gałęzi, w której chcesz cofnąć zmiany:</li>
</ol>
<div class="sourceCode" id="cb11"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># to nie jest konieczne bo już jesteśmy w tej gałęzi</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="co"># ale nie zawsze tak będzie</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> checkout main</span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<ol start="4" type="1">
<li>Zidentyfikuj commit, do którego chcesz się cofnąć:</li>
</ol>
<div class="sourceCode" id="cb12"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> log</span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Odnajdź hasz commitu, do którego chcesz się cofnąć.</p>
<ol start="5" type="1">
<li>Użyj <code>git reset --hard</code> do cofnięcia zmian:</li>
</ol>
<div class="sourceCode" id="cb13"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> reset <span class="at">--hard</span> hasz-commitu</span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Zastąp <code>hasz-commitu</code> odpowiednim hasłem commitu, do którego chcesz się cofnąć.</p>
<ol start="6" type="1">
<li>Przesuń zmiany na repozytorium zdalne:</li>
</ol>
<div class="sourceCode" id="cb14"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> push origin main <span class="at">--force</span></span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Uwaga: Użycie <code>--force</code> jest konieczne, ponieważ zmieniasz historię i wymagane jest przeforsowanie zmian na repozytorium zdalne. Jednak bądź bardzo ostrożny, używając <code>--force</code>, ponieważ może to wpłynąć na innych współpracowników korzystających z tej gałęzi.</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 19.46.35.png" class="img-fluid figure-img"></p>
<figcaption>Przejście do stanu z wcześniejszego commita</figcaption>
</figure>
</div>
<p>W ten sposób wróciliśmy do oryginalnego stanu pobranego repo <code>octocat/Spoon-Knife</code>. Możemy teraz przystąpić do tworzenia własnej gałęzi w tym repo i dokonania w nim zmian. Na końcu będziemy chcieli dokonać łączenia gałęzi (naszej po poprawkach) z oryginalną poprzez <em>pull request</em>.</p>
</section>
</section>
<section id="działanie-na-gałęziach" class="level2">
<h2 class="anchored" data-anchor-id="działanie-na-gałęziach">Działanie na gałęziach</h2>
<pre class="{bash}"><code># zaczynamy od sprawdzenia w której gałęzi jesteśmy
git branch

# teraz tworzymy nową gałąź w obecnej
git branch my_branch

# teraz do niej przechodzimy
git checkout my_branch

# dwie ostatnie czynności można wykonać jedną komendą
git checkout -b my_branch</code></pre>
<p>Teraz dokonujemy tych samych zmian w pliku <code>styles.css</code>, których dokonaliśmy w gałęzi głównej.</p>
<pre class="{bash}"><code># po zmianach sprawdzamy status repo w gałęzi my_branch
git status

# widać że zmiany nastąpiły więc je dodajemy do Stage
git add styles.css

# commitujemy zmiany
git commit -m "style changes"

# wypychamy zmiany/commita do nowej gałęzi
git push origin my_branch</code></pre>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="images/Zrzut ekranu 2024-01-6 o 20.02.31.png" class="img-fluid figure-img"></p>
<figcaption>Przebieg pracy nad utworzeniem nowej gałęzi i dodaniem do niej zmian</figcaption>
</figure>
</div>
<p>Jak można zauważyć na powyższym obrazku system sugeruje dokonanie <em>pull request,</em> czyli prośby (w tym przypadku skierowanej do octocat) o połączenie (czyli <em>merge</em>) gałęzi głównej z gałęzią <code>my_branch</code>.</p>
<p>Aby dokonać <em>pull request</em> nowej gałęzi w systemie Git, zazwyczaj korzysta się z platformy do zarządzania kodem, takiej jak GitHub, GitLab lub Bitbucket. Poniżej przedstawiam ogólny przewodnik krok po kroku, korzystając z GitHuba jako przykładu. Procedury na innych platformach są zbliżone, ale mogą się różnić w szczegółach.</p>
<ol type="1">
<li><p>Utwórz nową gałąź w lokalnym repozytorium:</p>
<div class="sourceCode" id="cb17"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> checkout <span class="at">-b</span> nazwa-nowej-gałęzi</span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>Wykonaj pracę na tej gałęzi i zatwierdzaj zmiany.</p></li>
<li><p>Push nowej gałęzi na repozytorium zdalne:</p>
<div class="sourceCode" id="cb18"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> push origin nazwa-nowej-gałęzi</span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>To przesyła nową gałąź na repozytorium zdalne<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>.</p></li>
<li><p>Otwórz przeglądarkę i przejdź do repozytorium na GitHubie.</p></li>
<li><p>Przejdź do nowej gałęzi - w zakładce “Branch” na stronie repozytorium, wybierz nową gałąź.</p></li>
<li><p>Utwórz Pull Request:</p>
<ul>
<li>Na stronie gałęzi wybierz przycisk “New pull request”.</li>
<li>Wybierz gałąź docelową, zazwyczaj jest to <code>master</code> lub inna główna gałąź.</li>
</ul></li>
<li><p>Uzupełnij informacje dotyczące Pull Request:</p>
<ul>
<li>Uzupełnij tytuł i opis dotyczący zmiany, które wprowadziłeś.</li>
<li>Sprawdź, czy Pull Request spełnia oczekiwania dotyczące kodu i testów.</li>
</ul></li>
<li><p>Utwórz Pull Request - kliknij przycisk “Create pull request”, aby utworzyć Pull Request.</p></li>
<li><p>Dokonaj przeglądu i zatwierdź:</p>
<ul>
<li>Inni członkowie zespołu mogą dokonać przeglądu zmian.</li>
<li>Po zakończonym przeglądzie i zatwierdzeniu zmian, Pull Request może być scalony (merged).</li>
</ul></li>
<li><p>Zaktualizuj lokalne repozytorium - po scaleniu Pull Requesta na repozytorium zdalnym, zaktualizuj swoje lokalne repozytorium:</p>
<div class="sourceCode" id="cb19"><pre class="sourceCode bash code-with-copy"><code class="sourceCode bash"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> checkout master</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">git</span> pull origin master</span></code><button title="Kopiuj do schowka" class="code-copy-button"><i class="bi"></i></button></pre></div>
<p>W ten sposób przyniesiesz zmiany z gałęzi docelowej (np. <code>master</code>) do swojego lokalnego repozytorium.</p></li>
</ol>
<div class="quarto-video"><video id="video_shortcode_videojs_video1" class="video-js vjs-default-skin vjs-fluid" controls="" preload="auto" data-setup="{}" title=""><source src="images/PullRequest.mp4"></video></div>


</section>
</section>


<div id="quarto-appendix" class="default"><section id="footnotes" class="footnotes footnotes-end-of-document" role="doc-endnotes"><h2 class="anchored quarto-appendix-heading">Przypisy</h2>

<ol>
<li id="fn1"><p>Ewentualne zmiany nie popsują niczego w tym repo, bo jest ono przygotowane do tego typu testów.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>Dotąd mamy wszystko zrobione<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section></div></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Skopiowano!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Skopiowano!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<script>videojs(video_shortcode_videojs_video1);</script>




</body></html>